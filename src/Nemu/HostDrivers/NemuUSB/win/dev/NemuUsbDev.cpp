/* $Id: NemuUsbDev.cpp $ */
/** @file
 * NemuUsbDev.cpp - USB device.
 */
/*
 * Copyright (C) 2011-2015 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */
#include "NemuUsbCmn.h"
#include <iprt/assert.h>
#include <Nemu/log.h>

#define NEMUUSB_MEMTAG 'bUBV'

DECLHIDDEN(PVOID) nemuUsbMemAlloc(SIZE_T cbBytes)
{
    PVOID pvMem = ExAllocatePoolWithTag(NonPagedPool, cbBytes, NEMUUSB_MEMTAG);
    Assert(pvMem);
    return pvMem;
}

DECLHIDDEN(PVOID) nemuUsbMemAllocZ(SIZE_T cbBytes)
{
    PVOID pvMem = nemuUsbMemAlloc(cbBytes);
    if (pvMem)
    {
        RtlZeroMemory(pvMem, cbBytes);
    }
    return pvMem;
}

DECLHIDDEN(VOID) nemuUsbMemFree(PVOID pvMem)
{
    ExFreePoolWithTag(pvMem, NEMUUSB_MEMTAG);
}

NEMUUSB_GLOBALS g_NemuUsbGlobals = {0};

static NTSTATUS nemuUsbDdiAddDevice(PDRIVER_OBJECT pDriverObject,
            PDEVICE_OBJECT pPDO)
{
    PDEVICE_OBJECT pFDO = NULL;
    NTSTATUS Status = IoCreateDevice(pDriverObject,
            sizeof (NEMUUSBDEV_EXT),
            NULL, /* IN PUNICODE_STRING pDeviceName OPTIONAL */
            FILE_DEVICE_UNKNOWN, /* IN DEVICE_TYPE DeviceType */
            FILE_AUTOGENERATED_DEVICE_NAME, /* IN ULONG DeviceCharacteristics */
            FALSE, /* IN BOOLEAN fExclusive */
            &pFDO);
    Assert(Status == STATUS_SUCCESS);
    if (Status == STATUS_SUCCESS)
    {
        PNEMUUSBDEV_EXT pDevExt = (PNEMUUSBDEV_EXT)pFDO->DeviceExtension;
        /* init Device Object bits */
        pFDO->Flags |= DO_DIRECT_IO;
        if (pPDO->Flags & DO_POWER_PAGABLE)
            pFDO->Flags |= DO_POWER_PAGABLE;


        /* now init our state bits */

        pDevExt->cHandles = 0;

        pDevExt->pFDO = pFDO;
        pDevExt->pPDO = pPDO;
        pDevExt->pLowerDO = IoAttachDeviceToDeviceStack(pFDO, pPDO);
        Assert(pDevExt->pLowerDO);
        if (pDevExt->pLowerDO)
        {
            nemuUsbDdiStateInit(pDevExt);
            Status = nemuUsbRtInit(pDevExt);
            if (Status == STATUS_SUCCESS)
            {
                /* we're done! */
                pFDO->Flags &= ~DO_DEVICE_INITIALIZING;
                return STATUS_SUCCESS;
            }

            IoDetachDevice(pDevExt->pLowerDO);
        }
        else
            Status = STATUS_NO_SUCH_DEVICE;

        IoDeleteDevice(pFDO);
    }

    return Status;
}

static VOID nemuUsbDdiUnload(PDRIVER_OBJECT pDriverObject)
{
    LogRel(("NemuUsb::DriverUnload. Built Date (%s) Time (%s)\n", __DATE__, __TIME__));
    NemuDrvToolStrFree(&g_NemuUsbGlobals.RegPath);

    nemuUsbRtGlobalsTerm();

    PRTLOGGER pLogger = RTLogRelSetDefaultInstance(NULL);
    if (pLogger)
    {
        RTLogDestroy(pLogger);
    }
    pLogger = RTLogSetDefaultInstance(NULL);
    if (pLogger)
    {
        RTLogDestroy(pLogger);
    }
}

static NTSTATUS nemuUsbDispatchCreate(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PNEMUUSBDEV_EXT pDevExt = (PNEMUUSBDEV_EXT)pDeviceObject->DeviceExtension;
    NTSTATUS Status = STATUS_INVALID_HANDLE;
    do
    {
        if (nemuUsbPnPStateGet(pDevExt) != ENMNEMUUSB_PNPSTATE_STARTED)
        {
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }

        PIO_STACK_LOCATION pSl = IoGetCurrentIrpStackLocation(pIrp);
        PFILE_OBJECT pFObj = pSl->FileObject;
        if (!pFObj)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        pFObj->FsContext = NULL;

        if (pFObj->FileName.Length)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        Status = nemuUsbRtCreate(pDevExt, pIrp);
        if (!NT_SUCCESS(Status))
        {
            AssertFailed();
            break;
        }

        ASMAtomicIncU32(&pDevExt->cHandles);
        Status = STATUS_SUCCESS;
        break;
    } while (0);

    Status = NemuDrvToolIoComplete(pIrp, Status, 0);
    return Status;
}

static NTSTATUS nemuUsbDispatchClose(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PNEMUUSBDEV_EXT pDevExt = (PNEMUUSBDEV_EXT)pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION pSl = IoGetCurrentIrpStackLocation(pIrp);
    PFILE_OBJECT pFObj = pSl->FileObject;
    NTSTATUS Status = STATUS_SUCCESS;
    Assert(pFObj);
    Assert(!pFObj->FileName.Length);
    Status = nemuUsbRtClose(pDevExt, pIrp);
    if (NT_SUCCESS(Status))
    {
        ASMAtomicDecU32(&pDevExt->cHandles);
    }
    else
    {
        AssertFailed();
    }
    Status = NemuDrvToolIoComplete(pIrp, Status, 0);
    return Status;
}

static NTSTATUS nemuUsbDispatchDeviceControl(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PNEMUUSBDEV_EXT pDevExt = (PNEMUUSBDEV_EXT)pDeviceObject->DeviceExtension;
    NTSTATUS Status = STATUS_INVALID_HANDLE;
    if (nemuUsbDdiStateRetainIfStarted(pDevExt))
    {
        return nemuUsbRtDispatch(pDevExt, pIrp);
    }
    else
    {
        Status = STATUS_INVALID_DEVICE_STATE;
    }

    Status = NemuDrvToolIoComplete(pIrp, Status, 0);
    return Status;
}

static NTSTATUS nemuUsbDispatchCleanup(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PNEMUUSBDEV_EXT pDevExt = (PNEMUUSBDEV_EXT)pDeviceObject->DeviceExtension;
    NTSTATUS Status = STATUS_SUCCESS;
    Status = NemuDrvToolIoComplete(pIrp, Status, 0);
    return Status;
}

static NTSTATUS nemuUsbDevAccessDeviedDispatchStub(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PNEMUUSBDEV_EXT pDevExt = (PNEMUUSBDEV_EXT)pDeviceObject->DeviceExtension;
    if (!nemuUsbDdiStateRetainIfNotRemoved(pDevExt))
    {
        NemuDrvToolIoComplete(pIrp, STATUS_DELETE_PENDING, 0);
        return STATUS_DELETE_PENDING;
    }

    NTSTATUS Status = STATUS_ACCESS_DENIED;
    Status = NemuDrvToolIoComplete(pIrp, Status, 0);

    nemuUsbDdiStateRelease(pDevExt);

    return Status;
}

static NTSTATUS nemuUsbDispatchSystemControl(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
    PNEMUUSBDEV_EXT pDevExt = (PNEMUUSBDEV_EXT)pDeviceObject->DeviceExtension;
    if (!nemuUsbDdiStateRetainIfNotRemoved(pDevExt))
    {
        NemuDrvToolIoComplete(pIrp, STATUS_DELETE_PENDING, 0);
        return STATUS_DELETE_PENDING;
    }

    IoSkipCurrentIrpStackLocation(pIrp);

    NTSTATUS Status = IoCallDriver(pDevExt->pLowerDO, pIrp);

    nemuUsbDdiStateRelease(pDevExt);

    return Status;
}

static NTSTATUS nemuUsbDispatchRead(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
#ifdef DEBUG_misha
    AssertFailed();
#endif
    return nemuUsbDevAccessDeviedDispatchStub(pDeviceObject, pIrp);
}

static NTSTATUS nemuUsbDispatchWrite(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)
{
#ifdef DEBUG_misha
    AssertFailed();
#endif
    return nemuUsbDevAccessDeviedDispatchStub(pDeviceObject, pIrp);
}

RT_C_DECLS_BEGIN

NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath);

RT_C_DECLS_END

NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath)
{
    LogRel(("NemuUsb::DriverEntry. Built Date (%s) Time (%s)\n", __DATE__, __TIME__));

    NTSTATUS Status = nemuUsbRtGlobalsInit();
    Assert(Status == STATUS_SUCCESS);
    if (Status == STATUS_SUCCESS)
    {
        Status = NemuDrvToolStrCopy(&g_NemuUsbGlobals.RegPath, pRegistryPath);
        Assert(Status == STATUS_SUCCESS);
        if (Status == STATUS_SUCCESS)
        {
            g_NemuUsbGlobals.pDrvObj = pDriverObject;

            pDriverObject->DriverExtension->AddDevice = nemuUsbDdiAddDevice;

            pDriverObject->DriverUnload = nemuUsbDdiUnload;

            pDriverObject->MajorFunction[IRP_MJ_CREATE] = nemuUsbDispatchCreate;
            pDriverObject->MajorFunction[IRP_MJ_CLOSE] =  nemuUsbDispatchClose;
            pDriverObject->MajorFunction[IRP_MJ_READ] = nemuUsbDispatchRead;
            pDriverObject->MajorFunction[IRP_MJ_WRITE] = nemuUsbDispatchWrite;
            pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = nemuUsbDispatchDeviceControl;
            pDriverObject->MajorFunction[IRP_MJ_CLEANUP] = nemuUsbDispatchCleanup;
            pDriverObject->MajorFunction[IRP_MJ_POWER] = nemuUsbDispatchPower;
            pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = nemuUsbDispatchSystemControl;
            pDriverObject->MajorFunction[IRP_MJ_PNP] = nemuUsbDispatchPnP;

            return STATUS_SUCCESS;
        }
        nemuUsbRtGlobalsTerm();
    }

    LogRel(("NemuUsb::DriverEntry. failed with Status (0x%x)\n", Status));

    return Status;
}

#ifdef DEBUG
DECLHIDDEN(VOID) nemuUsbPnPStateGbgChange(ENMNEMUUSB_PNPSTATE enmOldState, ENMNEMUUSB_PNPSTATE enmNewState)
{
    /* *ensure the state change is valid */
    switch (enmNewState)
    {
        case ENMNEMUUSB_PNPSTATE_STARTED:
            Assert(enmOldState == ENMNEMUUSB_PNPSTATE_START_PENDING
                    || ENMNEMUUSB_PNPSTATE_REMOVE_PENDING
                    || ENMNEMUUSB_PNPSTATE_STOPPED
                    || ENMNEMUUSB_PNPSTATE_STOP_PENDING);
            break;
        case ENMNEMUUSB_PNPSTATE_STOP_PENDING:
            Assert(enmOldState == ENMNEMUUSB_PNPSTATE_STARTED);
            break;
        case ENMNEMUUSB_PNPSTATE_STOPPED:
            Assert(enmOldState == ENMNEMUUSB_PNPSTATE_STOP_PENDING);
            break;
        case ENMNEMUUSB_PNPSTATE_SURPRISE_REMOVED:
            Assert(enmOldState == ENMNEMUUSB_PNPSTATE_STARTED);
            break;
        case ENMNEMUUSB_PNPSTATE_REMOVE_PENDING:
            Assert(enmOldState == ENMNEMUUSB_PNPSTATE_STARTED);
            break;
        case ENMNEMUUSB_PNPSTATE_REMOVED:
            Assert(enmOldState == ENMNEMUUSB_PNPSTATE_REMOVE_PENDING
                    || enmOldState == ENMNEMUUSB_PNPSTATE_SURPRISE_REMOVED);
            break;
        default:
            AssertBreakpoint();
            break;
    }

}
#endif
