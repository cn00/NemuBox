# $Id: Makefile.kmk $
## @file
# The Recompiler Sub-Makefile.
#

#
# Copyright (C) 2006-2015 Oracle Corporation
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#


SUB_DEPTH = ../..
include $(KBUILD_PATH)/subheader.kmk

#
# Globals
#
NEMU_PATH_RECOMPILER_SRC    := $(PATH_SUB_CURRENT)
# Workaround for darwin hell.
ifeq ($(KBUILD_TARGET),darwin)
 NEMU_WITHOUT_REM_LDR_CYCLE := 1
endif
ifeq ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH),win.amd64)
 NEMU_USE_MINGWW64 = 1
endif


#
# The primary REM module definition.
#
# This is extended by one of the NemuREM* modules below.  Currently, this
# isn't done by inheritance because of some obscure bug wrt inheriting from
# unused targets that I'm not going to fix now.
#
ifneq ($(KBUILD_TARGET),win)
 NemuRemPrimary_TEMPLATE       = NEMUR3NP
 # workaround the regparm bug in gcc <= 3.3
 NemuRemPrimary_DEFS           = $(if $(NEMU_GCC_BUGGY_REGPARM),GCC_WITH_BUGGY_REGPARM,)
else
 NemuRemPrimary_TEMPLATE       = DUMMY
 NemuRemPrimary_TOOL.win.x86   = MINGW32
 ifdef NEMU_USE_MINGWW64
  NemuRemPrimary_TOOL.win.amd64 = MINGWW64
 else
  NemuRemPrimary_TOOL.win.amd64 = XGCCAMD64LINUX
 endif
 NemuRemPrimary_SDKS.win.x86   = W32API
 NemuRemPrimary_ASFLAGS        = -x assembler-with-cpp
 NemuRemPrimary_CFLAGS         = -Wall -g -fno-omit-frame-pointer -fno-strict-aliasing -Wno-shadow
 NemuRemPrimary_CFLAGS.debug   = -O0
 NemuRemPrimary_CFLAGS.release += -fno-gcse -O2
 NemuRemPrimary_CFLAGS.profile = $(NemuRemPrimary_CFLAGS.release)
 NemuRemPrimary_DEFS          += IN_RING3 $(ARCH_BITS_DEFS)
 # Workaround the regparm bug in gcc <= 3.3.
 NemuRemPrimary_DEFS.win.x86  += GCC_WITH_BUGGY_REGPARM
 # Missing fpclassify. Is there a better define or flag for this?
 NemuRemPrimary_DEFS.solaris  += __C99FEATURES__
endif # win
NemuRemPrimary_DEFS           += IN_REM_R3 REM_INCLUDE_CPU_H NEED_CPU_H
#NemuRemPrimary_DEFS           += REM_PHYS_ADDR_IN_TLB
#NemuRemPrimary_DEFS           += DEBUG_ALL_LOGGING DEBUG_DISAS DEBUG_PCALL CONFIG_DEBUG_EXEC DEBUG_FLUSH DEBUG_IOPORT DEBUG_SIGNAL DEBUG_TLB_CHECK DEBUG_TB_INVALIDATE DEBUG_TLB  # Enables huge amounts of debug logging.
#NemuRemPrimary_DEFS           += DEBUG_DISAS DEBUG_PCALL CONFIG_DEBUG_EXEC DEBUG_FLUSH DEBUG_IOPORT DEBUG_SIGNAL DEBUG_TLB_CHECK DEBUG_TB_INVALIDATE DEBUG_TLB  # Enables huge amounts of debug logging.
ifdef IEM_VERIFICATION_MODE
 NemuRemPrimary_DEFS          += IEM_VERIFICATION_MODE
endif
ifdef NEMU_WITH_RAW_MODE
 NemuRemPrimary_DEFS          += NEMU_WITH_RAW_MODE
endif
ifdef NEMU_WITH_RAW_RING1
 NemuRemPrimary_DEFS          += NEMU_WITH_RAW_RING1
endif
NemuRemPrimary_DEFS.linux      = _GNU_SOURCE
ifdef NEMU_SOLARIS_10
 NemuRemPrimary_DEFS.solaris   = CONFIG_SOLARIS_VERSION=10
else
 NemuRemPrimary_DEFS.solaris   = CONFIG_SOLARIS_VERSION=11
endif
NemuRemPrimary_DEFS.freebsd   += _BSD
NemuRemPrimary_DEFS.amd64     += __x86_64__
NemuRemPrimary_DEFS.x86       += __i386__

NemuRemPrimary_INCS            = \
	Sun \
	target-i386 \
	tcg \
	fpu \
	$(NemuRemPrimary_0_OUTDIR) \
	$(PATH_ROOT)/src/Nemu/VMM/include \
	tcg/i386 \
	.
ifn1of ($(NemuRemPrimary_DEFS),DEBUG_TMP_LOGGING)
 NemuRemPrimary_DEFS          += LOG_USE_C99
 NemuRemPrimary_INCS          <= \
 	Sun/crt
endif

NemuRemPrimary_SOURCES         = \
	NemuRecompiler.c \
	cpu-exec.c \
	exec.c \
	translate-all.c \
	host-utils.c \
	cutils.c \
	tcg-runtime.c \
	tcg/tcg.c \
	tcg/tcg-dyngen.c \
	fpu/softfloat-native.c \
	target-i386/op_helper.c \
	target-i386/helper.c \
	target-i386/translate.c
NemuRemPrimary_SOURCES.debug  += \
	Sun/testmath.c
NemuRemPrimary_SOURCES.win = $(NemuREMImp_0_OUTDIR)/NemuREMRes.o
NemuRemPrimary_SOURCES.win.x86 = $(NemuREMImp_0_OUTDIR)/NemuREMWin.def
ifdef NEMU_USE_MINGWW64
 if 0 # exporting all helps when windbg pops up on crashes
  NemuRemPrimary_SOURCES.win.amd64 = $(NemuREMImp_0_OUTDIR)/NemuREMWin.def
 else
  NemuRemPrimary_LDFLAGS.win.amd64 = --export-all
 endif
endif

ifndef NEMU_USE_MINGWW64
NemuRemPrimary_LIBS            = \
	$(LIB_VMM) \
	$(LIB_RUNTIME)
else
NemuRemPrimary_LIBS            = \
	$(NemuRemPrimary_0_OUTDIR)/NemuVMMImp.a \
	$(NemuRemPrimary_0_OUTDIR)/NemuRTImp.a
NemuRemPrimary_CLEAN           = \
	$(NemuRemPrimary_0_OUTDIR)/NemuVMMImp.a \
	$(NemuRemPrimary_0_OUTDIR)/NemuVMMImp.def \
	$(NemuRemPrimary_0_OUTDIR)/NemuRTImp.a \
	$(NemuRemPrimary_0_OUTDIR)/NemuRTImp.def
endif

NemuRemPrimary_LDFLAGS.solaris = -mimpure-text
if defined(NEMU_WITH_HARDENING) && "$(KBUILD_TARGET)" == "win"
 NemuRemPrimary_POST_CMDS      = \
 	$(NEMU_VCC_EDITBIN) /LargeAddressAware /DynamicBase /NxCompat /Release /IntegrityCheck \
 		/Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) "$(out)" \
 	$$(NLTAB)$(NEMU_SIGN_IMAGE_CMDS)
else
 NemuRemPrimary_POST_CMDS      = $(NEMU_SIGN_IMAGE_CMDS)
endif


if "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.amd64" && !defined(NEMU_USE_MINGWW64)
 #
 # NemuREM2/NemuRemPrimary - Currently only used by 64-bit Windows.
 # (e_powl-xxx.S doesn't fit in IPRT because it requires GAS and is LGPL.)
 #
 SYSMODS += NemuRemPrimary
 NemuRemPrimary_TEMPLATE   = NEMUNOCRTGAS
 NemuRemPrimary_NAME       = NemuREM2
 NemuRemPrimary_DEFS      += LOG_USE_C99 $(ARCH_BITS_DEFS)
 NemuRemPrimary_SOURCES   += \
 	Sun/e_powl-$(KBUILD_TARGET_ARCH).S
 NemuRemPrimary_INCS      += \
 	Sun/crt
 NemuRemPrimary_SYSSUFF    = .rel
 NemuRemPrimary_LIBS       = \
 	$(PATH_STAGE_LIB)/RuntimeR3NoCRTGCC$(NEMU_SUFF_LIB)
 NemuRemPrimary_POST_CMDS  = $(NO_SUCH_VARIABLE)
 NEMU_REM_WRAPPER          = 2

else if "$(KBUILD_TARGET_ARCH)" == "x86" && defined(NEMU_WITH_64_BITS_GUESTS)
 #
 # For 32-bit targets when enabled 64-bit guests we build 2 REM DLLs:
 #  with 64-bit support (slow and buggy at the moment) NEMUREM64
 #  only 32-bit support (faster, stable, but not suitable for 64-bit guests) NEMUREM32
 # During the runtime, we load appropriate library from NEMUREM, depending on guest settings.
 # 64-bit targets have 64-bit enabled REM by default, so is not part of this mess
 #

 #
 # NemuREM32/NemuRemPrimary
 #
 DLLS += NemuRemPrimary
 NemuRemPrimary_NAME       = NemuREM32
 NemuRemPrimary_LDFLAGS.darwin = -install_name $(NEMU_DYLD_EXECUTABLE_PATH)/NemuREM32.dylib
 NEMU_REM_WRAPPER          = 32

 #
 # NemuREM64
 #
 DLLS += NemuREM64
 NemuREM64_EXTENDS         = NemuRemPrimary
 NemuREM64_EXTENDS_BY      = appending
 NemuREM64_NAME            = NemuREM64
 NemuREM64_DEFS            = NEMU_ENABLE_NEMUREM64
 NemuREM64_LDFLAGS.darwin  = -install_name $(NEMU_DYLD_EXECUTABLE_PATH)/NemuREM64.dylib

else
 #
 # NemuREM/NemuRemPrimary - Normal.
 #
 DLLS += NemuRemPrimary
 NemuRemPrimary_NAME       = NemuREM
 NemuRemPrimary_LDFLAGS.darwin = -install_name $(NEMU_DYLD_EXECUTABLE_PATH)/NemuREM3.dylib

 ifdef NEMU_USE_MINGWW64
  # GNU ld (rubenvb-4.5.4) 2.22.52.20120716 doesn't fix up rip relative
  # addressing in the import libraries generated by microsoft link.exe. So, we
  # have to regenerate these.
  # Note! The chdir to the output directory is because dlltool writes temporary files to the current directory.
  $$(NemuRemPrimary_0_OUTDIR)/NemuVMMImp.a \
  $$(NemuRemPrimary_0_OUTDIR)/NemuRTImp.a : $$(NemuRemPrimary_0_OUTDIR)/$$(notdir $$(basename $$@)).def
	$(REDIRECT) -C "$(dir $@)" -- $(TOOL_MINGWW64_DLLTOOL) \
		--output-lib "$@" \
		--input-def "$<" \
		--dllname "$(patsubst %Imp.a,%.dll,$(notdir $@))"

  $$(NemuRemPrimary_0_OUTDIR)/NemuVMMImp.def \
  $$(NemuRemPrimary_0_OUTDIR)/NemuRTImp.def : \
  		$(PATH_STAGE_BIN)/$$(patsubst %Imp.def,%.dll,$$(notdir $$@)) \
               | $$(dir $$@)
	$(APPEND) -nt $@ "LIBRARY $(notdir $<)" "EXPORTS"
	$(TOOL_$(NEMU_VCC_TOOL)_DUMPBIN) /EXPORTS "$<" \
		| $(SED) -e '/ = /!d' \
			 -e 's/^.* \([^ ][^ ]*\) = .*$(DOLLAR)/  \"\1\"/' \
			 --append $@
 endif # NEMU_USE_MINGWW64

endif


ifdef NEMU_REM_WRAPPER
 #
 # NemuREM - Wrapper for loading NemuREM2, NemuREM32 or NemuREM64.
 #
 DLLS += NemuREMWrapper
 NemuREMWrapper_TEMPLATE   = NemuR3DllWarnNoPic
 NemuREMWrapper_NAME       = NemuREM
 NemuREMWrapper_DEFS       = IN_REM_R3
 if "$(KBUILD_TARGET_ARCH)" == "x86" && defined(NEMU_WITH_64_BITS_GUESTS)
  NemuREMWrapper_DEFS     += NEMU_USE_BITNESS_SELECTOR
 endif
 ifdef NEMU_WITHOUT_REM_LDR_CYCLE
  NemuREMWrapper_DEFS     += NEMU_WITHOUT_REM_LDR_CYCLE
 endif
 NemuREMWrapper_SOURCES    = \
 	NemuREMWrapper.cpp
 NemuREMWrapper_SOURCES.win = NemuREM.rc
 if "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.amd64" && !defined(NEMU_USE_MINGWW64)
  NemuREMWrapper_SOURCES  += \
  	NemuREMWrapperA.asm
 endif
 NemuREMWrapper_LIBS       = \
 	$(LIB_RUNTIME)
 ifndef NEMU_WITHOUT_REM_LDR_CYCLE
  NemuREMWrapper_LIBS     += \
  	$(LIB_VMM)
  NemuREMWrapper_LIBS.darwin += \
  	$(TARGET_NemuREMImp)
 endif
 NemuREMWrapper_LDFLAGS.darwin = -install_name $(NEMU_DYLD_EXECUTABLE_PATH)/NemuREM.dylib
endif


#
# The NemuREM import library.
#
# This is a HACK to get around (a) the cyclic dependency between NemuVMM and
# NemuREM during linking and (b) the recursive build ordering which means NemuREM
# won't be built until after all the other DLLs.
#
IMPORT_LIBS += NemuREMImp
NemuREMImp_TEMPLATE        = NemuR3Dll
 ifn1of ($(KBUILD_TARGET), os2 win)
NemuREMImp_NAME            = NemuREM
 endif
NemuREMImp_INST            = $(INST_LIB)
NemuREMImp_SOURCES.win     = $(NemuREMImp_0_OUTDIR)/NemuREMWin.def
NemuREMImp_CLEAN.win       = $(NemuREMImp_0_OUTDIR)/NemuREMWin.def
NemuREMImp_SOURCES.os2     = $(NemuREMImp_0_OUTDIR)/NemuREMOS2.def
NemuREMImp_CLEAN.os2       = $(NemuREMImp_0_OUTDIR)/NemuREMOS2.def
 ifn1of ($(KBUILD_TARGET), os2 win)
NemuREMImp_SOURCES         = $(NemuREMImp_0_OUTDIR)/NemuREMImp.c
NemuREMImp_CLEAN           = $(NemuREMImp_0_OUTDIR)/NemuREMImp.c
 endif
 ifn1of ($(KBUILD_TARGET), darwin os2 win)
NemuREMImp_SONAME          = NemuREM$(SUFF_DLL)
 endif
ifdef NEMU_WITHOUT_REM_LDR_CYCLE
 NemuREMImp_LDFLAGS.darwin = -install_name $(NEMU_DYLD_EXECUTABLE_PATH)/NemuREM.dylib
else
 NemuREMImp_LDFLAGS.darwin = -install_name $(subst @rpath,@executable_path,$(NEMU_DYLD_EXECUTABLE_PATH))/NemuREM.dylib
endif
NemuREMImp_LDFLAGS.l4      = -T$(L4_LIBDIR)/../main_rel.ld -nostdlib

$$(NemuREMImp_0_OUTDIR)/NemuREMImp.c: $(NEMU_PATH_RECOMPILER_SRC)/NemuREM.def $(NEMU_PATH_RECOMPILER_SRC)/Sun/deftoimp.sed $(MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(APPEND) -t $@ '#ifdef NEMU_HAVE_VISIBILITY_HIDDEN'
	$(QUIET)$(APPEND)    $@ '# define EXPORT __attribute__((visibility("default")))'
	$(QUIET)$(APPEND)    $@ '#else'
	$(QUIET)$(APPEND)    $@ '# define EXPORT'
	$(QUIET)$(APPEND)    $@ '#endif'
	$(QUIET)$(APPEND)    $@ ''
	$(QUIET)$(SED) -f $(NEMU_PATH_RECOMPILER_SRC)/Sun/deftoimp.sed --append $@ $<

$$(NemuREMImp_0_OUTDIR)/NemuREMOS2.def: $(NEMU_PATH_RECOMPILER_SRC)/NemuREM.def $(MAKEFILE_CURRENT) | $$(dir $$@)
	$(SED) \
		-e 's/^[ \t][ \t]*REMR3/    _REMR3/' \
		-e 's/\.[Dd][Ll][Ll]//' \
		-e 's/^LIBRARY .*/LIBRARY NemuREM INITINSTANCE TERMINSTANCE\nDATA MULTIPLE\n/' \
		--output $@ \
		$<

$$(NemuREMImp_0_OUTDIR)/NemuREMWin.def: $(NEMU_PATH_RECOMPILER_SRC)/NemuREM.def $(MAKEFILE_CURRENT) | $$(dir $$@)
	$(CP) -f $< $@

$$(NemuREMImp_0_OUTDIR)/NemuREMRes.o: $(NEMU_PATH_RECOMPILER_SRC)/NemuREM.rc $(MAKEFILE_CURRENT) $(NEMU_VERSION_MK) | $$(dir $$@)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(REDIRECT) -E 'COMSPEC=$(NEMU_GOOD_COMSPEC_BS)' -- $(TOOL_MINGWW64_PREFIX)windres \
	    $(addprefix -I,$(INCS) $(PATH_SDK_$(NEMU_WINPSDK)_INC) $(PATH_TOOL_$(NEMU_VCC_TOOL)_INC)) \
	    -DNEMU_SVN_REV=$(NEMU_SVN_REV) \
	    -DNEMU_SVN_REV_MOD_5K=$(expr $(NEMU_SVN_REV) % 50000) \
	    $< $@

#
# The math testcase as a standalone program for testing and debugging purposes.
#
## @todo This is a bit messy because of MINGW32.
testmath_ASFLAGS.amd64  = -m amd64
testmath_CFLAGS         = -Wall -g
testmath_CFLAGS.release = -O3
testmath_LDFLAGS        = -g
testmath_DEFS           = MATHTEST_STANDALONE
testmath_SOURCES        = Sun/testmath.c


include $(FILE_KBUILD_SUB_FOOTER)

