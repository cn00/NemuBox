# $Id: Config.kmk $
## @file
# The global build configuration file for Nemu.
#
# This file gets included by all makefiles through the
# include $(KBUILD_PATH)/header.kmk statement.
#

#
# Copyright (C) 2006-2015 Oracle Corporation
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#

# Marker.
NEMU_ROOT_CONFIG_KMK_INCLUDED = 1

#
# kBuild stuff
#

# Build with umask 022 (requires kBuild r2556 to work, harmless on earlier).
$(set-umask 022)

# Add our own directories to the search paths.
KBUILD_TOOL_PATHS = $(KBUILD_DEVTOOLS)/kBuildTools/


# Modify the build types.
KBUILD_BLD_TYPES = release profile debug kprofile

## 'strict' builds
# Same as release builds, except that RT_STRICT and NEMU_STRICT are defined,
# meaning all assertions are in action. (Appending means '.strict' props take
# precedence in argument lists.)
KBUILD_BLD_TYPES += strict
BLD_TYPE_strict_EXTENDS = release
BLD_TYPE_strict_EXTENDS_BY = appending

## 'dbgopt' builds
# Same as debug builds, except that compiler optimizations are enabled.  This
# intended for cases where all the debug facitities (logging, assertions, ++)
# is wanted but actual source level debugging as important as execution speed.
KBUILD_BLD_TYPES += dbgopt
BLD_TYPE_dbgopt_EXTENDS = debug
BLD_TYPE_dbgopt_EXTENDS_BY = overriding

# Temporary hack for kBuild ticket #83.
## @todo kBuild: remove after closing ticket #83.
PROPS_ACCUMULATE_L_LNK       += INTERMEDIATES
PROPS_PROGRAMS_ACCUMULATE_L  += INTERMEDIATES
PROPS_LIBRARIES_ACCUMULATE_L += INTERMEDIATES
PROPS_DLLS_ACCUMULATE_L      += INTERMEDIATES
PROPS_SYSMODS_ACCUMULATE_L   += INTERMEDIATES
PROPS_MISCBINS_ACCUMULATE_L  += INTERMEDIATES

# Misc names used by the install paths below.
NEMU_PUEL_MANGLED_NAME := Oracle_VM_VirtualBox_Extension_Pack

# Install paths
## @todo This will change after 4.1 is branched off!
# What is now 'bin' and 'lib' will be moved down under 'staged/', except on
# darwin where it's currently called 'dist' which will be renamed to 'staged'.
# When running 'kmk install' files will be copied to 'dist/', on unix systems
# this will be done in FHS fashion assuming /usr/local or /usr as 'prefix'.
#
# Changes related to this are marked NEMU_WITH_NEW_LAYOUT.
ifndef NEMU_WITH_NEW_LAYOUT
 PATH_INS             = $(PATH_OUT)/dist
 PATH_STAGE           = $(PATH_OUT)
 INST_DEBUG          := stage/debug/
endif

ifeq ($(KBUILD_TARGET),darwin)
 ifndef NEMU_WITH_NEW_LAYOUT
  INST_DIST           = dist/
 else
  INST_DIST          :=
 endif
 INST_SDK             = $(INST_DIST)sdk/

 # the bundles
 INST_VIRTUALBOX      = $(INST_DIST)VirtualBox.app/
 INST_NEMUDRV         = $(INST_DIST)NemuDrv.kext/
 INST_NEMUNETFLT      = $(INST_DIST)NemuNetFlt.kext/
 INST_NEMUNETADP      = $(INST_DIST)NemuNetAdp.kext/
 INST_NEMUUSB         = $(INST_DIST)NemuUSB.kext/

 # put everything in the VirtualBox app bundle.
 INST_BIN             = $(INST_VIRTUALBOX)Contents/MacOS/
 INST_DLL             = $(INST_BIN)
 INST_SYS             = $(INST_BIN)
 INST_TESTCASE        = $(INST_BIN)testcase/
 INST_ADDITIONS       = $(INST_DIST)additions/
 INST_ADDITIONS_ISO   = $(INST_BIN)

 INST_NEMUDBG_SYMS    = $(INST_VIRTUALBOX)Contents/Resources/NemuDbgSyms/

 # other paths
 INST_LIB             = lib/
 INST_ADDITIONS_LIB   = $(INST_LIB)additions/
 NEMU_INST_DTRACE_LIB = $(INST_BIN)dtrace/lib/
 NEMU_INST_DTRACE_TST = $(INST_BIN)dtrace/testcase/
 NEMU_INST_TOOLS      = $(INST_BIN)tools/

else

 INST_BIN             = bin/
 INST_DIST            = $(INST_BIN)
 INST_SDK             = $(INST_BIN)sdk/

 INST_VIRTUALBOX      = $(INST_BIN)
 INST_NEMUDRV         = $(INST_BIN)
 INST_NEMUNETFLT      = $(INST_BIN)
 INST_NEMUNETADP      = $(INST_BIN)
 INST_NEMUUSB         = $(INST_BIN)

 INST_DLL             = $(INST_BIN)
 INST_SYS             = $(INST_BIN)
 INST_TESTCASE        = $(INST_BIN)testcase/
 INST_ADDITIONS       = $(INST_BIN)additions/
 INST_ADDITIONS_ISO   = $(INST_ADDITIONS)

 INST_LIB             = lib/
 INST_ADDITIONS_LIB   = $(INST_LIB)additions/
 NEMU_INST_DTRACE_LIB = $(INST_BIN)dtrace/lib/
 NEMU_INST_DTRACE_TST = $(INST_BIN)dtrace/testcase/

 INST_NEMUDBG_SYMS    = $(INST_BIN)NemuDbgSyms/
 NEMU_INST_TOOLS      = $(INST_BIN)tools/
endif


INST_VALIDATIONKIT    = validationkit/
INST_TESTBOXSCRIPT    = testboxscript/

INST_DOC              = doc/
INST_EXTPACK          = $(INST_BIN)ExtensionPacks/
INST_EXTPACK_CERTS    = $(INST_BIN)ExtPackCertificates/
INST_EXTPACK_PUEL     = $(INST_EXTPACK)$(NEMU_PUEL_MANGLED_NAME)/
INST_PACKAGES         = packages/

NEMU_PATH_SDK         = $(patsubst %/,%,$(PATH_STAGE)/$(INST_SDK))
NEMU_PATH_DIST        = $(patsubst %/,%,$(PATH_STAGE)/$(INST_DIST))
NEMU_PATH_VALIDATIONKIT = $(patsubst %/,%,$(PATH_STAGE)/$(INST_VALIDATIONKIT))
NEMU_PATH_ADDITIONS   = $(patsubst %/,%,$(PATH_STAGE)/$(INST_ADDITIONS))
NEMU_PATH_ADDITIONS_ISO = $(patsubst %/,%,$(PATH_STAGE)/$(INST_ADDITIONS_ISO))
NEMU_PATH_ADDITIONS_LIB = $(patsubst %/,%,$(PATH_STAGE)/$(INST_ADDITIONS_LIB))
NEMU_PATH_EXTPACK_PUEL= $(patsubst %/,%,$(PATH_STAGE)/$(INST_EXTPACK_PUEL))
NEMU_PATH_PACKAGES    = $(patsubst %/,%,$(PATH_STAGE)/$(INST_PACKAGES))


# Delete targets on failure.
.DELETE_ON_ERROR:

# Notify about important kBuild updates.
if  $(KBUILD_VERSION_MAJOR) == 0 \
 && (   $(KBUILD_VERSION_MINOR) >= 2 \
     || (   $(KBUILD_VERSION_MINOR) == 1 \
         && $(KBUILD_VERSION_PATCH) >= 999))
 if $(KMK_REVISION) >= 2689
  # OK.
 else
  $(error You must update kBuild! Requires kBuild revision 2577 or later, found $(KMK_REVISION) ($(KBUILD_VERSION)))
 endif
else
 $(error You must update kBuild! Requires 0.1.999 or later, found $(KBUILD_VERSION))
endif

#
# Define USERNAME early on.
#
ifndef USERNAME
 ifdef USER
  USERNAME = $(USER)
 else
  $(warning Warning: You must have USERNAME or USER in your environment.)
 endif
endif

#
# Detect the darwin host version number so we can disable stuff that doesn't
# currently build on Lion.
#
ifeq ($(KBUILD_HOST),darwin)
 NEMU_DARWIN_HOST_VERSION := $(subst ., ,$(shell uname -r))
 NEMU_DARWIN_HOST_VERSION_MAJOR := $(expr $(word 1, $(NEMU_DARWIN_HOST_VERSION)) - 4)
 NEMU_DARWIN_HOST_VERSION_MINOR := $(word 2, $(NEMU_DARWIN_HOST_VERSION))
 NEMU_DARWIN_HOST_VERSION_PATCH := $(word 3, $(NEMU_DARWIN_HOST_VERSION))
 NEMU_DARWIN_HOST_VERSION := 10.$(NEMU_DARWIN_HOST_VERSION_MAJOR).$(NEMU_DARWIN_HOST_VERSION_MINOR)
endif


#
# The VirtualBox version.
#

# Major version.
NEMU_VERSION_MAJOR = 5
# Minor version.
NEMU_VERSION_MINOR = 0
# This is the current build number. It should be increased every time we publish a
# new build. The define is available in every source file. Only even build numbers
# will be published, odd numbers are set during development.
NEMU_VERSION_BUILD = 14
# The raw version string. This *must not* contain any other information/fields than
# major, minor and build revision (as it is now) -- also will be used for host/guest version
# comparison.
NEMU_VERSION_STRING_RAW = $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)
# This can be overridden in LocalConfig.kmk or elsewhere.
# For the convension, see checks near the end of Config.kmk.
NEMU_BUILD_PUBLISHER =
# Full version string (may include more than just x.y.z, but no spaces or other problematic chars).
# Note! The BETA[n],ALPHA[n],RC[n] indicators should be inserted before the
#       publisher so that RTStrVersionCompare have a chance of comparing
#       prerelease from different publishers correctly.
NEMU_VERSION_STRING = $(NEMU_VERSION_STRING_RAW)$(NEMU_BUILD_PUBLISHER)
# Just the BETA[n],ALPHA[n],RC[n] indicators. Set to empty string for release.
NEMU_VERSION_PRERELEASE =

# Force the additions.sh script to get an exact additions build when we're doing the release.
ifeq ($(int-mod $(NEMU_VERSION_BUILD),2),0)
  NEMU_RELEASE_EXACT_MATCH=1
endif
ifneq ($(NEMU_RELEASE_EXACT_MATCH),)
 export NEMU_ADDITIONS_SH_MODE     = release
 export NEMU_DOCUMENTATION_SH_MODE = release
 export NEMU_EFI_SH_MODE           = release
 export NEMU_EXTPACKS_SH_MODE      = release
endif

# Some info on the vendor
NEMU_VENDOR       = Oracle Corporation
NEMU_VENDOR_SHORT = Oracle
NEMU_PRODUCT      = Oracle VM VirtualBox
# Not all could be done automatically. Here is a list of known places which
# have to be updated manually, please keep this up to date:
#	src/Nemu/Devices/PC/PXE/client/uinit.asm
#	src/Nemu/RDP/webclient/flash/com/sun/network/rdp/Version.as
#	src/Nemu/Frontends/VirtualBox/src/globals/NemuGlobal.cpp
#	src/Nemu/Frontends/VirtualBox/src/settings/global/NemuGLSettingsLanguage.cpp
#	src/Nemu/Frontends/VirtualBox/nls/*.ts
#	debian/control
#	src/Nemu/Installer/linux/{debian,rpm}
#	src/Nemu/Installer/linux/virtualbox.desktop
#	src/Nemu/Additions/WINNT/Installer/ISO/ReadmeDrivers.txt
#	*/*.inf, */*.rc

# Maybe we want set this manually.
NEMU_C_YEAR = $(date-utc %Y)

#
# The VirtualBox package type.
#
ifeq ($(KBUILD_TARGET),win)
  NEMU_PACKAGE_OS = WINDOWS
else ifeq ($(KBUILD_TARGET),linux)
  NEMU_PACKAGE_OS = LINUX
else ifeq ($(KBUILD_TARGET),darwin)
  NEMU_PACKAGE_OS = DARWIN
else ifeq ($(KBUILD_TARGET),solaris)
  NEMU_PACKAGE_OS = SOLARIS
else ifeq ($(KBUILD_TARGET),os2)
  NEMU_PACKAGE_OS = OS2
else ifeq ($(KBUILD_TARGET),haiku)
  NEMU_PACKAGE_OS = HAIKU
else if1of ($(KBUILD_TARGET), dragonfly freebsd netbsd openbsd)
  NEMU_PACKAGE_OS = BSD
else
  $(error Cannot determine NEMU_PACKAGE_OS)
endif
ifeq ($(KBUILD_TARGET_ARCH),x86)
  NEMU_PACKAGE_ARCH = 32BITS
else
  NEMU_PACKAGE_ARCH = 64BITS
endif
# distribution, mostly for Linux/Solaris where we support different distributions
# this strip will be overridden by the Linux packaging scripts
NEMU_PACKAGE_DIST ?= GENERIC
# Full string
NEMU_PACKAGE_STRING = $(NEMU_PACKAGE_OS)_$(NEMU_PACKAGE_ARCH)_$(NEMU_PACKAGE_DIST)


#
# The VirtualBox Configuration Defaults.
#
# We try to document all the build configuration options here, thing which
# aren't enabled by default is left commented out just to show that they
# exist and which value they should have (usually 1, but anyway).
#

## @name Additions
## @{
# This indicates that additions (of some kind or another) is being _built_.
# NEMU_WITHOUT_ADDITIONS overrides it.
NEMU_WITH_ADDITIONS = 1
# Build the optional ring-0 part of the additions for syntax checking.
# (Except when cross-building on linux since we're using /usr/src/...)
ifn1of ($(KBUILD_TARGET).$(KBUILD_HOST_ARCH).$(KBUILD_TARGET_ARCH), linux.x86.amd64 linux.amd64.x86)
 NEMU_WITH_ADDITION_DRIVERS = 1
endif
# Build X11 additions. Can be disabled separately.
if1of ($(KBUILD_TARGET), dragonfly freebsd linux netbsd openbsd solaris)
 NEMU_WITH_X11_ADDITIONS = 1
endif
# Enable the building of shared folders in the windows additions.
NEMU_WITH_WIN32_ADDITIONS_SHAREDFOLDERS = 1
# Take the binaries of the OS/2 Additions.
NEMU_WITH_OS2_ADDITIONS_BIN = 1
# Use additions from the build server.
#NEMU_WITH_ADDITIONS_FROM_BUILD_SERVER = 1
# Include additions in the package
NEMU_WITH_ADDITIONS_PACKING = 1
# Only build the additions (for the additions build server).
#NEMU_ONLY_ADDITIONS = 1
ifdef NEMU_ADDITIONS_ONLY # typical mistake.
 $(error It is NEMU_ONLY_ADDITIONS=1 not NEMU_ADDITIONS_ONLY!)
endif
# Don't bother with additions, overrides NEMU_WITH_ADDITIONS.
# This is not used by makefiles, only Config.kmk, see below.
ifdef NEMU_ONLY_SDK
 NEMU_WITHOUT_ADDITIONS = 1
endif
# Don't create the additions ISO.
# (Used by the additions build server, don't invert it.)
#NEMU_WITHOUT_ADDITIONS_ISO = 1
## @}

## @name Documentation
## @{
# The documentation
NEMU_WITH_DOCS = 1
# Use documentation from the build server.
#NEMU_WITH_DOCS_FROM_BUILD_SERVER = 1
# Include documentation in the package
NEMU_WITH_DOCS_PACKING = 1
# Include CHM when building docs (unset in LocalConfig.kmk to suppress CHM)
ifn1of ($(KBUILD_TARGET), linux)
 NEMU_WITH_DOCS_CHM = 1
endif
# By default only include translations in documentation-only builds
ifdef NEMU_ONLY_DOCS
 ifndef NEMU_NO_DOCS_TRANSLATIONS
  NEMU_WITH_DOCS_TRANSLATIONS = 1
 endif
endif
# Default languages
NEMU_MANUAL_LANGUAGES = en_US
ifdef NEMU_WITH_DOCS_TRANSLATIONS
 NEMU_MANUAL_ADD_LANGUAGES = fr_FR
endif
# Don't bother with documentation, overrides NEMU_WITH_DOCS.
# This is not used by makefiles, only Config.kmk, see below.
#NEMU_WITHOUT_DOCS = 1
# Only build the documentation (for the documentation build server).
#NEMU_ONLY_DOCS = 1
ifdef NEMU_DOCS_ONLY # typical mistake.
 $(error It is NEMU_ONLY_DOCS=1 not NEMU_DOCS_ONLY!)
endif
## @}

## @name VMM related settings.
## @{
# Enable the tradition raw-mode virtualization.
if !$(intersects $(KBUILD_TARGET), darwin) || defined(NEMU_ONLY_EXTPACKS)
 NEMU_WITH_RAW_MODE = 1
endif
# Enable the ring-1 compression option (mainly for QNX).
NEMU_WITH_RAW_RING1 = 1
# Enable safe STR (store task register) emulation for raw-mode.
NEMU_WITH_SAFE_STR = 1
# Enable support for 64-bit guests.
NEMU_WITH_64_BITS_GUESTS = 1
# Enable multi-core VCPUs.
NEMU_WITH_MULTI_CORE = 1
# Activate this to force the VM to pre-allocate the guest RAM before startup
NEMU_WITH_PREALLOC_RAM_BY_DEFAULT =
# Enable the debugger.
NEMU_WITH_DEBUGGER = 1
# Enable the debugger GUI.
NEMU_WITH_DEBUGGER_GUI = 1
# Enables the second step using IEM (the interpreter).
NEMU_WITH_2ND_IEM_STEP = 1
# Enables the third step using IEM (the interpreter).
#NEMU_WITH_3RD_IEM_STEP = 1
## @}


## @name Devices, Drivers, ...
## @{
# Build the Host Guest Communication Manager component.
NEMU_WITH_HGCM = 1
## Build the bugcheck detection code.
#NEMU_WITH_GUEST_BUGCHECK_DETECTION =
# Enable the USB feature. This includes NEMU_WITH_VUSB!
NEMU_WITH_USB = 1
# Enable the USB 1.1 controller plus virtual USB HID devices.
NEMU_WITH_VUSB = 1
# Enable the USB 2.0 controller.
NEMU_WITH_EHCI = 1
# Enable the ISCSI feature.
NEMU_WITH_ISCSI = 1
# Enable INIP support in the ISCSI feature.
NEMU_WITH_INIP = 1
# Enables lwip as a core of NAT service
NEMU_WITH_LWIP_NAT = 1
# Enables compilation of NAT service
NEMU_WITH_NAT_SERVICE = 1
# Enable the E1000 feature.
NEMU_WITH_E1000 = 1
# Enable the Virtio feature.
NEMU_WITH_VIRTIO = 1
# Enable new PS/2 mouse emulation.
NEMU_WITH_NEW_PS2M = 1
# Enable ALSA support for Linux.
NEMU_WITH_ALSA = 1
# Enable Pulse support for Linux.
NEMU_WITH_PULSE = 1
# Enable PCI passthrough support.
NEMU_WITH_PCI_PASSTHROUGH = 1
# Enable statically linked dbus support.
if1of ($(KBUILD_TARGET), linux solaris)
 NEMU_WITH_DBUS = 1
endif
# Enable building PAM modules.
if1of ($(KBUILD_TARGET), linux solaris)
 NEMU_WITH_PAM = 1
endif
# Disable WINMM support for Windows (not implemented).
NEMU_WITH_WINMM =
# Enable internal networking.
NEMU_WITH_INTERNAL_NETWORKING = 1
# Enable vmsvga (svga2) graphics device variant, 2D part
NEMU_WITH_VMSVGA = 1
# Enable vmsvga (svga2) graphics device variant, 3D part
if1of ($(KBUILD_TARGET), darwin win)
 NEMU_WITH_VMSVGA3D = 1
endif
# Enable Host Guest Shared Memory Interface.
NEMU_WITH_HGSMI = 1
# Enable Video 2D Acceleration.
if1of ($(KBUILD_TARGET), darwin linux win freebsd)
 NEMU_WITH_VIDEOHWACCEL = 1
endif
# Enable Wddm Video driver for Vista+ guests.
NEMU_WITH_WDDM = 1
# Enable Wddm Video driver for Windows 8 guests.
NEMU_WITH_WDDM_W8 = 1
# Lazy developer!!
NEMUWDDM_WITH_VBVA = 1
# Lazy developer!!
ifdef NEMU_WITH_WDDM
 NEMU_WITH_VDMA = 1
else ifdef NEMU_WITH_VDMA
  undef NEMU_WITH_VDMA
endif
# Disable the Intel PXE ROM (uses Etherboot).
NEMU_WITH_INTEL_PXE =
# Enable EFI support
NEMU_WITH_EFI = 1
# Fetch EFI firmware image from the build server
#NEMU_WITH_EFIFW_FROM_BUILD_SERVER = 1
# Include the EFI firmware into the package
NEMU_WITH_EFIFW_PACKING = 1
# Use kStuff for MACH-O and LX binary loading.
if1of ($(KBUILD_TARGET_ARCH), x86 amd64)
 IPRT_WITH_KSTUFF = 1
endif
# Enable setuid wrapper for Solaris host DVD.
#NEMU_WITH_SUID_WRAPPER = 1
# Enable the virtual SATA/AHCI controller
NEMU_WITH_AHCI = 1
# Enable the new async completion manager
NEMU_WITH_PDM_ASYNC_COMPLETION = 1
ifdef NEMU_WITH_USB
 NEMU_WITH_VUSB = 1
 NEMU_WITH_XHCI_IMPL=1
endif
ifdef NEMU_WITH_EHCI
 NEMU_WITH_EHCI_IMPL = 1
endif
ifdef NEMU_WITH_PCI_PASSTHROUGH
 NEMU_WITH_PCI_PASSTHROUGH_IMPL = 1
endif
ifndef NEMU_WITHOUT_HOSTWEBCAM
 NEMU_WITH_USB_VIDEO_IMPL = 1
endif
# Enable the hal/sysfs USB code on Linux.
ifeq ($(KBUILD_TARGET),linux)
 NEMU_USB_WITH_SYSFS = 1
 # Disabled for now
 # NEMU_USB_WITH_DBUS = 1
 NEMU_USB_WITH_INOTIFY = 1
endif
# Enable performance API.
NEMU_WITH_RESOURCE_USAGE_API = 1
# Use NemuVolInfo for getting FS dependecies.
if1of ($(KBUILD_TARGET), linux)
 NEMU_WITH_DEVMAPPER = 1
endif
# Enable BusLogic SCSI host adapter
NEMU_WITH_BUSLOGIC = 1
# Enable LsiLogic SCSI host adapter
NEMU_WITH_LSILOGIC = 1
# Enable SCSI drivers
NEMU_WITH_SCSI = 1
# Enable this setting to force a fallback to default DMI data on configuration errors
NEMU_BIOS_DMI_FALLBACK =
# Enable the builtin PXE ROM
NEMU_WITH_PXE_ROM = 1
# Enable MSI support in devices
NEMU_WITH_MSI_DEVICES = 1
# Enable host network interface API.
if1of ($(KBUILD_TARGET), darwin freebsd linux solaris win)
 NEMU_WITH_HOSTNETIF_API = 1
endif
# Emulated USB smart card reader
NEMU_WITH_USB_CARDREADER = 1
# Disk crypt plugin
NEMU_WITH_PLUGIN_CRYPT = 1
# VirtualKD stub/loader device, only relevant on Windows host
NEMU_WITH_VIRTUALKD = 1
## @}

# legacy
ifdef NEMU_ONLY_TESTSUITE
 $(warning NEMU_ONLY_TESTSUITE was renamed to NEMU_ONLY_VALIDATIONKIT)
 NEMU_ONLY_VALIDATIONKIT = $(NEMU_ONLY_TESTSUITE)
endif

## @name Other Component
## @{
# Build the installer.
NEMU_WITH_INSTALLER = 1
# The kernel driver/module and related runtime libraries.
NEMU_WITH_NEMUDRV = 1
# The main api.
NEMU_WITH_MAIN = 1
# Whether to also ship 32-bit main API on 64-bit systems.
if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), solaris.amd64 win.amd64)
 if !defined(NEMU_ONLY_VALIDATIONKIT) && !defined(NEMU_ONLY_ADDITIONS) && !defined(NEMU_ONLY_DOCS)
  NEMU_WITH_32_ON_64_MAIN_API = 1
 endif
endif
# Whether to generate a database of USB vendor IDs and device IDs into NemuSVC.
NEMU_WITH_MAIN_USB_ID_DATABASE = 1
# The recompiler.
NEMU_WITH_REM = 1
# Set this to prefix all C symbols in XPCOM, to avoid dynamic linking problems
# caused by our XPCOM library polluting the symbol namespace for system libs.
if1of ($(KBUILD_TARGET), linux solaris)
 NEMU_WITH_XPCOM_NAMESPACE_CLEANUP = 1
endif
# The webservices api.
NEMU_WITH_WEBSERVICES = 1
NEMU_WITH_WEBSERVICES_SSL = 1
# The Qt 4 GUI.
NEMU_WITH_QTGUI = 1
# Indicates the Qt is Cocoa based on the Mac.
ifeq ($(KBUILD_TARGET),darwin)
 NEMU_WITH_COCOA_QT = 1
endif
# HiDPI support for OS X
NEMU_GUI_WITH_HIDPI = 1
# The SDL based GUI.
NEMU_WITH_NEMUSDL = 1
# Build NemuSDL with secure label support.
ifeq ($(filter win.amd64,$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)),) # too much work with freetype and all that.
NEMU_WITH_SECURELABEL = 1
endif
# The headless frontend.
NEMU_WITH_HEADLESS = 1
# Enable the build of VRDP server.
NEMU_WITH_VRDP = 1
# Build the VRDP authentication modules.
NEMU_WITH_VRDP_AUTHMOD = 1
# Build enhanced version of rdesktop.
NEMU_WITH_VRDP_RDESKTOP = 1
## The Direct Framebuffer GUI.
#NEMU_WITH_NEMUFB = 1
# Enables the Python<->XPCOM, Python<->COM and (WS enabled) Python<->WS bindings.
NEMU_WITH_PYTHON ?= 1
# Enables the PERL<->WS binding (if WS enabled).
#NEMU_WITH_PERL ?= 1
# Enables the PHP<->WS binding (if WS enabled).
NEMU_WITH_PHP ?= 1
if1of ($(KBUILD_TARGET), darwin linux solaris)
 # Enable Java<->XPCOM bridge + glue code
 NEMU_WITH_JXPCOM ?= 1
endif
if1of ($(KBUILD_TARGET), )
 # Enable Java<->MSCOM glue, bridge is provided by an external lib (Jacob)
 NEMU_WITH_JMSCOM ?= 1
endif
if1of ($(KBUILD_TARGET), darwin linux solaris)
 # Enable Java<->JAX-WS bridge
 NEMU_WITH_JWS ?= 1
endif
# Use XPIDL instead of XSLT stylesheet
NEMU_WITH_JAVA_SUPPORT_IN_XPIDL ?=
# Build against multiple Python versions present in the system
NEMU_WITH_MULTIVERSION_PYTHON ?= 1
# Enable the kchmviewer.
NEMU_WITH_KCHMVIEWER = 1
# Build the Validation Kit.
NEMU_WITH_VALIDATIONKIT = 1
# Build the testcases.
NEMU_WITH_TESTCASES = 1
# Enable this to build vditool even if NEMU_WITH_TESTCASES is disabled
NEMU_WITH_VDITOOL =
# Enable this to build nemu-img even if NEMU_WITH_TESTCASES is disabled
NEMU_WITH_NEMU_IMG =
# Enables the VPX module for VM video capturing
if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), darwin.x86 darwin.amd64 linux.x86 linux.amd64 solaris.amd64 win.x86 win.amd64)
 NEMU_WITH_VPX = 1
endif
# Enable shared folders
NEMU_WITH_SHARED_FOLDERS = 1
# Enable shared clipboard
NEMU_WITH_SHARED_CLIPBOARD = 1
# Enable the host/guest information service (aka guest properties).
NEMU_WITH_GUEST_PROPS = 1
# Enable this to prevent the guest from writing guest properties.
NEMU_WITH_GUEST_PROPS_RDONLY_GUEST =
# Compile the host channel
NEMU_WITH_HOST_CHANNEL = 1
# Enable the guest control service.
if1of ($(KBUILD_TARGET), darwin freebsd linux solaris win)
 NEMU_WITH_GUEST_CONTROL = 1
endif
# Enable ballooning
NEMU_WITH_MEMBALLOON = 1
# Enable crOpenGL service
if1of ($(KBUILD_TARGET), darwin freebsd linux solaris win)
 NEMU_WITH_CROGL = 1
endif
# Enable S3 support (requires libcurl)
NEMU_WITH_S3 = 1
# Enable Host=>Guest Drag'n'Drop
if1of ($(KBUILD_TARGET), darwin linux solaris win)
 NEMU_WITH_DRAG_AND_DROP = 1
 if1of ($(KBUILD_TARGET), darwin linux solaris win)
  NEMU_WITH_DRAG_AND_DROP_GH = $(NEMU_WITH_DRAG_AND_DROP)
 endif
 ifdef NEMU_WITH_DRAG_AND_DROP_GH
  ifeq ($(KBUILD_TARGET),darwin)
   # On OS X (Darwin) this needs to be set in order to get proper
   # guest->host support.
   # Note: Setting this requires Qt also having this feature enabled!
   NEMU_WITH_DRAG_AND_DROP_PROMISES = $(NEMU_WITH_DRAG_AND_DROP)
  endif
 endif
endif
# Use the VRDE external authentication library from NemuSVC
if1of ($(KBUILD_TARGET), win)
 NEMU_WITH_VRDEAUTH_IN_NEMUSVC = 1
endif
# Enables use of merge modules in the windows installer. This will increase
# the overall installer size significantly because merge modules are not able
# to use a common .cab file to reduce their size.
#NEMU_WITH_MSM_INSTALL = 1
## @}


## @name Networking
## @{
# Use NemuNetFlt for host interface networking.
if1of ($(KBUILD_TARGET), darwin freebsd linux solaris win)
 NEMU_WITH_NETFLT = 1
 ifeq ($(KBUILD_TARGET),solaris)
  # requires snv_159+.
  NEMU_WITH_NETFLT_CROSSBOW = 1
 endif
 # Use NemuNetAdp for host only networking.
 if1of ($(KBUILD_TARGET), darwin freebsd linux solaris win)
  NEMU_WITH_NETADP = 1
 endif
endif
# Enables the UDP tunnel transport.
NEMU_WITH_UDPTUNNEL = 1
# Enable the netshaper support
NEMU_WITH_NETSHAPER = 1
# Enable Virtual Distributed Ethernet or not.
if1of ($(KBUILD_TARGET), freebsd linux)
 NEMU_WITH_VDE = 1
endif
## @}


## @name Extension pack
## @{
# Enables the extension pack feature.
NEMU_WITH_EXTPACK = 1
# Enables separating code into the Oracle VM VirtualBox Extension Pack, dubbed PUEL.
NEMU_WITH_EXTPACK_PUEL = 1
# Enables building+packing the Oracle VM VirtualBox Extension Pack, includes NEMU_WITH_EXTPACK_PUEL
NEMU_WITH_EXTPACK_PUEL_BUILD = 1
# Enable the BusMouse sample extension pack.
#NEMU_WITH_EXTPACK_BUSMOUSESAMPLE = 1
# Enable the VNC server extension pack (GPL only).
#NEMU_WITH_EXTPACK_VNC = 1
# Enables the NemuDTrace extension pack.
NEMU_WITH_EXTPACK_NEMUDTRACE = 1
## @}

## @name Misc
## @{
# Enable Seamless mode
NEMU_X11_SEAMLESS_GUEST = 1
# Enables all the doxgen bits.
NEMU_WITH_ALL_DOXYGEN_TARGETS = 1
# Set this to skip installing the redistributable compiler runtime.
#NEMU_WITHOUT_COMPILER_REDIST = 1
# Enables NemuVMMR0.r0 (++) loading using the native loader on solaris.
# Good for debugging and analysis.  Experimental.
#NEMU_WITH_NATIVE_SOLARIS_LOADING = 1
# Set this to enable user mode dtrace probes.
if1of ($(KBUILD_TARGET), darwin linux solaris)
 NEMU_WITH_DTRACE_R3 = 1
 NEMU_WITH_DTRACE_R3_MAIN = 1
endif
# Set this to enable kernel driver dtrace probes.
if1of ($(KBUILD_TARGET), darwin solaris)
 NEMU_WITH_DTRACE_R0DRV = 1
endif
# Set this to enable dtrace probes in platform agnostic kernel code.
ifn1of ($(KBUILD_TARGET), os2)
 NEMU_WITH_DTRACE_R0 = 1
endif
# Set this to enable dtrace probes raw-mode context code.
if1of ($(KBUILD_TARGET), linux solaris)
 NEMU_WITH_DTRACE_RC = 1
endif
# Set this to enable support for dtrace probes in guest code.
#NEMU_WITH_DTRACE_GST = 1
# Set this to indicate that the host ships with DTrace.
if1of ($(KBUILD_TARGET), darwin solaris)
 NEMU_WITH_NATIVE_DTRACE = 1
endif
# Makes it possible to run some of the testcases and tools on older
# windows versions (only define when buildling win.x86).
#NEMU_WITH_MORE_NT4_COMPAT_BINARIES = 1
## @}


## @name Compiler and linker config
## @{
# For treating compiler and linker warnings as errors where possible.
if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), darwin.x86 darwin.amd64 linux.x86 linux.amd64 win.x86 win.amd64)
 NEMU_WITH_WARNINGS_AS_ERRORS = 1
endif
# Whether we can use Open Watcom to build stuff.
if1of ($(KBUILD_TARGET), darwin linux os2 win)
 NEMU_WITH_OPEN_WATCOM = 1
endif
## @}


## @name Hardening
## @{
# Enables hardening.
# Most developers will want to disable this in their LocalConfig.kmk.
NEMU_WITH_HARDENING = 1
# Where the application files are (going to be) installed.
#NEMU_PATH_APP_PRIVATE       = /usr/lib/virtualbox
ifdef NEMU_WITH_HARDENING
 if1of ($(KBUILD_TARGET), linux solaris)
  NEMU_PATH_APP_PRIVATE      = /opt/VirtualBox
 else ifeq ($(KBUILD_TARGET),darwin)
  NEMU_PATH_APP_PRIVATE      = /Applications/VirtualBox.app/Contents/MacOS
 else ifeq ($(KBUILD_TARGET),freebsd)
  NEMU_PATH_APP_PRIVATE      = /usr/local/lib/virtualbox
 else ifeq ($(KBUILD_TARGET),haiku)
  NEMU_PATH_APP_PRIVATE      = /boot/system/apps/VirtualBox
 endif
endif
# Where the architecture specific application files are (going to be) installed.
#NEMU_PATH_APP_PRIVATE_ARCH  = /usr/lib/virtualbox
ifdef NEMU_WITH_HARDENING
 if1of ($(KBUILD_TARGET), solaris)
  NEMU_PATH_APP_PRIVATE_ARCH_TOP = $(NEMU_PATH_APP_PRIVATE)
  NEMU_PATH_APP_PRIVATE_ARCH = $(NEMU_PATH_APP_PRIVATE_ARCH_TOP)/$(if-expr $(KBUILD_TARGET_ARCH) == "amd64",amd64,i386)
 else ifdef NEMU_PATH_APP_PRIVATE
  NEMU_PATH_APP_PRIVATE_ARCH = $(NEMU_PATH_APP_PRIVATE)
 endif
endif
# Where the shared libraries are (going to be) installed.
#NEMU_PATH_SHARED_LIBS       = /usr/lib
ifdef NEMU_WITH_HARDENING
 if1of ($(KBUILD_TARGET), solaris)
  NEMU_PATH_SHARED_LIBS      = $(NEMU_PATH_APP_PRIVATE)/$(if-expr $(KBUILD_TARGET_ARCH) == "amd64",amd64,i386)
 else ifdef NEMU_PATH_APP_PRIVATE
  NEMU_PATH_SHARED_LIBS      = $(NEMU_PATH_APP_PRIVATE)
 endif
endif
# Where the documentation is (going to be) installed.
#NEMU_PATH_APP_DOCS         = /usr/share/doc/virtualbox
ifdef NEMU_WITH_HARDENING
 ifdef NEMU_PATH_APP_PRIVATE
  NEMU_PATH_APP_DOCS         = $(NEMU_PATH_APP_PRIVATE)
 endif
endif
# The DT_RPATH/DT_RUNPATH to embed into the binaries (ELF).
# (This one is used for all binaries, there is no need to adjust this
# depending on the location of the object.)
#NEMU_WITH_RUNPATH = /usr/lib/virtualbox
ifdef NEMU_WITH_HARDENING
 if1of ($(KBUILD_TARGET), solaris)
  NEMU_WITH_RUNPATH = $(NEMU_PATH_APP_PRIVATE)/$(if-expr $(KBUILD_TARGET_ARCH) == "amd64",amd64,i386)
 else if1of ($(KBUILD_TARGET), freebsd linux)
  NEMU_WITH_RUNPATH = $(NEMU_PATH_APP_PRIVATE)
 endif
endif
# Enable use of the $ORIGIN DT_RPATH/DT_RUNPATH feature (ELF).
# Because of the setuid usage on all ELF platforms when hardening the build
# things gets a bit complicated since the $ORIGIN+setuid policy differs.
#NEMU_WITH_ORIGIN = 1
ifndef NEMU_WITH_HARDENING
 if1of ($(KBUILD_TARGET), linux solaris)
  NEMU_WITH_ORIGIN = 1
 endif
endif
# Enable the system wide support service/daemon.
# Very sketchy work in progress.
#NEMU_WITH_SUPSVC = 1

# Continue to support Vista w/o any service pack, at least for now.
NEMU_WITH_VISTA_NO_SP = 1
## @}


# Strip binaries of release and profile builds before packing them into the installer
# archive. When building .deb/.rpms, don't strip the symbols as they are required for
# the debug packages containing symbols for gdb located in /usr/lib/debug.
NEMU_DO_STRIP := $(if $(filter release profile,$(KBUILD_TYPE)),1,)


#
# Config items for enabling work in progress.
#
# It's good pratice to add stuff here even if it is currently disabled by
# default.
#
# Note! Please, do *not* add stuff to the global DEFS unless it is *really*
#       necessary!  The other guys will hate for it you when they have to
#       recompile everything when the feature is enabled or disabled.  Put
#       the ifdefs in target or template definitions.
#

# Mask all Local APIC interrupt vectors which are set up to NMI mode when switching
# to/from the guest in raw mode. Modern Linux kernels use the performance counter
# to raise an NMI from time to time.
if1of ($(KBUILD_TARGET), linux)
 NEMU_WITH_VMMR0_DISABLE_LAPIC_NMI = 1
endif
## For testing deadlock detection and lock order validation.
# If issues are found, create high priority defects and temporarily comment
# the next line.
NEMU_WITH_STRICT_LOCKS = 1


#
# Branding
#
NEMU_BRAND_BIOS_LOGO                 := $(PATH_ROOT)/src/Nemu/Devices/Graphics/BIOS/puel_logo.bmp
NEMU_BRAND_LICENSE_HTML              := $(PATH_ROOT)/doc/License-gpl-2.0.html
NEMU_BRAND_LICENSE_RTF               := $(PATH_ROOT)/doc/License-gpl-2.0.rtf
NEMU_BRAND_LICENSE_TXT               := $(PATH_ROOT)/doc/License-gpl-2.0.txt
NEMU_BRAND_LICENSE_VER               :=
NEMU_BRAND_GUI_ABOUT_PNG             := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/NonOSE/about.png
NEMU_BRAND_GUI_ABOUT_HIDPI_PNG       := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/hidpi/NonOSE/about_hidpi.png
NEMU_BRAND_GUI_ABOUT_16PX_PNG        := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/NonOSE/about_16px.png
NEMU_BRAND_GUI_ABOUT_16PX_HIDPI_PNG  := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/hidpi/NonOSE/about_16px_hidpi.png
NEMU_BRAND_GUI_NEMU_16PX_PNG         := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/NonOSE/VirtualBox_16px.png
NEMU_BRAND_GUI_NEMU_20PX_PNG         := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/NonOSE/VirtualBox_20px.png
NEMU_BRAND_GUI_NEMU_32PX_PNG         := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/NonOSE/VirtualBox_32px.png
NEMU_BRAND_GUI_NEMU_40PX_PNG         := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/NonOSE/VirtualBox_40px.png
NEMU_BRAND_GUI_NEMU_48PX_PNG         := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/NonOSE/VirtualBox_48px.png
NEMU_BRAND_GUI_NEMU_64PX_PNG         := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/NonOSE/VirtualBox_64px.png
NEMU_BRAND_GUI_NEMU_SVG              := $(PATH_ROOT)/src/Nemu/Artwork/NonOSE/virtualbox.svg
NEMU_BRAND_WIN_INST_DLGJPG           := $(PATH_ROOT)/src/Nemu/Installer/win/Binary/Dialog.jpg
NEMU_BRAND_WIN_INST_EXT              :=
NEMU_BRAND_WIN_ADD_INST_DLGBMP       := $(PATH_ROOT)/src/Nemu/Additions/WINNT/Installer/welcome.bmp
NEMU_BRAND_DARWIN_DISKIMAGE_DS_STORE := $(PATH_ROOT)/src/Nemu/Installer/darwin/DiskImage/DS_Store
NEMU_BRAND_DARWIN_DISKIMAGE_BG       := $(PATH_ROOT)/src/Nemu/Installer/darwin/DiskImage/nemu_folder.tiff
NEMU_BRAND_DARWIN_INSTALLER_BG       := $(PATH_ROOT)/src/Nemu/Installer/darwin/VirtualBox_mpkg/background.tif

#
# Skip stuff.
#

ifdef NEMU_ONLY_EXTPACKS
 # Clear some NEMU_WITH_XXX variables instead of adding ifdefs all over the place.
 NEMU_WITH_DEBUGGER =
 NEMU_WITH_ADDITIONS =
 NEMU_WITH_NEMUDRV =
 NEMU_WITH_TESTCASES =
endif

# NEMU_QUICK can be used by core developers to speed to the build
ifdef NEMU_QUICK
 # undefine variables by assigning blank.
 NEMU_WITH_VALIDATIONKIT=
 NEMU_WITH_TESTCASES=
 NEMU_WITH_MAIN =
 NEMU_WITH_NEMUSDL =
 NEMU_WITH_QTGUI =
 NEMU_WITH_DEBUGGER_GUI =
 NEMU_WITH_DOCS =
endif # NEMU_QUICK

ifeq ($(KBUILD_TARGET),darwin)
 # Don't bother with SDL ttf for now.
 NEMU_WITH_SECURELABEL=
 # We'll use the native html/help viewer.
 NEMU_WITH_KCHMVIEWER=
 NEMU_WITH_VRDP_RDESKTOP=
 # Permanent (no working SDL).
 NEMU_WITH_NEMUSDL=
endif

ifeq ($(KBUILD_TARGET),freebsd)
 NEMU_WITH_DOCS=
endif

ifeq ($(KBUILD_TARGET),haiku)
 # Don't bother with SDL ttf for now.
 NEMU_WITH_SECURELABEL=
 # We'll use the native html/help viewer.
 NEMU_WITH_KCHMVIEWER=
 NEMU_WITH_VRDP_RDESKTOP=
 # Permanent (no working SDL).
 NEMU_WITH_NEMUSDL=
 NEMU_WITH_DOCS=
 NEMU_WITH_NEMUDRV=
 NEMU_WITH_VRDP=
 NEMU_WITH_HEADLESS=
 NEMU_WITH_NEMUSDL=
 NEMU_WITH_QTGUI=
# NEMU_WITH_MAIN=
 NEMU_WITH_DOCS=
 NEMU_WITH_ISCSI=
 NEMU_WITH_INIP=
 NEMU_WITH_INTERNAL_NETWORKING=
 NEMU_WITH_PDM_ASYNC_COMPLETION=
 NEMU_WITH_KCHMVIEWER=
 NEMU_WITH_HARDENING=
endif


ifeq ($(KBUILD_TARGET),os2)
 NEMU_WITH_WEBSERVICES=
 NEMU_WITH_INSTALLER=
 NEMU_WITH_SECURELABEL=
 NEMU_WITH_VRDP_AUTHMOD=
 NEMU_WITH_VRDP_RDESKTOP=
 NEMU_WITH_VALIDATIONKIT=
 NEMU_WITH_QTGUI=
 NEMU_WITH_USB=
 NEMU_WITH_EHCI=
 NEMU_WITH_DOCS=
 NEMU_WITH_PDM_ASYNC_COMPLETION=
 NEMU_WITH_KCHMVIEWER=
 NEMU_WITH_HARDENING=
endif

ifeq ($(KBUILD_TARGET),solaris)
 NEMU_WITH_SECURELABEL=
 NEMU_WITH_OGL=
endif

ifeq ($(KBUILD_TARGET),win)
 NEMU_WITH_VRDP_RDESKTOP=
 NEMU_WITH_KCHMVIEWER=
endif

ifn1of ($(KBUILD_TARGET_ARCH), x86 amd64)
 NEMU_WITH_ADDITION_DRIVERS=
 NEMU_WITH_CROGL=
 NEMU_WITH_DEBUGGER=
 NEMU_WITH_DOCS=
 NEMU_WITH_EHCI=
 NEMU_WITH_HARDENING=
 NEMU_WITH_HEADLESS=
 NEMU_WITH_HGCM=
 NEMU_WITH_HGSMI=
 NEMU_WITH_INIP=
 NEMU_WITH_INSTALLER=
 NEMU_WITH_INTERNAL_NETWORKING=
 NEMU_WITH_ISCSI=
 NEMU_WITH_KCHMVIEWER=
 NEMU_WITH_MAIN=
 NEMU_WITH_PDM_ASYNC_COMPLETION=
 NEMU_WITH_QTGUI=
 NEMU_WITH_RAW_MODE=
 NEMU_WITH_SECURELABEL=
 NEMU_WITH_VALIDATIONKIT=
 NEMU_WITH_USB=
 NEMU_WITH_NEMUDRV=
 NEMU_WITH_NEMUSDL=
 NEMU_WITH_WEBSERVICES=
 NEMU_WITH_XPCOM=
 NEMU_WITHOUT_HARDENING=1
 # remove later:
 NEMU_WITH_VRDP=
 NEMU_WITH_VRDP_AUTHMOD=
 NEMU_WITH_VRDP_RDESKTOP=
endif


#
# Include automatic and local config file to override the above settings
# and to provide defaults for the settings below this point.
#
ifndef AUTOCFG
 AUTOCFG := $(wildcard $(PATH_ROOT)/AutoConfig.kmk)
endif
ifneq ($(AUTOCFG),)
 include $(AUTOCFG)
endif

ifndef LOCALCFG
 LOCALCFG := $(wildcard $(PATH_ROOT)/LocalConfig.kmk)
 ifneq ($(LOCALCFG),)
  include $(LOCALCFG)
 endif
else
 # Ignore it if it doesn't exist.
 if exists "$(LOCALCFG)"
  include $(LOCALCFG)
 else
  $(warning LOCALCFG='$(LOCALCFG)' does not exist)
  override LOCALCFG :=
 endif
endif

#
# Allow to overwrite the branding information from an external file
#
ifdef NEMU_BRANDING_CFG
 include $(NEMU_BRANDING_CFG)
endif

#
# Bitch about old settings.
#
ifdef NEMU_WITHOUT_LINUX_COMPILER_H
 $(warning NEMU_WITHOUT_LINUX_COMPILER_H was renamed to NEMU_WITH_LINUX_COMPILER_H, the meaning is inverted.)
endif

#
# Indicate NEMU_ONLY build if any of the NEMU_ONLY_* variables are set.
#
NEMU_ONLY_BUILD := $(strip $(foreach x, ADDITIONS DOCS EXTPACKS SDK VALIDATIONKIT\
	, $(if-expr defined(NEMU_ONLY_$(x)),NEMU_ONLY_$(x))))
if $(words $(NEMU_ONLY_BUILD)) > 1
 $(error Nemu: More than one NEMU_ONLY build enabled! $(NEMU_ONLY_BUILD))
endif

#
# For the docs build box.
#
ifdef NEMU_ONLY_DOCS
 NEMU_WITH_DOCS_CHM = 1
endif

#
# Disable components that are not open sourced.
#
ifdef NEMU_OSE
 NEMU_WITH_VRDP=
 NEMU_WITH_EHCI_IMPL=
 NEMU_WITH_XHCI_IMPL=
 NEMU_WITH_USB_VIDEO_IMPL=
 NEMU_WITH_EXTPACK_PUEL=
 NEMU_WITH_EXTPACK_PUEL_BUILD=
 NEMU_WITH_PCI_PASSTHROUGH_IMPL=
 NEMU_WITH_OS2_ADDITIONS_BIN=
 NEMU_WITH_SECURELABEL=
 NEMU_WITH_KCHMVIEWER=
 NEMU_WITH_PLUGIN_CRYPT=
 NEMU_WITH_DRAG_AND_DROP_PROMISES=
 ifn1of ($(KBUILD_TARGET), linux)
  NEMU_WITH_DOCS=
  NEMU_WITH_DOCS_PACKING=
 endif
 if1of ($(KBUILD_TARGET), solaris)
  NEMU_WITH_32_ON_64_MAIN_API=
 endif
 # Enable any translations in OSE, even partial ones.
 ifndef ($(NEMU_NO_DOCS_TRANSLATIONS))
  NEMU_WITH_DOCS_TRANSLATIONS = 1
 endif
 NEMU_WITH_INTEL_PXE=
 # Disable for OSE, requires snv_159+.
 NEMU_WITH_NETFLT_CROSSBOW=
 ifn1of ($(KBUILD_TARGET), darwin linux solaris win)
  NEMU_WITH_INSTALLER=
 endif
 if1of ($(KBUILD_TARGET), win)
  NEMU_WITH_VPX=
 endif
 NEMU_GUI_WITH_HIDPI=
 # branding
 NEMU_BRAND_LICENSE_HTML             := $(PATH_ROOT)/doc/License-gpl-2.0.html
 NEMU_BRAND_LICENSE_RTF              := $(PATH_ROOT)/doc/License-gpl-2.0.rtf
 NEMU_BRAND_LICENSE_TXT              := $(PATH_ROOT)/doc/License-gpl-2.0.txt
 NEMU_BRAND_BIOS_LOGO                := $(PATH_ROOT)/src/Nemu/Devices/Graphics/BIOS/ose_logo.bmp
 NEMU_BRAND_GUI_ABOUT_PNG            := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/about.png
 NEMU_BRAND_GUI_ABOUT_HIDPI_PNG      := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/about_hidpi.png
 NEMU_BRAND_GUI_ABOUT_16PX_PNG       := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/about_16px.png
 NEMU_BRAND_GUI_ABOUT_16PX_HIDPI_PNG := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/about_16px.png
 NEMU_BRAND_GUI_NEMU_16PX_PNG        := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/VirtualBox_16px.png
 NEMU_BRAND_GUI_NEMU_20PX_PNG        := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/VirtualBox_20px.png
 NEMU_BRAND_GUI_NEMU_32PX_PNG        := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/VirtualBox_32px.png
 NEMU_BRAND_GUI_NEMU_40PX_PNG        := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/VirtualBox_40px.png
 NEMU_BRAND_GUI_NEMU_48PX_PNG        := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/VirtualBox_48px.png
 NEMU_BRAND_GUI_NEMU_64PX_PNG        := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/VirtualBox_64px.png
 NEMU_BRAND_GUI_CUBE_42PX_PNG        := $(PATH_ROOT)/src/Nemu/Frontends/VirtualBox/images/OSE/VirtualBox_cube_42px.png
 NEMU_BRAND_GUI_NEMU_SVG             := $(PATH_ROOT)/src/Nemu/Artwork/OSE/virtualbox.svg
endif

#
# NEMU_WITHOUT_HARDENING is for developers (put in LocalConfig.kmk).
# Note that this is a bit rough since hardening governs more than one
# variable...  Also note that we allow NEMU_WITH_HARDENING=1 on the
# command line to overrule NEMU_WITHOUT_HARDENING (the check below).
#
ifdef NEMU_WITHOUT_HARDENING
 NEMU_WITH_HARDENING=
 ifeq ($(NEMU_WITH_HARDENING),)
  NEMU_PATH_APP_PRIVATE=
  NEMU_PATH_APP_PRIVATE_ARCH=
  NEMU_PATH_APP_PRIVATE_ARCH_TOP=
  NEMU_PATH_SHARED_LIBS=
  NEMU_PATH_APP_DOCS=
  NEMU_WITH_RUNPATH=
  if1of ($(KBUILD_TARGET), linux solaris)
   NEMU_WITH_ORIGIN=1
  endif
 endif
endif

#
# Sanitize the additions build config variables.
#
ifdef NEMU_WITH_ADDITIONS_FROM_BUILD_SERVER
 NEMU_WITHOUT_ADDITIONS := 1
 ifdef NEMU_ONLY_ADDITIONS
  $(error NEMU_ONLY_ADDITIONS + NEMU_WITH_ADDITIONS_FROM_BUILD_SERVER does not add up!)
 endif
endif

ifdef NEMU_ONLY_ADDITIONS
 ifdef NEMU_WITHOUT_ADDITIONS
  $(error NEMU_ONLY_ADDITIONS + NEMU_WITHOUT_ADDITIONS does not add up!)
 endif
endif

ifdef NEMU_WITHOUT_ADDITIONS
 # Zap anything that could be contradicting this.
 NEMU_WITH_ADDITIONS :=
endif

#
# Sanitize the documentation build config variables.
#
ifdef NEMU_WITH_DOCS_FROM_BUILD_SERVER
 NEMU_WITHOUT_DOCS := 1
 ifdef NEMU_ONLY_DOCS
  $(error NEMU_ONLY_DOCS + NEMU_WITH_DOCS_FROM_BUILD_SERVER does not add up!)
 endif
endif

ifdef NEMU_ONLY_DOCS
 ifdef NEMU_WITHOUT_DOCS
  $(error NEMU_ONLY_DOCS + NEMU_WITHOUT_DOCS does not add up!)
 endif
endif

ifdef NEMU_WITHOUT_DOCS
 # Zap anything that could be contradicting this.
 NEMU_WITH_DOCS :=
 NEMU_WITH_DOCS_CHM :=
endif

#
# Disable components for headless
#
ifdef NEMU_HEADLESS
 NEMU_WITH_QTGUI=
 NEMU_WITH_NEMUSDL=
 NEMU_WITH_OGL=
 NEMU_WITH_KCHMVIEWER=
 NEMU_WITH_VRDP_RDESKTOP=
endif

#
# Undefined NEMU_WITH_MAIN implies exclusion of a few more items.
#
ifndef NEMU_WITH_MAIN
 NEMU_WITH_NEMUSDL=
 NEMU_WITH_QTGUI=
 NEMU_WITH_DEBUGGER_GUI=
 NEMU_WITH_HEADLESS=
 ifdef NEMU_ONLY_DOCS
  $(error Oh, does NEMU_ONLY_DOCS actually end up here. sweet.)
 endif
 NEMU_WITH_DOCS=
endif

ifndef NEMU_WITH_QTGUI
 NEMU_WITH_KCHMVIEWER=
endif

ifdef NEMU_WITH_EXTPACK_PUEL_BUILD
 NEMU_WITH_EXTPACK_PUEL = 1
endif

ifdef NEMU_WITH_TESTSUITE
 $(warning NEMU_WITH_TESTSUITE was renamed to NEMU_WITH_VALIDATIONKIT)
 NEMU_WITH_VALIDATIONKIT = $(NEMU_WITH_TESTSUITE)
endif

#
# Mark OSE builds clearly, helps figuring out limitations more easily.
#
ifdef NEMU_OSE
# This can be overridden (e.g. in LocalConfig.kmk) by whoever publishes a set
# of VirtualBox binaries.  We request though that you always use something that
# clearly identifies your build and makes it clear that it is not one done by
# the VirtualBox team.
 NEMU_BUILD_PUBLISHER = _OSE
endif

# Keep in sync with G_virtualBoxPackage in glue-jaxws.xsl and glue-java.xsl
# Changed with every new version, so beware!
if $(NEMU_VERSION_BUILD) < 51
  NEMU_API_VERSION          = $(NEMU_VERSION_MAJOR)_$(NEMU_VERSION_MINOR)
else
  NEMU_API_VERSION          = $(NEMU_VERSION_MAJOR)_$(expr $(NEMU_VERSION_MINOR) + 1)
endif
NEMU_API_SUFFIX             = _$(NEMU_API_VERSION)
NEMU_JAVA_PACKAGE           = org.virtualbox$(NEMU_API_SUFFIX)

#
# Derived / helper config indicators.  Not configurable.
#

# Use the OpenGL module in qt when the video hardware acceleartion feature
# is enabled.
if defined(NEMU_WITH_VIDEOHWACCEL) && defined(NEMU_WITH_QTGUI)
 NEMU_GUI_USE_QGL = 1
else
 NEMU_GUI_USE_QGL=
endif

# Collection macro mainly for deciding whether NemuDTrace needs shipping.
NEMU_WITH_DTRACE := $(if-expr defined(NEMU_WITH_DTRACE_R0) || defined(NEMU_WITH_DTRACE_R0DRV) \
	       	            || defined(NEMU_WITH_DTRACE_R3) || defined(NEMU_WITH_DTRACE_RC),1,)


#
# Image and object format config.
#
if1of ($(KBUILD_TARGET), freebsd haiku linux netbsd openbsd solaris)
 NEMU_LDR_FMT = elf
endif
ifeq ($(KBUILD_TARGET),darwin)
 NEMU_LDR_FMT = macho
endif
ifeq ($(KBUILD_TARGET),os2)
 NEMU_LDR_FMT = lx
 NEMU_LDR_FMT32 = lx
 NEMU_LDR_FMT64 = elf
 DONT_USE_YASM = 1 # yasm doesn't implement omf yet.
endif
ifeq ($(KBUILD_TARGET),win)
 NEMU_LDR_FMT = pe
endif
NEMU_LDR_FMT32 ?= $(NEMU_LDR_FMT)
NEMU_LDR_FMT64 ?= $(NEMU_LDR_FMT)

#
# Assembler setup.
#
# This is a bit complicated since we have to support two different assmblers
# (yasm/nasm) and possibly two different formats (32-bit/64-bit).
#
ifeq ($(NEMU_LDR_FMT),elf)
 ifeq ($(KBUILD_TARGET_ARCH),x86)
NEMU_ASFLAGS_FMT = -f elf32 -DASM_FORMAT_ELF
 else
NEMU_ASFLAGS_FMT = -f elf64 -DASM_FORMAT_ELF
 endif
 NEMU_ASFLAGS_DBFINFO = -g dwarf2
endif
ifeq ($(NEMU_LDR_FMT),lx)
 NEMU_ASFLAGS_FMT = -f obj -DASM_FORMAT_OMF
 NEMU_ASFLAGS_DBFINFO = -g stabs
endif
ifeq ($(NEMU_LDR_FMT),macho)
 ifeq ($(KBUILD_TARGET_ARCH),x86)
  NEMU_ASFLAGS_FMT = -f macho32 -DASM_FORMAT_MACHO
 else
  NEMU_ASFLAGS_FMT = -f macho64 -DASM_FORMAT_MACHO
 endif
 NEMU_ASFLAGS_DBFINFO = -g dwarf2
endif
ifeq ($(NEMU_LDR_FMT),pe)
 ifeq ($(KBUILD_TARGET_ARCH),x86)
NEMU_ASFLAGS_FMT = -f win32 -DASM_FORMAT_PE
 else
NEMU_ASFLAGS_FMT = -f win64 -DASM_FORMAT_PE
 endif
NEMU_ASFLAGS_DBFINFO = -g cv8
endif
ifndef NEMU_ASFLAGS_FMT
 $(error NEMU_ASFLAGS_FMT is not defined. NEMU_LDR_FMT=$(NEMU_LDR_FMT))
endif

ifeq ($(NEMU_LDR_FMT32),elf)
 NEMU_ASFLAGS_FMT32 = -f elf32 -DASM_FORMAT_ELF
 NEMU_ASFLAGS_DBFINFO32 = -g dwarf2
endif
ifeq ($(NEMU_LDR_FMT32),lx)
 NEMU_ASFLAGS_FMT32 = -f obj -DASM_FORMAT_OMF
 NEMU_ASFLAGS_DBFINFO32 = -g stabs
endif
ifeq ($(NEMU_LDR_FMT32),macho)
 NEMU_ASFLAGS_FMT32 = -f macho32 -DASM_FORMAT_MACHO
 NEMU_ASFLAGS_DBFINFO32 = -g dwarf2
endif
ifeq ($(NEMU_LDR_FMT32),pe)
 NEMU_ASFLAGS_FMT32 = -f win32 -DASM_FORMAT_PE
 NEMU_ASFLAGS_DBFINFO32 = -g cv8
endif
ifndef NEMU_ASFLAGS_FMT32
 $(error NEMU_ASFLAGS_FMT32 is not defined. NEMU_LDR_FMT32=$(NEMU_LDR_FMT32))
endif

ifeq ($(NEMU_LDR_FMT64),elf)
 NEMU_ASFLAGS_FMT64 = -f elf64 -DASM_FORMAT_ELF
 NEMU_ASFLAGS_DBFINFO64 = -g dwarf2
endif
ifeq ($(NEMU_LDR_FMT64),macho)
 NEMU_ASFLAGS_FMT64 = -f macho64 -DASM_FORMAT_MACHO
 NEMU_ASFLAGS_DBFINFO64 = -g dwarf2
endif
ifeq ($(NEMU_LDR_FMT64),pe)
 NEMU_ASFLAGS_FMT64 = -f win64 -DASM_FORMAT_PE
 NEMU_ASFLAGS_DBFINFO64 = -g cv8
endif
ifndef NEMU_ASFLAGS_FMT64
 $(error NEMU_ASFLAGS_FMT64 is not defined. NEMU_LDR_FMT64=$(NEMU_LDR_FMT64))
endif

ifndef DONT_USE_YASM
 NEMU_ASTOOL    = YASM
 NEMU_LDR_FMT_2_YASM_DBGINFO.elf   = -g dwarf2
 NEMU_LDR_FMT_2_YASM_DBGINFO.lx    = -g stabs
 NEMU_LDR_FMT_2_YASM_DBGINFO.macho =
 NEMU_LDR_FMT_2_YASM_DBGINFO.pe    = -g cv8
 NEMU_ASFLAGS   = $(NEMU_ASFLAGS_FMT)   -D__YASM__ -Worphan-labels $(NEMU_YASM_Wno-segreg-in-64bit) $(NEMU_LDR_FMT_2_YASM_DBGINFO.$(NEMU_LDR_FMT))
 NEMU_ASFLAGS32 = $(NEMU_ASFLAGS_FMT32) -D__YASM__ -Worphan-labels $(NEMU_YASM_Wno-segreg-in-64bit) $(NEMU_LDR_FMT_2_YASM_DBGINFO.$(NEMU_LDR_FMT32))
 NEMU_ASFLAGS64 = $(NEMU_ASFLAGS_FMT64) -D__YASM__ -Worphan-labels $(NEMU_YASM_Wno-segreg-in-64bit) $(NEMU_LDR_FMT_2_YASM_DBGINFO.$(NEMU_LDR_FMT64))
else
 NEMU_ASTOOL    = NASM
 NEMU_ASFLAGS   = $(subst elf32,elf,$(NEMU_ASFLAGS_FMT))   -D__NASM__ -w+orphan-labels -g
 NEMU_ASFLAGS32 = $(subst elf32,elf,$(NEMU_ASFLAGS_FMT32)) -D__NASM__ -w+orphan-labels -g
 NEMU_ASFLAGS64 = $(NEMU_ASFLAGS_FMT64) -D__NASM__ -w+orphan-labels -g
endif

#
# Windows only has mingw handy. On *nix we have to deal with cross compiling
# 32-bit targets on 64-bit platforms, meaning we'll be using gcc32/g++32.
# In the latter case we'll also have to disable all the all the R0 driver related stuff.
#
ifndef NEMU_GCC_TOOL
 ifeq ($(KBUILD_TARGET),win)
  ifeq ($(KBUILD_TARGET_ARCH),x86)
   NEMU_GCC_TOOL := MINGW32
   TOOL_MINGW32_CFLAGS := $(UNDEFINED) # override -g
  else
   NEMU_GCC_TOOL := MINGWW64
  endif
 else ifeq ($(KBUILD_TARGET),os2)
  NEMU_GCC_TOOL := GXX3OMF
 else ifeq ($(KBUILD_TARGET),darwin)
  NEMU_GCC_TOOL := GXX4MACHO
 else ifeq ($(KBUILD_TARGET),haiku)
  # Haiku shouldn't pass '-r' to the linker by default
  NEMU_GCC_TOOL := GXX3PLAIN
 else ifeq ($(KBUILD_TARGET),solaris)
  NEMU_GCC_TOOL := GXX3PLAIN
  NEMU_GCC32_TOOL := GXX3PLAIN
  ifeq ($(KBUILD_HOST),solaris)
   TOOL_GXX3PLAIN_LD_SYSMOD ?= /usr/ccs/bin/ld
  endif
 else
  NEMU_GCC_TOOL := GXX3
  ifeq ($(KBUILD_TARGET_ARCH).$(KBUILD_HOST_ARCH),x86.amd64) ## @todo mixing target/host here!
   NEMU_GCC_TOOL := GXX32
   NEMU_WITH_NEMUDRV=
  else ifeq ($(KBUILD_TARGET_ARCH).$(KBUILD_HOST_ARCH),amd64.x86)
   NEMU_GCC_TOOL := GXX64
   NEMU_WITH_NEMUDRV=
  endif
 endif
endif
ifndef NEMU_GCC32_TOOL
 ifeq ($(KBUILD_TARGET_ARCH),x86)
  NEMU_GCC32_TOOL := $(NEMU_GCC_TOOL)
 else ifeq ($(KBUILD_TARGET),win)
  NEMU_GCC32_TOOL := MINGW32
 else
  NEMU_GCC32_TOOL := GXX32
 endif
endif

#
# Decide which Visual C++ compiler version we're using by default.
#
ifndef NEMU_VCC_TOOL_STEM
 NEMU_VCC_TOOL_STEM := VCC100
else ifn1of ($(NEMU_VCC_TOOL_STEM), VCC100 VCC110)
 $(error Nemu: NEMU_VCC_TOOL_STEM='$(NEMU_VCC_TOOL_STEM)' is not supported, only VCC100 and VCC110 is)
endif
ifndef NEMU_VCC_TOOL
 NEMU_VCC_TOOL := $(NEMU_VCC_TOOL_STEM)$(toupper $(KBUILD_TARGET_ARCH))
endif


## @todo Remove the default tool crap here!
TOOL = $(NEMU_GCC_TOOL)
TOOL.win.x86 = $(NEMU_VCC_TOOL_STEM)X86
TOOL.win.amd64 = $(NEMU_VCC_TOOL_STEM)AMD64
ASTOOL = $(NEMU_ASTOOL)


#
# Setup the global defines and includes.
#
# Note! The __SOMETHING__ #defines are deprecated as they violate the C/C++ specs.
#
INCS += $(PATH_ROOT)/include $(PATH_OUT)
DEFS += NEMU
DEFS.debug := DEBUG DEBUG_$(subst $(subst _, ,_),_,$(USERNAME)) DEBUG_USERNAME=$(subst $(subst _, ,_),_,$(USERNAME))
DEFS.dbgopt  = $(DEFS.debug)
DEFS.profile = NEMU_WITH_STATISTICS
DEFS.strict  = RT_STRICT NEMU_STRICT
DEFS.x86     = RT_ARCH_X86 __X86__
DEFS.amd64   = RT_ARCH_AMD64 __AMD64__
DEFS.darwin  = RT_OS_DARWIN __DARWIN__
DEFS.freebsd = RT_OS_FREEBSD __FREEBSD__
DEFS.haiku   = RT_OS_HAIKU
DEFS.linux   = RT_OS_LINUX _FILE_OFFSET_BITS=64
DEFS.netbsd  = RT_OS_NETBSD
DEFS.openbsd = RT_OS_OPENBSD
DEFS.os2     = RT_OS_OS2 __OS2__
DEFS.solaris = RT_OS_SOLARIS _FILE_OFFSET_BITS=64
DEFS.win     = RT_OS_WINDOWS __WIN__
DEFS.win.x86 = __WIN32__
DEFS.win.amd64 = __WIN64__
# optional defines (use environment or make commandline)
ifdef NEMU_WITH_STATISTICS
 DEFS += NEMU_WITH_STATISTICS
endif
ifdef NEMU_STRICT
 DEFS += NEMU_STRICT
endif
ifdef LOG_ENABLED
 DEFS += LOG_ENABLED
endif
ifdef NEMU_OSE
 DEFS += NEMU_OSE
endif
ifdef NEMU_WITH_64_BITS_GUESTS
 DEFS += NEMU_WITH_64_BITS_GUESTS
endif

# Don't flood CDEFS, old MASMs doesn't like too many defines.
ifdef NEMU_WITH_DEBUGGER
 DEFS += NEMU_WITH_DEBUGGER
endif
ifdef NEMU_WITH_HARDENING
 CDEFS += NEMU_WITH_HARDENING
endif
if defined(NEMU_WITH_STRICT_LOCKS) && ($(KBUILD_TYPE) == "debug" || $(KBUILD_TYPE) == "strict")
 CDEFS += RT_LOCK_STRICT RT_LOCK_STRICT_ORDER
endif
ifdef NEMU_WITH_EF_WRAPS
 CDEFS += RTMEM_WRAP_TO_EF_APIS RTMEM_WRAP_SOME_NEW_AND_DELETE_TO_EF
endif

# Quoted strings should not be passed to the assemblers since they might not
# subscribe to C preprocessing semantics.
ifdef NEMU_PATH_APP_PRIVATE
 CDEFS += RTPATH_APP_PRIVATE=\"$(NEMU_PATH_APP_PRIVATE)\"
endif
ifdef NEMU_PATH_APP_PRIVATE_ARCH
 CDEFS += RTPATH_APP_PRIVATE_ARCH=\"$(NEMU_PATH_APP_PRIVATE_ARCH)\"
endif
ifdef NEMU_PATH_APP_PRIVATE_ARCH_TOP
 CDEFS += RTPATH_APP_PRIVATE_ARCH_TOP=\"$(NEMU_PATH_APP_PRIVATE_ARCH_TOP)\"
endif
ifdef NEMU_PATH_SHARED_LIBS
 CDEFS += RTPATH_SHARED_LIBS=\"$(NEMU_PATH_SHARED_LIBS)\"
endif
ifdef NEMU_PATH_APP_DOCS
 CDEFS += RTPATH_APP_DOCS=\"$(NEMU_PATH_APP_DOCS)\"
endif
CXXDEFS  += $(CDEFS)
OBJCDEFS += $(CDEFS)

USES += dtrace


#
# Compiler optimization flags.
#
NEMU_GCC_WARN     ?= -Wall $(NEMU_GCC_Wextra) $(NEMU_GCC_Wno-missing-field-initializers) -Wno-unused -Wno-trigraphs $(NEMU_GCC_fdiagnostics-show-option) $(NEMU_GCC_Wno-unused-parameter) $(NEMU_GCC_Wlogical-op)
NEMU_GCC_WARN_PEDANTIC = -Wshadow $(NEMU_GCC_WARN) -Wno-long-long
ifdef NEMU_WITH_MASOCHISTIC_WARNINGS
 NEMU_GCC_WARN_PEDANTIC += -Wunused-variable -Wunused-function -Wunused-label -Wunused-parameter
endif
NEMU_GCC_PEDANTIC_CXX ?= -pedantic -Wshadow $(NEMU_GCC_WARN_PEDANTIC) -Wno-long-long $(NEMU_GCC_Wno-delete-non-virtual-dtor)
NEMU_GCC_PEDANTIC_C   ?= -pedantic -Wshadow $(NEMU_GCC_WARN_PEDANTIC) -Wno-long-long -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations -Werror-implicit-function-declaration
ifeq ($(KBUILD_TARGET),win)
 NEMU_C_CXX_FLAGS_NO_UNUSED_PARAMETERS = #-Wdxxxx
else
 NEMU_C_CXX_FLAGS_NO_UNUSED_PARAMETERS = -Wno-unused-parameter
endif
ifeq ($(KBUILD_TYPE),debug)
 NEMU_GCC_FP     ?= -fno-omit-frame-pointer
 NEMU_GCC_OPT    ?= -O0
 NEMU_VCC_FP     ?= -Oy-
 NEMU_VCC_OPT    ?=
 NEMU_GCC_R0_FP  ?= -fno-omit-frame-pointer -fno-optimize-sibling-calls
 NEMU_GCC_R0_OPT ?= -O2
 NEMU_VCC_R0_FP  ?= -Oy-
 NEMU_VCC_R0_OPT ?=
 NEMU_GCC_GC_FP  ?= -fno-omit-frame-pointer -fno-optimize-sibling-calls
 NEMU_GCC_GC_OPT ?= -O2
 NEMU_VCC_GC_FP  ?= -Oy-
 NEMU_VCC_GC_OPT ?=
else
 # We should use -fomit-frame-pointer for GCC / -Oy for VCC.
 # -funwind-tables provides support for backtraces in gdb then.
 NEMU_GCC_FP     ?= -fno-omit-frame-pointer
 NEMU_GCC_OPT    ?= -O2 $(NEMU_GCC_mtune-generic)
 NEMU_VCC_FP     ?= -Oy-
 NEMU_VCC_OPT    ?= -O2
 NEMU_GCC_R0_FP  ?= -fno-omit-frame-pointer
 NEMU_GCC_R0_OPT ?= -O2 $(NEMU_GCC_mtune-generic)
 NEMU_VCC_R0_FP  ?= -Oy-
 NEMU_VCC_R0_OPT ?= -O2
 NEMU_GCC_GC_FP  ?= -fno-omit-frame-pointer
 NEMU_GCC_GC_OPT ?= -O2 $(NEMU_GCC_mtune-generic)
 NEMU_VCC_GC_FP  ?= -Oy-
 NEMU_VCC_GC_OPT ?= -O2
endif
ifeq ($(KBUILD_TARGET_ARCH),x86)
 ifneq ($(KBUILD_TARGET),darwin)
  # (The '<=' operator is for prepending (kmk specific).)
  NEMU_GCC_OPT <= -march=i586
 endif
endif


#
# Select the CRT type we're using with Microsoft Visual C++.
#
ifdef NEMU_WITH_DEBUG_VCC_CRT
 NEMU_VCC_CRT_TYPE   = d
 NEMU_VCC_CRT_TYPE_N =
else
 NEMU_VCC_CRT_TYPE   =
 NEMU_VCC_CRT_TYPE_N = d
endif

#
# Decide which Windows DDK to use by default.
#
ifeq ($(NEMU_VCC_TOOL_STEM),VCC110)
 NEMU_WINDDK         ?= WINDDK80
else
 NEMU_WINDDK         ?= WINDDK71
endif
NEMU_WINDDK_WLH      ?= $(NEMU_WINDDK)WLH

NEMU_WINDDK_GST      ?= $(NEMU_WINDDK)
NEMU_WINDDK_GST_W8   ?= WINDDK80W8
NEMU_WINDDK_GST_W7   ?= $(NEMU_WINDDK_GST)W7
NEMU_WINDDK_GST_WLH  ?= $(NEMU_WINDDK_GST)WLH
NEMU_WINDDK_GST_W2K3 ?= WINDDK71WNET
ifeq ($(KBUILD_TARGET_ARCH),x86)
 NEMU_WINDDK_GST_WXP ?= WINDDK71WXP
 NEMU_WINDDK_GST_W2K ?= $(NEMU_WINDDK_GST_WXP)
 NEMU_WINDDK_GST_NT4 ?= $(NEMU_WINDDK_GST_WXP)
else
 NEMU_WINDDK_GST_WXP ?= $(NEMU_WINDDK_GST_W2K3)
 NEMU_WINDDK_GST_W2K ?= $(NEMU_WINDDK_GST_W2K3)
 NEMU_WINDDK_GST_NT4 ?= $(NEMU_WINDDK_GST_W2K3)
endif


#
# Decide which Windows SDK to use by default.
#
ifeq ($(NEMU_VCC_TOOL_STEM),VCC110)
 NEMU_WINPSDK ?= WINPSDK80
else
 NEMU_WINPSDK ?= WINPSDK71
endif
NEMU_WINPSDK_GST      ?= $(NEMU_WINPSDK)
NEMU_WINPSDK_GST_W8   ?= WINPSDK80
NEMU_WINPSDK_GST_W7   ?= $(NEMU_WINPSDK_GST)
NEMU_WINPSDK_GST_WLH  ?= $(NEMU_WINPSDK_GST)
NEMU_WINPSDK_GST_WXP  ?= $(NEMU_WINPSDK_GST)
ifeq ($(KBUILD_TARGET_ARCH),x86)
 NEMU_WINPSDK_GST_W2K ?= $(NEMU_WINPSDK_GST)
 NEMU_WINPSDK_GST_NT4 ?= $(NEMU_WINPSDK_GST)
else
 NEMU_WINPSDK_GST_W2K ?= $(NEMU_WINPSDK_GST_WXP)
 NEMU_WINPSDK_GST_NT4 ?= $(NEMU_WINPSDK_GST_WXP)
endif


#
# ARCH_BITS_DEFS.
#
if1of ($(KBUILD_TARGET_ARCH),amd64 sparc64)
 NEMU_HC_ARCH_BITS := 64
 ARCH_BITS_DEFS    := HC_ARCH_BITS=64
else if1of ($(KBUILD_TARGET_ARCH),x86 sparc32)
 NEMU_HC_ARCH_BITS := 32
 ARCH_BITS_DEFS    := HC_ARCH_BITS=32
else
 $(error Nemu: KBUILD_TARGET_ARCH=$(KBUILD_TARGET_ARCH))
endif

ifdef NEMU_WITH_64_BITS_GUESTS
 NEMU_GC_ARCH_BITS_DEFS := GC_ARCH_BITS=64
else
 NEMU_GC_ARCH_BITS_DEFS := GC_ARCH_BITS=32
endif
ARCH_BITS_DEFS += $(NEMU_GC_ARCH_BITS_DEFS)

#
# Add the output dir(s) to the dynamic loader search path.
#
if1of ($(KBUILD_HOST), freebsd linux netbsd openbsd solaris)
 export LD_LIBRARY_PATH:=$(PATH_STAGE_BIN):$(PATH_STAGE_LIB):$(LD_LIBRARY_PATH)
endif
ifeq ($(KBUILD_HOST),haiku)
 export LIBRARY_PATH:=$(PATH_STAGE_BIN):$(PATH_STAGE_LIB):$(LIBRARY_PATH)
endif
ifeq ($(KBUILD_HOST),os2)
 #fixme! export BEGINLIBPATH:=$(PATH_STAGE_BIN);$(PATH_STAGE_LIB);$(BEGINLIBPATH)
endif
ifeq ($(KBUILD_HOST),win)
  # This check is a bit hacky, but avoids problems with PATH being changed
  # again when the makefiles are reread because some automatically generated
  # makefile has been modified.
  ifeq ($(findstring $(PATH_STAGE_BIN);$(PATH_STAGE_LIB);,$(PATH)),)
   export PATH:=$(PATH_STAGE_BIN);$(PATH_STAGE_LIB);$(PATH)
  endif
endif

#
# Common libraries and tools.
#
ifeq ($(KBUILD_TARGET),darwin)
 LIB_RUNTIME     = $(PATH_STAGE_BIN)/NemuRT.dylib
 LIB_RUNTIME_EF  = #$(PATH_STAGE_LIB)/RuntimeEFCPP.a
 NEMU_LIB_RUNTIME_X86   = $(PATH_STAGE_BIN)/NemuRT-x86.dylib
 LIB_KPROFILE    = $(PATH_STAGE_BIN)/kPrf2.dylib
 LIB_VMM         = $(PATH_STAGE_BIN)/NemuVMM.dylib
 LIB_VMMRC       = $(PATH_STAGE_BIN)/VMMRC.rc
 LIB_REM         = $(PATH_STAGE_LIB)/NemuREM.dylib
 LIB_XPCOM       = $(PATH_STAGE_BIN)/NemuXPCOM.dylib
 NEMU_LIB_XPCOM_X86     = $(PATH_STAGE_BIN)/NemuXPCOM-x86.dylib
 LIB_DDU         = $(PATH_STAGE_BIN)/NemuDDU.dylib
endif
if1of ($(KBUILD_TARGET), freebsd haiku linux netbsd openbsd solaris)
 LIB_RUNTIME     = $(PATH_STAGE_BIN)/NemuRT.so
 LIB_RUNTIME_EF  = $(PATH_STAGE_LIB)/RuntimeEFCPP.a
 NEMU_LIB_RUNTIME_X86   = $(PATH_STAGE_BIN)/NemuRT-x86.so
 LIB_KPROFILE    = $(PATH_STAGE_BIN)/kPrf2.so
 LIB_VMM         = $(PATH_STAGE_BIN)/NemuVMM.so
 LIB_VMMRC       = $(PATH_STAGE_BIN)/VMMRC.rc
 LIB_REM         = $(PATH_STAGE_LIB)/NemuREM.so
 LIB_XPCOM       = $(PATH_STAGE_BIN)/NemuXPCOM.so
 NEMU_LIB_XPCOM_X86   = $(PATH_STAGE_BIN)/NemuXPCOM-x86.so
 LIB_DDU         = $(PATH_STAGE_BIN)/NemuDDU.so
endif
ifeq ($(KBUILD_TARGET),os2)
 LIB_RUNTIME     = $(PATH_STAGE_BIN)/NemuRT.dll
 LIB_RUNTIME_EF  = #$(PATH_STAGE_LIB)/RuntimeEFCPP.a
 NEMU_LIB_RUNTIME_X86   = $(PATH_STAGE_BIN)/NemuRT-x86.dll
 LIB_KPROFILE    = $(PATH_STAGE_BIN)/kPrf2.dll
 LIB_VMM         = $(PATH_STAGE_BIN)/NemuVMM.dll
 LIB_VMMRC       = $(PATH_STAGE_LIB)/VMMRCImp.lib
 LIB_REM         = $(PATH_STAGE_LIB)/NemuREMImp.lib
 LIB_XPCOM       = $(PATH_STAGE_BIN)/NemuXCOM.dll
 NEMU_LIB_XPCOM_X86     = $(PATH_STAGE_BIN)/NemuXPCOM-x86.dll
 LIB_DDU         = $(PATH_STAGE_BIN)/NemuDDU.dll
 NEMU_OBJ_SYS0   = $(PATH_OBJ)/RuntimeR0/os2/sys0.obj
endif
ifeq ($(KBUILD_TARGET),win)
 LIB_RUNTIME     = $(PATH_STAGE_LIB)/NemuRT.lib
 LIB_RUNTIME_EF  = #$(PATH_STAGE_LIB)/RuntimeEFCPP.lib
 NEMU_LIB_RUNTIME_X86   = $(PATH_STAGE_LIB)/NemuRT-x86.lib
 LIB_KPROFILE    = $(PATH_STAGE_LIB)/kPrf2.lib
 LIB_VMM         = $(PATH_STAGE_LIB)/NemuVMM.lib
 LIB_VMMRC       = $(PATH_OBJ)/VMMRC/VMMRC.lib
 LIB_REM         = $(PATH_STAGE_LIB)/NemuREMImp.lib
 LIB_XPCOM       = $(PATH_STAGE_BIN)/NemuXPCOM.lib
 NEMU_LIB_XPCOM_X86     = $(PATH_STAGE_BIN)/NemuXPCOM-x86.lib
 LIB_DDU         = $(PATH_STAGE_LIB)/NemuDDU.lib
endif
if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), win.amd64 linux.amd64)
 NEMU_LIB_VMM_LAZY      = $(PATH_STAGE_LIB)/VMMR3LazyImp$(NEMU_SUFF_LIB)
else
 NEMU_LIB_VMM_LAZY      = $(LIB_VMM)
endif
NEMU_LIB_SUPHARDENED    = $(PATH_STAGE_LIB)/SUPR3HardenedStatic$(NEMU_SUFF_LIB)
NEMU_LIB_RUNTIME_STATIC = $(PATH_STAGE_LIB)/RuntimeR3$(NEMU_SUFF_LIB)

ifndef NEMU_WITH_REM
 LIB_REM :=
endif

# Python
ifndef NEMU_BLD_PYTHON
 if1of ($(KBUILD_HOST), win)
  NEMU_BLD_PYTHON := $(firstword $(rsort $(wildcard $(KBUILD_DEVTOOLS)/win.x86/python/v*/python$(HOSTSUFF_EXE))) \
  				   python-not-found.exe)
 else
  NEMU_BLD_PYTHON := $(firstword $(which python2.7$(HOSTSUFF_EXE)) $(which python2.6$(HOSTSUFF_EXE)) \
                                 $(which python$(HOSTSUFF_EXE)) python$(HOSTSUFF_EXE))
 endif
endif

#
# pylint setup, see http://www.logilab.org/857.
# Supported are 0.21.0 - 0.25.2, but no 0.26.0.
#
# Disabled:
#   W0301 - Unnecessary semicolon.
#   W0511 - TODO/XXX/FIXME/+++.
#   W0603 - Using the global statement.
#   W0702 - No exception type(s) specified.
#   W0703 - Catch "Exception".
#   I0011 - Locally disabling XXXXX.
#   C0321 - More than one statement on a single line.
#   R0201 - Method could be a function.
#
# Note! Yes, --max-branchs is a typo, but not by me.
#
# Note! Users of older pylint release (< 1.0) needs to define
#       NEMU_WITH_PYLINT_PRE_V1_0 in LocalConfig because they changed the
#       output arguments in an backwards incompatible way and added more
#       attribute regex options.
#
ifndef NEMU_PYLINT
 NEMU_PYLINT        := $(firstword $(which pylint-2.7) $(which pylint-2.6) $(which pylint2) $(which pylint))
 ifdef NEMU_PYLINT
  NEMU_PYLINT       := $(NEMU_BLD_PYTHON) $(NEMU_PYLINT)
 endif
endif
if !defined(NEMU_WITH_PYLINT) && defined(NEMU_PYLINT)
 NEMU_WITH_PYLINT := 1
endif
NEMU_PYLINT_FLAGS   := --report=n \
	$(if-expr !defined(NEMU_WITH_PYLINT_PRE_V1_0)\
	  ,--msg-template='{path}:{line}: <{msg_id}>({obj}:{symbol}): {msg}' \
	  ,--output-format=msvs --include-ids=y) \
	--persistent=n \
	--rcfile=$(PATH_ROOT)/tools/pylintrc \
	--max-line-length=130 \
	--max-attributes=20 \
	--max-branch$(if-expr !defined(NEMU_WITH_PYLINT_PRE_V1_0),e,)s=50 \
	--max-statements=100 \
	--max-returns=100 \
	--max-public-methods=139 \
	--max-args=9 \
	--max-module-lines=4096 \
       --max-locals=32 \
       --min-public-methods=0 \
	--function-rgx='[a-z_][a-zA-Z0-9_]{2,40}$(DOLLAR)' \
	--method-rgx='[a-z_][a-zA-Z0-9_]{2,40}$(DOLLAR)' \
	--argument-rgx='([a-z_][a-zA-Z0-9_]{2,30}|rc|hr|s|c|ch|cx|cy|cb|fn)$(DOLLAR)' \
	--variable-rgx='([a-z_][a-zA-Z0-9_]{2,30}|rc|hr|s|c|ch|cx|cy|cb|fn)$(DOLLAR)' \
	--attr-rgx='([a-z_][a-zA-Z0-9_]{2,30}|rc|hr|o)$(DOLLAR)' \
	--module-rgx='(([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+)|(td[A-Z][a-zA-Z0-9]+)|(t(e|)st(-|)[a-zA-Z0-9]+))$(DOLLAR)' \
	--class-rgx='(td|)[A-Z_][a-zA-Z0-9_]+$(DOLLAR)' \
	--const-rgx='(g_(k|)[abcdefhmnpilorstu]+[A-Z][a-zA-Z0-9]+|[A-Z_][A-Z0-9_]+|__copyright__|__version__|__file__|__all__)$(DOLLAR)' \
	--good-names='i,j,k,t,o,c,e,ch,s,_' \
	$(if-expr !defined(NEMU_WITH_PYLINT_PRE_V1_0),--class-attribute-rgx='(k[abcdefhmnpilorstu]+[A-Z0-9][a-zA-Z0-9_]{0,32}|[A-Z_][A-Z0-9_]{2,32})',) \
       $(if-expr defined(NEMU_WITH_PYLINT_V1_1_PLUS) || defined(NEMU_WITH_PYLINT_V1_2_1_PLUS),--disable=C0326,) \
       $(if-expr defined(NEMU_WITH_PYLINT_V1_2_1_PLUS),--disable=C0330 --disable=W0123,) \
	--disable=W0301,W0511,W0603,W0702,W0703,C0321,R0201,I0011 \
	--ignored-classes=testdriver.nemucon \


# Define the macro for win path conversion.
ifndef NEMU_ONLY_SDK
  NEMU_FN_MAKE_WIN_PATH = $(subst /,\\,$(1))
else
  # on Wine Z: is always FS root
  NEMU_FN_MAKE_WIN_PATH = $(subst /,\\,$(patsubst /%,Z:/%,$(1)))
endif #!NEMU_ONLY_SDK

# The kprofile build automagically links with kProfile.
ifeq ($(KBUILD_TYPE),kprofile)
 LIB_RUNTIME += $(LIB_KPROFILE)
endif

# Enable C++ electric fence heap. (Warning: will easily run out of virtual memory / kernel stuff on Linux/Windows.)
ifdef NEMU_WITH_CPP_EF
 LIB_RUNTIME <= $(LIB_RUNTIME_EF)
endif

# Overridable libraries (unix).
LIB_PTHREAD      ?= pthread

# Xcursor (consider an SDK for this).
ifeq ($(NEMU_XCURSOR_LIBS),)
 ifeq ($(KBUILD_TARGET),solaris)
  NEMU_XCURSOR_LIBS := $(lastword $(wildcard $(KBUILD_DEVTOOLS_TRG)/libXcursor/*/lib/libXcursor.a))
  ifneq ($(NEMU_XCURSOR_LIBS),)
   NEMU_XCURSOR_INCS := $(patsubst %/lib/libXcursor.a,%/include, $(NEMU_XCURSOR_LIBS))
   NEMU_XCURSOR_LIBS += X11 Xrender Xfixes
  endif
 endif
 ifeq ($(NEMU_XCURSOR_LIBS),)
  NEMU_XCURSOR_LIBS := Xcursor
 endif
endif


# Intel ASL compiler for ACPI
NEMU_IASLCMD   ?= $(firstword $(wildcard $(KBUILD_DEVTOOLS_HST)/bin/iasl$(HOSTSUFF_EXE)) iasl$(HOSTSUFF_EXE))

# libxslt XSLT processor. (see PATH_TOOL_YASM for explanation why it's temporarily located in bin.)
ifeq ($(NEMU_XSLTPROC),)
 ifeq ($(KBUILD_HOST),win)
  NEMU_XSLTPROC := $(wildcard $(KBUILD_DEVTOOLS)/$(KBUILD_HOST).$(KBUILD_HOST_ARCH)/libxslt/10128/bin/xsltproc.exe)
  ifeq ($(NEMU_XSLTPROC),)
   NEMU_XSLTPROC := $(KBUILD_DEVTOOLS)/win.x86/bin/xsltproc.exe
  endif
 else ifeq ($(KBUILD_HOST),os2)
  NEMU_XSLTPROC  := BEGINLIBPATH="$(KBUILD_DEVTOOLS_HST)/bin;$$BEGINLIBPATH" $(KBUILD_DEVTOOLS_HST)/bin/xsltproc.exe
 else ifeq ($(KBUILD_HOST),haiku)
  NEMU_XSLTPROC  := $(KBUILD_DEVTOOLS)/haiku.x86/bin/xsltproc
 else
  NEMU_XSLTPROC  := xsltproc$(HOSTSUFF_EXE)
 endif
endif

# bin2c (convert binary files into C arrays)
NEMU_BIN2C      ?= $(PATH_OBJ)/bin2c/bin2c$(HOSTSUFF_EXE)

# RTManifest (extension pack manifest utility)
NEMU_RTMANIFEST ?= $(PATH_OBJ)/bldRTManifest/bldRTManifest$(HOSTSUFF_EXE)

# RTSignTool (certificate extraction tool)
NEMU_RTSIGNTOOL ?= $(PATH_OBJ)/bldRTSignTool/bldRTSignTool$(HOSTSUFF_EXE)

# NemuCmp (simple /bin/cmp with more sensible output)
NEMU_NEMUCMP    ?= $(PATH_OBJ)/NemuCmp/NemuCmp$(HOSTSUFF_EXE)

# NemuCPP (special purpose C preprocessor)
NEMU_NEMUCPP    ?= $(PATH_OBJ)/NemuCPP/NemuCPP$(HOSTSUFF_EXE)

# NemuTpG (tracepoint generator)
NEMU_NEMUTPG    ?= $(PATH_OBJ)/NemuTpG/NemuTpG$(HOSTSUFF_EXE)

# NemuPeSetVersion (changes the minimum OS version of an image)
NEMU_PE_SET_VERSION ?= $(PATH_OBJ)/NemuPeSetVersion/NemuPeSetVersion$(HOSTSUFF_EXE)

# Visual C++ EditBin.exe.
NEMU_VCC_EDITBIN = $(if $(PATH_TOOL_$(NEMU_VCC_TOOL)_BIN),$(PATH_TOOL_$(NEMU_VCC_TOOL)_BIN)/,)editbin.exe /NoLogo

# filesplitter (splits java files)
NEMU_FILESPLIT  ?= $(PATH_OBJ)/filesplitter/filesplitter$(HOSTSUFF_EXE)

# biossums (set BIOS checksums)
NEMU_BIOSSUMS   ?= $(PATH_OBJ)/biossums/biossums$(HOSTSUFF_EXE)

# MakeAlternativeSource (for BIOSes)
NEMU_MAKE_ALTERNATIVE_SOURCE ?= $(PATH_OBJ)/MakeAlternativeSource/MakeAlternativeSource$(HOSTSUFF_EXE)

# NemuDef2LazyLoad (lazy dynamic library loader assembly generator)
NEMU_DEF_2_LAZY_LOAD ?= $(PATH_OBJ)/NemuDef2LazyLoad/NemuDef2LazyLoad$(HOSTSUFF_EXE)

# NemuCheckImports (checks what we imports from on windows)
NEMU_CHECK_IMPORTS ?= $(PATH_OBJ)/NemuCheckImports/NemuCheckImports$(HOSTSUFF_EXE)

# GNU tar if present.
if1of ($(KBUILD_TARGET), linux os2 win)
 NEMU_GTAR ?= tar
else if1of ($(KBUILD_TARGET), freebsd solaris)
 NEMU_GTAR ?= gtar
endif

# mkisofs
ifeq ($(KBUILD_HOST),win)
 NEMU_MKISOFS  ?= $(KBUILD_DEVTOOLS_HST)/bin/mkisofs.exe
else
 NEMU_MKISOFS  ?= mkisofs
endif

ifeq ($(KBUILD_HOST),win)
 NEMU_NM ?= $(PATH_TOOL_MINGW32)/bin/nm.exe -p
else
 NEMU_NM ?= nm -p
endif

# Makeself for the linux installers.
NEMU_MAKESELF  ?= $(KBUILD_DEVTOOLS)/common/makeself/v2.1.5/makeself.sh

# Microsoft HTML Help Workshop.
NEMU_PATH_HTML_HELP_WORKSHOP ?= $(KBUILD_DEVTOOLS)/win.x86/HTML_Help_Workshop/v1.3/

# Path to the null soft installer.
NEMU_PATH_NSIS ?= $(KBUILD_DEVTOOLS)/win.x86/nsis/v2.46-log-nsscm-r1

# Path to AutoIt3.
NEMU_PATH_AUTOIT3 ?= $(KBUILD_DEVTOOLS)/win.x86/autoit/v3.2.10.0

# Windows install tools...
# Note! The scripts has been moved to Bin in v8.0.
NEMU_PATH_WIX       ?= $(KBUILD_DEVTOOLS)/win.x86/wix/v3.8.1128.0
NEMU_PATH_MSITRAN   ?= $(KBUILD_DEVTOOLS)/win.x86/sdk/v7.1/Bin/MsiTran.Exe
NEMU_PATH_MSIDB     ?= $(KBUILD_DEVTOOLS)/win.x86/sdk/v7.1/Bin/MsiDb.Exe
NEMU_PATH_WISUBSTG  ?= $(KBUILD_DEVTOOLS)/win.x86/sdk/v7.1/Samples/sysmgmt/msi/scripts/WiSubStg.vbs
NEMU_PATH_WISUMINFO ?= $(KBUILD_DEVTOOLS)/win.x86/sdk/v7.1/Samples/sysmgmt/msi/scripts/WiSumInf.vbs
NEMU_PATH_DIFX      ?= $(KBUILD_DEVTOOLS)/win.$(KBUILD_TARGET_ARCH)/DIFx/v2.1-r3
NEMU_PATH_CABSDK    ?= $(KBUILD_DEVTOOLS)/win.x86/cabsdk/r1
NEMU_PATH_MAKECAB   ?= $(NEMU_PATH_CABSDK)/BIN/MAKECAB.EXE

# We need to export YASM for OSE, but since it was converted to .zip we need to
# allow for the location used by the zip to be properly cleaned up first.
if1of ($(KBUILD_HOST).$(KBUILD_HOST_ARCH), linux.x86 solaris.x86 win.x86)
 PATH_TOOL_YASM ?= $(KBUILD_DEVTOOLS_HST)/bin
endif

# The Microsoft IDL compiler (the SDK build needs this on non-Windows).
NEMU_WIN_MIDL ?= $(EXEC_X86_WIN32) $(call NEMU_FN_MAKE_WIN_PATH,$(firstword $(wildcard $(addsuffix /[Mm][Ii][Dd][Ll].[Ee][Xx][Ee], \
	$(KBUILD_DEVTOOLS)/win.x86/sdk/v7.1/Bin$(if-expr "$(KBUILD_HOST).$(KBUILD_HOST_ARCH)" == "win.amd64",/x64,) \
	$(KBUILD_DEVTOOLS)/win.x86/ddk/7600.16385.1/bin/x86 \
	$(KBUILD_DEVTOOLS)/win.x86/bin \
	$(PATH_SDK_$(NEMU_WINPSDK)_BIN) \
	$(PATH_SDK_$(NEMU_WINPSDK)) \
	$(PATH_SDK_WINPSDK_BIN) \
	$(PATH_SDK_WINPSDK) \
	)) Sorry_Cannot_Find_The_Midl_Compiler_In_The_PSDK))

# XPCOM setup for all but win32.
ifneq ($(KBUILD_TARGET),win)
 NEMU_WITH_XPCOM      = 1
 # if updating, also update xpidl_INST var in src/libs/xpcom18a4/Makefile.kmk
 NEMU_XPIDL          ?= $(PATH_STAGE_BIN)/xpidl$(HOSTSUFF_EXE)
 ifeq ($(KBUILD_TARGET),os2)
  NEMU_XPIDL_ENV      = BEGINLIBPATH="$(dir $(NEMU_XPIDL));$$BEGINLIBPATH"$(SP)
 endif
 NEMU_PATH_XPCOM_IDL ?= $(NEMU_PATH_SDK)/bindings/xpcom/idl
 NEMU_XPCOM_INCS     ?=				\
 	$(NEMU_PATH_SDK)/bindings/xpcom/include	\
 	$(NEMU_PATH_SDK)/bindings/xpcom/include/xpcom	\
 	$(NEMU_PATH_SDK)/bindings/xpcom/include/string	\
 	$(NEMU_PATH_SDK)/bindings/xpcom/include/xpcom	\
 	$(NEMU_PATH_SDK)/bindings/xpcom/include/nsprpub \
 	$(NEMU_PATH_SDK)/bindings/xpcom/include/ipcd
 ifneq ($(KBUILD_TARGET),os2)
  # libIDL-config (for xpcom18a4)
  ifeq ($(origin NEMU_LIBIDL_CONFIG),undefined)
   export NEMU_LIBIDL_CONFIG := $(firstword $(shell which libIDL-config-2 libIDL-config 2> /dev/null))
  endif
 endif
endif

# The X11 LIBPATH. (The amd64 hack is for RHEL4.)
ifeq ($(KBUILD_TARGET_ARCH),amd64)
 NEMU_LIBPATH_X11 ?= /usr/X11R6/lib64 /usr/X11R6/lib
else
 NEMU_LIBPATH_X11 ?= /usr/X11R6/lib
endif

# 32bit X11 LIBPATH for building 32bit guest additions
NEMU_LIBPATH32_X11 ?= /usr/X11R6/lib32 /usr/X11R6/lib

# Good windows shell.
NEMU_GOOD_COMSPEC = $(subst \,/,$(SystemRoot))/System32/cmd.exe
NEMU_GOOD_COMSPEC_BS ?= $(subst /,\,$(NEMU_GOOD_COMSPEC))

#
# Macros dealing with the darwin version we're targeting.
# The DEF in NEMU_DEF_MACOSX_VERSION_MIN mean default.  The default min
# version is assumed to be the
#
ifeq ($(KBUILD_TARGET),darwin)
 NEMU_DEF_MACOSX_VERSION_MIN ?= 10.6

 # Check for the Xcode 4.1 bits in tools/darwin.x86.
 if   !defined(NEMU_WITH_MACOSX_COMPILERS_FROM_DEVEL) \
   && !defined(NEMU_XCODE_VERSION) \
   && exists "$(KBUILD_DEVTOOLS)/darwin.x86/xcode/v4.1"
  NEMU_WITH_MACOSX_COMPILERS_FROM_DEVEL := 1
  NEMU_PATH_MACOSX_DEVEL_ROOT := $(KBUILD_DEVTOOLS)/darwin.x86/xcode/v4.1
  NEMU_XCODE_VERSION := 4.1
 endif

 # Fallback - system / LocalConfig.kmk.
 NEMU_PATH_MACOSX_DEVEL_ROOT ?= /Developer
 NEMU_PATH_MACOSX_SDK_ROOT ?= $(NEMU_PATH_MACOSX_DEVEL_ROOT)/SDKs

 # Figure the default SDK location and obsolete linker tricks.
 ifeq ($(NEMU_DEF_MACOSX_VERSION_MIN),10.4)
  ifeq ($(origin NEMU_DARWIN_CLASSIC_LINKER),undefined)
   NEMU_DARWIN_CLASSIC_LINKER := $(shell ld -v 2>&1 )
   ifneq ($(filter ld64%, $(subst :, , $(NEMU_DARWIN_CLASSIC_LINKER))),)
    export NEMU_DARWIN_CLASSIC_LINKER := -Wl,-classic_linker
   else
    export NEMU_DARWIN_CLASSIC_LINKER :=
   endif
  endif
  NEMU_PATH_MACOSX_SDK ?= $(NEMU_PATH_MACOSX_SDK_ROOT)/MacOSX$(NEMU_DEF_MACOSX_VERSION_MIN)u.sdk
 else
  NEMU_PATH_MACOSX_SDK ?= $(NEMU_PATH_MACOSX_SDK_ROOT)/MacOSX$(NEMU_DEF_MACOSX_VERSION_MIN).sdk
 endif

 ## The Xcode version.
 ifeq ($(KBUILD_HOST),darwin)
  ifndef NEMU_XCODE_VERSION
   ifdef NEMU_WITH_MACOSX_COMPILERS_FROM_DEVEL
    NEMU_XCODE_VERSION := $(word 2, $(shell $(NEMU_PATH_MACOSX_DEVEL_ROOT)/usr/bin/xcodebuild -version))
   else
    NEMU_XCODE_VERSION := $(word 2, $(shell xcodebuild -version))
   endif
   NEMU_XCODE_VERSION ?= 4.1
  endif
  ifeq ($(NEMU_XCODE_VERSION),4.2)
   $(warning Xcode 4.2 is not able to correctly build the recompiler!)
   $(warning Please downgrade to Xcode 4.1 if you want a working VMM!)
  endif
 else
  NEMU_XCODE_VERSION ?= 4.1
 endif
 NEMU_XCODE_VERSION_MAJOR := $(word 1, $(subst ., ,$(NEMU_XCODE_VERSION)))
 NEMU_XCODE_VERSION_MINOR := $(word 2, $(subst ., ,$(NEMU_XCODE_VERSION)))
 NEMU_XCODE_VERSION       := $(NEMU_XCODE_VERSION_MAJOR).$(NEMU_XCODE_VERSION_MINOR)

 ifeq ($(KBUILD_TARGET_ARCH),x86)
  if1of ($(NEMU_DEF_MACOSX_VERSION_MIN), 10.4 10.5)
   NEMU_DARWIN_NO_COMPACT_LINKEDIT ?= $(NEMU_LD_no_compact_linkedit)
   TOOL_GXX4MACHO_SUFFIX ?= -4.0
  endif
 else
  if $(NEMU_XCODE_VERSION_MAJOR) < 4 && "$(NEMU_XCODE_VERSION)" != "3.2"
   ifeq ($(PATH_CURRENT),$(PATH_ROOT)/tools)
    $(warning Nemu: 64-bit darwin builds require Xcode 3.2 or later, you have $(NEMU_XCODE_VERSION))
   else
    $(error Nemu: 64-bit darwin builds require Xcode 3.2 or later, you have $(NEMU_XCODE_VERSION))
   endif
  endif
 endif
 if $(NEMU_XCODE_VERSION_MAJOR) == 4 && $(NEMU_XCODE_VERSION_MINOR) >= 2
  TOOL_GXX4MACHO_PREFIX ?= llvm-
 endif
 TOOL_GXX4MACHO_SUFFIX ?= -4.2
 NEMU_DARWIN_NO_COMPACT_LINKEDIT ?=

 TOOL_GCC4MACHO_SUFFIX ?= $(TOOL_GXX4MACHO_SUFFIX)$(HOSTSUFF_EXE)
 TOOL_GCC4MACHO_PREFIX ?= $(TOOL_GXX4MACHO_PREFIX)
 ifdef NEMU_WITH_MACOSX_COMPILERS_FROM_DEVEL
  TOOL_GCC4MACHO_PREFIX := $(NEMU_PATH_MACOSX_DEVEL_ROOT)/usr/bin/$(TOOL_GCC4MACHO_PREFIX)
  TOOL_GXX4MACHO_PREFIX := $(NEMU_PATH_MACOSX_DEVEL_ROOT)/usr/bin/$(TOOL_GXX4MACHO_PREFIX)
  TOOL_GCC4MACHO_SUFFIX := $(TOOL_GCC4MACHO_SUFFIX) -isysroot $(NEMU_PATH_MACOSX_SDK)
  TOOL_GXX4MACHO_SUFFIX := $(TOOL_GXX4MACHO_SUFFIX) -isysroot $(NEMU_PATH_MACOSX_SDK)
  ifndef SVN  # must expand first so we won't be using old svn.
   SVN := $(firstword $(which svn) svn)
  endif
  export PATH:=$(NEMU_PATH_MACOSX_DEVEL_ROOT)/usr/bin/:$(PATH)
  TOOL_GXX32_CC  = $(TOOL_GCC4MACHO_PREFIX)gcc$(TOOL_GCC4MACHO_SUFFIX) -m32
  TOOL_GXX32_CXX = $(TOOL_GCC4MACHO_PREFIX)g++$(TOOL_GCC4MACHO_SUFFIX) -m32
  TOOL_GXX32_LD  = $(TOOL_GXX32_CXX)
  override TOOL_StandardDTrace_DTRACE := dtrace "-xcpppath=$(TOOL_GCC4MACHO_PREFIX)cpp-4.2"
 endif
 ## @todo WTF do we do the -m32/64 stuff here for these compilers? Also the visibility should be elsewhere...
 TOOL_GXX4MACHO_OBJC   = $(TOOL_GCC4MACHO_PREFIX)gcc$(TOOL_GCC4MACHO_SUFFIX) $(if-expr $(KBUILD_TARGET_ARCH) == "x86",-m32,-m64) -fvisibility=hidden
 TOOL_GXX4MACHO_OBJCXX = $(TOOL_GCC4MACHO_PREFIX)gcc$(TOOL_GCC4MACHO_SUFFIX) $(if-expr $(KBUILD_TARGET_ARCH) == "x86",-m32,-m64) -fvisibility=hidden -fvisibility-inlines-hidden

 NEMU_DARWIN_DEF_SDK_DEFS        := MAC_OS_X_VERSION_MIN_REQUIRED=$(subst .,,$(NEMU_DEF_MACOSX_VERSION_MIN))0 \
                                    MAC_OS_X_VERSION_MAX_ALLOWED=$(subst .,,$(NEMU_DEF_MACOSX_VERSION_MIN))0
 NEMU_DARWIN_DEF_SDK_CFLAGS      := -mmacosx-version-min=$(NEMU_DEF_MACOSX_VERSION_MIN) -isysroot $(NEMU_PATH_MACOSX_SDK)
 NEMU_DARWIN_DEF_SDK_CXXFLAGS    := -mmacosx-version-min=$(NEMU_DEF_MACOSX_VERSION_MIN) -isysroot $(NEMU_PATH_MACOSX_SDK)
 NEMU_DARWIN_DEF_SDK_OBJCFLAGS   := -mmacosx-version-min=$(NEMU_DEF_MACOSX_VERSION_MIN) -isysroot $(NEMU_PATH_MACOSX_SDK)
 NEMU_DARWIN_DEF_SDK_OBJCXXFLAGS := -mmacosx-version-min=$(NEMU_DEF_MACOSX_VERSION_MIN) -isysroot $(NEMU_PATH_MACOSX_SDK)
 NEMU_DARWIN_DEF_SDK_LDFLAGS      = -mmacosx-version-min=$(NEMU_DEF_MACOSX_VERSION_MIN) -Wl,-syslibroot,$(NEMU_PATH_MACOSX_SDK) \
	-Wl,-headerpad_max_install_names $(NEMU_DARWIN_CLASSIC_LINKER) $(NEMU_DARWIN_NO_COMPACT_LINKEDIT)

 # specific versions.
 ## @todo s/NEMU_DARWIN_DEF_SDK_10/NEMU_DARWIN_SDK_10/g

 if1of ($(NEMU_DEF_MACOSX_VERSION_MIN), 10.4) # classic linker detection is bust otherwise
  NEMU_PATH_MACOSX_SDK_10_4            ?= $(NEMU_PATH_MACOSX_SDK_ROOT)/MacOSX10.4u.sdk
  NEMU_DARWIN_DEF_SDK_10_4_DEFS        := MAC_OS_X_VERSION_MIN_REQUIRED=1040 MAC_OS_X_VERSION_MAX_ALLOWED=1040
  NEMU_DARWIN_DEF_SDK_10_4_CFLAGS      := -mmacosx-version-min=10.4 -isysroot $(NEMU_PATH_MACOSX_SDK_10_4)
  NEMU_DARWIN_DEF_SDK_10_4_CXXFLAGS    := -mmacosx-version-min=10.4 -isysroot $(NEMU_PATH_MACOSX_SDK_10_4)
  NEMU_DARWIN_DEF_SDK_10_4_OBJCFLAGS   := -mmacosx-version-min=10.4 -isysroot $(NEMU_PATH_MACOSX_SDK_10_4)
  NEMU_DARWIN_DEF_SDK_10_4_OBJCXXFLAGS := -mmacosx-version-min=10.4 -isysroot $(NEMU_PATH_MACOSX_SDK_10_4)
  NEMU_DARWIN_DEF_SDK_10_4_LDFLAGS     := -mmacosx-version-min=10.4 -Wl,-syslibroot,$(NEMU_PATH_MACOSX_SDK_10_4) \
	-Wl,-headerpad_max_install_names $(NEMU_DARWIN_CLASSIC_LINKER)
 else
  NEMU_DARWIN_DEF_SDK_10_4_CXXFLAGS  = $(error Nemu: $(if $(target),$(target): ,)Using 10.4 SDK)
  NEMU_DARWIN_DEF_SDK_10_4_LDFLAGS   = $(error Nemu: $(if $(target),$(target): ,)Using 10.4 SDK)
 endif

 if1of ($(NEMU_DEF_MACOSX_VERSION_MIN), 10.4 10.5)
  NEMU_PATH_MACOSX_SDK_10_5            ?= $(NEMU_PATH_MACOSX_SDK_ROOT)/MacOSX10.5.sdk
  NEMU_DARWIN_DEF_SDK_10_5_DEFS        := MAC_OS_X_VERSION_MIN_REQUIRED=1050 MAC_OS_X_VERSION_MAX_ALLOWED=1050
  NEMU_DARWIN_DEF_SDK_10_5_CFLAGS      := -mmacosx-version-min=10.5 -isysroot $(NEMU_PATH_MACOSX_SDK_10_5)
  NEMU_DARWIN_DEF_SDK_10_5_CXXFLAGS    := -mmacosx-version-min=10.5 -isysroot $(NEMU_PATH_MACOSX_SDK_10_5)
  NEMU_DARWIN_DEF_SDK_10_5_OBJCFLAGS   := -mmacosx-version-min=10.5 -isysroot $(NEMU_PATH_MACOSX_SDK_10_5)
  NEMU_DARWIN_DEF_SDK_10_5_OBJCXXFLAGS := -mmacosx-version-min=10.5 -isysroot $(NEMU_PATH_MACOSX_SDK_10_5)
  NEMU_DARWIN_DEF_SDK_10_5_LDFLAGS     := -mmacosx-version-min=10.5 -Wl,-syslibroot,$(NEMU_PATH_MACOSX_SDK_10_5) \
	-Wl,-headerpad_max_install_names $(NEMU_DARWIN_NO_COMPACT_LINKEDIT)
 else
  NEMU_DARWIN_DEF_SDK_10_5_CXXFLAGS  = $(error Nemu: $(if $(target),$(target): ,)Using 10.5 SDK)
  NEMU_DARWIN_DEF_SDK_10_5_LDFLAGS   = $(error Nemu: $(if $(target),$(target): ,)Using 10.5 SDK)
 endif

 if1of ($(NEMU_DEF_MACOSX_VERSION_MIN), 10.4 10.5 10.6)
  NEMU_PATH_MACOSX_SDK_10_6            ?= $(NEMU_PATH_MACOSX_SDK_ROOT)/MacOSX10.6.sdk
  NEMU_DARWIN_DEF_SDK_10_6_DEFS        := MAC_OS_X_VERSION_MIN_REQUIRED=1060 MAC_OS_X_VERSION_MAX_ALLOWED=1060
  NEMU_DARWIN_DEF_SDK_10_6_CFLAGS      := -mmacosx-version-min=10.6 -isysroot $(NEMU_PATH_MACOSX_SDK_10_6)
  NEMU_DARWIN_DEF_SDK_10_6_CXXFLAGS    := -mmacosx-version-min=10.6 -isysroot $(NEMU_PATH_MACOSX_SDK_10_6)
  NEMU_DARWIN_DEF_SDK_10_6_OBJCFLAGS   := -mmacosx-version-min=10.6 -isysroot $(NEMU_PATH_MACOSX_SDK_10_6)
  NEMU_DARWIN_DEF_SDK_10_6_OBJCXXFLAGS := -mmacosx-version-min=10.6 -isysroot $(NEMU_PATH_MACOSX_SDK_10_6)
  NEMU_DARWIN_DEF_SDK_10_6_LDFLAGS     := -mmacosx-version-min=10.6 -Wl,-syslibroot,$(NEMU_PATH_MACOSX_SDK_10_6) \
         -Wl,-headerpad_max_install_names
 else
  NEMU_DARWIN_DEF_SDK_10_6_CXXFLAGS  = $(error Nemu: $(if $(target),$(target): ,)Using 10.6 SDK)
  NEMU_DARWIN_DEF_SDK_10_6_LDFLAGS   = $(error Nemu: $(if $(target),$(target): ,)Using 10.6 SDK)
 endif

 if1of ($(NEMU_DEF_MACOSX_VERSION_MIN), 10.4 10.5 10.6 10.7)
  ifndef NEMU_PATH_MACOSX_SDK_10_7
   ifneq ($(wildcard $(NEMU_PATH_MACOSX_SDK_ROOT)/MacOSX10.7.sdk),)
    NEMU_PATH_MACOSX_SDK_10_7           = $(NEMU_PATH_MACOSX_SDK_ROOT)/MacOSX10.7.sdk
   else
    NEMU_PATH_MACOSX_SDK_10_7           = $(KBUILD_DEVTOOLS)/darwin.x86/SDKs/MacOSX10.7.sdk
   endif
  endif
  NEMU_DARWIN_DEF_SDK_10_7_DEFS        := MAC_OS_X_VERSION_MIN_REQUIRED=1070 MAC_OS_X_VERSION_MAX_ALLOWED=1070
  NEMU_DARWIN_DEF_SDK_10_7_CFLAGS      := -mmacosx-version-min=10.7 -isysroot $(NEMU_PATH_MACOSX_SDK_10_7)
  NEMU_DARWIN_DEF_SDK_10_7_CXXFLAGS    := -mmacosx-version-min=10.7 -isysroot $(NEMU_PATH_MACOSX_SDK_10_7)
  NEMU_DARWIN_DEF_SDK_10_7_OBJCFLAGS   := -mmacosx-version-min=10.7 -isysroot $(NEMU_PATH_MACOSX_SDK_10_7)
  NEMU_DARWIN_DEF_SDK_10_7_OBJCXXFLAGS := -mmacosx-version-min=10.7 -isysroot $(NEMU_PATH_MACOSX_SDK_10_7)
  NEMU_DARWIN_DEF_SDK_10_7_LDFLAGS     := -mmacosx-version-min=10.7 -Wl,-syslibroot,$(NEMU_PATH_MACOSX_SDK_10_7) \
         -Wl,-headerpad_max_install_names
 else
  NEMU_DARWIN_DEF_SDK_10_7_CXXFLAGS  = $(error Nemu: $(if $(target),$(target): ,)Using 10.7 SDK)
  NEMU_DARWIN_DEF_SDK_10_7_LDFLAGS   = $(error Nemu: $(if $(target),$(target): ,)Using 10.7 SDK)
 endif


endif # target=darwin

#
# Macro switching between @executable_path, @rpath and /Applications/VirtualBox.app
# depending on whether the build is hardened or not (dylib install_name).
#
ifeq ($(KBUILD_TARGET),darwin)
 ifndef NEMU_DYLD_EXECUTABLE_PATH
  ifdef NEMU_WITH_HARDENING
   NEMU_DYLD_EXECUTABLE_PATH = $(NEMU_PATH_APP_PRIVATE_ARCH)
  else if 0
   NEMU_DYLD_EXECUTABLE_PATH = @executable_path
  else
   NEMU_DYLD_EXECUTABLE_PATH = @rpath
   NEMU_WITH_RELATIVE_RUNPATH = @loader_path/
  endif
 endif
endif

#
# Check for incompatible rpath combinations.
#
if defined(NEMU_WITH_RUNPATH) && defined(NEMU_WITH_ORIGIN)
 $(error Nemu: NEMU_WITH_RUNPATH and NEMU_WITH_ORIGIN are mutually exclusive)
endif
if defined(NEMU_WITH_RELATIVE_RUNPATH) && defined(NEMU_WITH_ORIGIN)
 $(error Nemu: NEMU_WITH_RELATIVE_RUNPATH and NEMU_WITH_ORIGIN are mutually exclusive)
endif
if defined(NEMU_WITH_RUNPATH) && defined(NEMU_WITH_RELATIVE_RUNPATH)
 $(error Nemu: NEMU_WITH_RUNPATH and NEMU_WITH_RELATIVE_RUNPATH are mutually exclusive)
endif
if defined(NEMU_WITH_RELATIVE_RUNPATH) && defined(NEMU_WITH_HARDENING)
 $(error Nemu: NEMU_WITH_RELATIVE_RUNPATH and NEMU_WITH_HARDENING are mutually exclusive)
endif

#
# NEMU_WITH_ORIGIN translates into NEMU_WITH_RELATIVE_RUNPATH.
#
# We use two helper variables for the NEMU_WITH_ORIGIN stuff:
#   NEMU_ORIGIN - Indirect expansion trick.
#   NEMU_GCC_RPATH_OPT - Different GCC/LD combinations needs different options.
#
NEMU_ORIGIN = $$ORIGIN
ifeq ($(KBUILD_TARGET),solaris)
 NEMU_GCC_RPATH_OPT  = -R
else
 NEMU_GCC_RPATH_OPT  = -Wl,-rpath,
 NEMU_GCC_ORIGIN_OPT = -Wl,-z,origin
endif
ifdef NEMU_WITH_ORIGIN
 NEMU_WITH_RELATIVE_RUNPATH = $$(NEMU_ORIGIN)
endif


#
# The X11 headers.
#
NEMU_PATH_X11_ROOT      = $(PATH_ROOT)/src/Nemu/Additions/x11/x11include
NEMU_PATH_X11_XFREE_4_3 = $(NEMU_PATH_X11_ROOT)/4.3
NEMU_PATH_X11_XORG_7_0  = $(NEMU_PATH_X11_ROOT)/7.0
NEMU_PATH_X11_XORG_7_1  = $(NEMU_PATH_X11_ROOT)/7.1


#
# crOpenGL related paths and variables.
#
ifdef NEMU_WITH_CROGL
 ifdef NEMU_WITH_WDDM
  NEMU_WITH_CRHGSMI = 1
 endif

 #if1of ($(KBUILD_TARGET),darwin)
 # NEMU_WITH_CR_DISPLAY_LISTS = 1
 #endif

 NEMU_PATH_CROGL_GLAPI       = $(PATH_ROOT)/src/Nemu/GuestHost/OpenGL/glapi_parser
 NEMU_PATH_CROGL_GENFILES    = $(PATH_OBJ)/NemuOGLgen
 NEMU_PATH_CROGL_INCLUDE     = $(PATH_ROOT)/src/Nemu/GuestHost/OpenGL/include
 NEMU_CROGL_API_FILES        = $(NEMU_PATH_CROGL_GLAPI)/apiutil.py $(NEMU_PATH_CROGL_GLAPI)/APIspec.txt
 NEMU_CROGL_PYTHON_ENV       = $(REDIRECT) $(if $1,-E 'PYTHONPATH=$1',) $(if $2,-o $2,) $(if $3,-i $3) --

 if1of ($(KBUILD_HOST), os2 win)
  NEMU_PATH_CROGL_PYTHON_INCLUDE = $(NEMU_PATH_CROGL_GLAPI);$(PATH_ROOT)/src/Nemu/GuestHost/OpenGL/packer;$(PATH_ROOT)/src/Nemu/HostServices/SharedOpenGL/crserverlib
 else
  NEMU_PATH_CROGL_PYTHON_INCLUDE = $(NEMU_PATH_CROGL_GLAPI):$(PATH_ROOT)/src/Nemu/GuestHost/OpenGL/packer:$(PATH_ROOT)/src/Nemu/HostServices/SharedOpenGL/crserverlib
 endif

 ifeq ($(KBUILD_TARGET),win)
  NEMU_LIB_OGL_CRUTIL = $(PATH_OBJ)/NemuOGLcrutil/NemuOGLcrutil$(NEMU_SUFF_LIB)
  NEMU_LIB_OGL_HOSTCRUTIL = $(PATH_OBJ)/NemuOGLhostcrutil/NemuOGLhostcrutil$(NEMU_SUFF_LIB)
  ifeq ($(KBUILD_TARGET),x86)
   NEMU_LIB_OGL_CRUTIL_X86      = $(NEMU_LIB_OGL_CRUTIL)
  else
   NEMU_LIB_OGL_CRUTIL_X86      = $(PATH_OBJ)/NemuOGLcrutil-x86/NemuOGLcrutil-x86$(NEMU_SUFF_LIB)
  endif
 else
  NEMU_LIB_OGL_CRUTIL = $(NEMU_PATH_ADDITIONS)/NemuOGLcrutil$(NEMU_SUFF_DLL)
  NEMU_LIB_OGL_HOSTCRUTIL = $(PATH_STAGE_BIN)/NemuOGLhostcrutil$(NEMU_SUFF_DLL)
 endif

 if1of ($(KBUILD_TARGET), freebsd linux solaris)
 # NEMU_PATH_MESA_SOURCE = $(PATH_ROOT)/src/libs/mesa-7.2
  NEMU_PATH_MESA_SOURCE = $(NEMU_PATH_X11_ROOT)/mesa-7.2
  NEMU_MESA_INCS = \
        $(NEMU_PATH_MESA_SOURCE) \
        $(NEMU_PATH_MESA_SOURCE)/include \
        $(NEMU_PATH_MESA_SOURCE)/src/mesa/ \
        $(NEMU_PATH_MESA_SOURCE)/src/mesa/glapi \
        $(NEMU_PATH_MESA_SOURCE)/src/mesa/main \
        $(NEMU_PATH_MESA_SOURCE)/src/mesa/drivers/dri/common
 endif

 NEMU_DARWIN_OPENGL_INST     = obj/NemuOGL/GL/
 NEMU_DARWIN_OPENGL_HEADERS  = gl.h glu.h
 SDK_DARWIN-OPENGL           = Workaround SDK for the darwin OpenGL include directorly layout layout.
 SDK_DARWIN-OPENGL_INCS      = $(PATH_OUT)/obj/NemuOGL
 SDK_DARWIN-OPENGL_ORDERDEPS = $(addprefix $(PATH_OUT)/obj/NemuOGL/GL/,$(NEMU_DARWIN_OPENGL_HEADERS))
 ## @todo kBuild: Using INTERMEDIATES doesn't work!
endif

# The icons to use.
ifdef NEMU_OSE
 NEMU_WINDOWS_ICON_FILE           ?= $(PATH_ROOT)/src/Nemu/Artwork/win/OSE/VirtualBox_win.ico
 NEMU_WINDOWS_ADDITIONS_ICON_FILE ?= $(PATH_ROOT)/src/Nemu/Artwork/win/OSE/VirtualBox_win.ico
 NEMU_NSIS_ICON_FILE              ?= $(PATH_ROOT)/src/Nemu/Artwork/win/OSE/VirtualBox_win.ico
 NEMU_MACOSX_ICON_FILE            ?= $(PATH_ROOT)/src/Nemu/Artwork/darwin/OSE/VirtualBox.icns
else
 ifeq ($(KBUILD_HOST),win)
  NEMU_WINDOWS_ICON_FILE           ?= $(PATH_ROOT)/src/Nemu/Artwork/win/NonOSE/VirtualBox-vista.ico
  NEMU_WINDOWS_ADDITIONS_ICON_FILE ?= $(PATH_ROOT)/src/Nemu/Artwork/win/NonOSE/VirtualBoxGA-vista.ico
  NEMU_NSIS_ICON_FILE              ?= $(PATH_ROOT)/src/Nemu/Artwork/win/NonOSE/VirtualBoxGA-nsis.ico
  TOOL_VCC80X86_RC                 := $(KBUILD_DEVTOOLS)/win.x86/ddk/6000/bin/x86/rc.exe
  TOOL_VCC80AMD64_RC               := $(KBUILD_DEVTOOLS)/win.x86/ddk/6000/bin/x86/rc.exe
  TOOL_VCC70_RC                    := $(KBUILD_DEVTOOLS)/win.x86/ddk/6000/bin/x86/rc.exe
 else
  NEMU_WINDOWS_ICON_FILE           ?= $(PATH_ROOT)/src/Nemu/Artwork/win/NonOSE/VirtualBox-winxp.ico
  NEMU_WINDOWS_ADDITIONS_ICON_FILE ?= $(PATH_ROOT)/src/Nemu/Artwork/win/NonOSE/VirtualBoxGA-winxp.ico
  NEMU_NSIS_ICON_FILE              ?= $(PATH_ROOT)/src/Nemu/Artwork/win/NonOSE/VirtualBox-nsis.ico
 endif
 NEMU_MACOSX_ICON_FILE             ?= $(PATH_ROOT)/src/Nemu/Artwork/darwin/NonOSE/VirtualBox.icns
endif


ifndef NEMU_NOINC_DYNAMIC_CONFIG_KMK
#
# GCC and YASM dynamic properties.
# Most of this is resolved on first kmk invocation and cached in PATH_OUT.
#
# Note! That a harmless warning is printed if the file doesn't exist.
# Note! Changes in GCC are not detected automatically (yet).
#
include $(KBUILD_PATH)/tools/$(NEMU_GCC_TOOL).kmk
ifneq ($(NEMU_GCC_TOOL),$(NEMU_GCC32_TOOL))
 include $(KBUILD_PATH)/tools/$(NEMU_GCC32_TOOL).kmk
endif

# These tests never worked on Windows because of /dev/null, so, there
# can be no harm in just dropping them until cygwin is mp safe.
ifeq ($(KBUILD_HOST),win)
 NEMU_GCC_CHECK_EX_CC  = $(3)
 NEMU_GCC_CHECK_EX_CXX = $(3)
 NEMU_GCC_CHECK_EX_LD  = $(3)
 NEMU_GCC_CHECK_CC = $(2)
 NEMU_GCC_CHECK_CXX = $(2)
 NEMU_GCC_CHECK_LD = $(2)
 NEMU_GCC32_CHECK_CXX = $(2)
else
 NEMU_GCC_CHECK_EX_CC = $(shell \
    if $(1) $(subst -Wno-,-W,$(2)) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(2)"; else echo "$(3)"; fi; )
 NEMU_GCC_CHECK_EX_CXX = $(shell \
    if $(1) $(subst -Wno-,-W,$(2)) -S -o /dev/null -xc++ /dev/null > /dev/null 2>&1; then echo "$(2)"; else echo "$(3)"; fi; )
 NEMU_GCC_CHECK_EX_LD = $(shell \
    if $(1) -Wl,$(2) $(if $(eq $(KBUILD_HOST),darwin),-Wl$(COMMA)-u$(COMMA)start -Wl$(COMMA)-undefined$(COMMA)dynamic_lookup,) \
            -nostdlib -o /dev/null -xc /dev/null > /dev/null 2>&1; \
    then echo "-Wl,$(2)"; else echo "$(3)"; fi; )

 NEMU_GCC_CHECK_CC    = $(call NEMU_GCC_CHECK_EX_CC,  $(TOOL_$(NEMU_GCC_TOOL)_CC),$1,$2)
 NEMU_GCC_CHECK_CXX   = $(call NEMU_GCC_CHECK_EX_CXX, $(TOOL_$(NEMU_GCC_TOOL)_CXX),$1,$2)
 NEMU_GCC_CHECK_LD    = $(call NEMU_GCC_CHECK_EX_LD,  $(TOOL_$(NEMU_GCC_TOOL)_LD),$1,$2)
 NEMU_GCC32_CHECK_CXX = $(call NEMU_GCC_CHECK_EX_CXX, $(TOOL_$(NEMU_GCC32_TOOL)_CXX),$1,$2)
endif

ifeq ($(KBUILD_HOST),win) ## @todo can drop this now, we're not using cygwin.
 # This isn't important (yet) on windows, so cook the result until
 # cygwin is feeling better.
 NEMU_GCC_VERSION := $(int-add $(int-mul 10000, 3), $(int-mul 100, 3), 3)
else
 # This is kind of bad, the returned string needs to be re-evaluated before use.
 # The reason for this hack is that the windows kmk_ash cannot deal with $((1+1)).
 # Some versions of gcc (e.g. openSUSE11) return only major.minor on `gcc -dumpversion`.
 NEMU_GCC_VERSION = $(shell \
    $(1) -dumpversion | $(SED_EXT) 's|\([0-9]\)\.\([0-9]\)\.\{0,1\}\([0-9]\{0,1\}\).*|$$(int-add $$(int-mul 10000, \1), $$(int-mul 100, \2), $$(firstword \3 0))|' )
endif

# Find MinGW cross compilers for EFI on non-windows systems. We need to probe
# them for supported options in the Dynamic Config.kmk section below.
ifdef NEMU_WITH_EFI
 ifneq ($(KBUILD_HOST),win)
  ifndef NEMU_PATH_PREFIX_MINGW32
   NEMU_PATH_PREFIX_MINGW32 := $(firstword \
   	$(which i686-w64-mingw32-gcc) \
   	$(which i686-w32-mingw32-gcc) \
   	$(which i686-pc-mingw32-gcc) \
   	$(which i586-mingw32msvc-gcc) \
        )# Add more variants.
   ifdef NEMU_PATH_PREFIX_MINGW32
    NEMU_PATH_PREFIX_MINGW32 := $(substr $(NEMU_PATH_PREFIX_MINGW32), 1, $(expr $(length-var NEMU_PATH_PREFIX_MINGW32) - 3))
   endif
  endif
  ifndef NEMU_PATH_PREFIX_MINGW64
   NEMU_PATH_PREFIX_MINGW64 := $(firstword \
   	$(which x86_64-w64-mingw64-gcc) \
   	$(which x86_64-w64-mingw32-gcc) \
   	$(which x86_64-pc-mingw64-gcc) \
   	$(which x86_64-pc-mingw32-gcc) \
   	$(which x86_64-w32-mingw32-gcc) \
        )# Add more variants.
   ifdef NEMU_PATH_PREFIX_MINGW64
    NEMU_PATH_PREFIX_MINGW64 := $(substr $(NEMU_PATH_PREFIX_MINGW64), 1, $(expr $(length-var NEMU_PATH_PREFIX_MINGW64) - 3))
   endif
  endif
  if defined(NEMU_PATH_PREFIX_MINGW32) || defined(NEMU_PATH_PREFIX_MINGW64)
   if !defined(NEMU_PATH_PREFIX_MINGW32)
    NEMU_PATH_PREFIX_MINGW32 = $(NEMU_PATH_PREFIX_MINGW64)
   else if !defined(NEMU_PATH_PREFIX_MINGW64)
    NEMU_PATH_PREFIX_MINGW64 = $(NEMU_PATH_PREFIX_MINGW32)
   endif
  endif
 endif # !win
endif # NEMU_WITH_EFI

# YASM macros
ifndef DONT_USE_YASM
 include $(KBUILD_PATH)/tools/YASM.kmk
 if1of ($(KBUILD_HOST), win os2)
  NEMU_YASM_CHECK = $(if-expr "$(shell $(TOOL_YASM_AS) -e -o nul $1 - < /dev/null 2>&1)" == "",$(1),)
 else
  NEMU_YASM_CHECK = $(if-expr "$(shell $(TOOL_YASM_AS) -e -o /dev/null $1 - < /dev/null 2>&1)" == "",$(1),)
 endif
else
 NEMU_YASM_CHECK =
endif

# No $(QUIET) here as it's interesting to see what goes into the file.
$(PATH_OUT)/DynamicConfig.kmk: \
		$(PATH_ROOT)/Config.kmk \
		$(LOCALCFG) \
		$(AUTOCFG) \
		$(NEMU_GCC_PATH_CC) \
		$(NEMU_GCC_PATH_CXX) \
		$(NEMU_GCC32_PATH_CC) \
		$(NEMU_GCC32_PATH_CXX) \
		$(if-expr "$(KBUILD_HOST).$(KBUILD_HOST_ARCH)" == "solaris.amd64" && $(KBUILD_HOST_VERSION_MINOR) >= 11 \
			, /platform/i86pc/kernel/$(KBUILD_HOST_ARCH)/unix,)
	$(call MSG_GENERATE,,$@,)
	$(QUIET)$(RM) -f '$@'
	$(QUIET)$(MKDIR) -p $(@D)

# HC compiler switch detection.
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_PATH_CC               ?= $(which $(TOOL_$(NEMU_GCC_TOOL)_CC))'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_PATH_CXX              ?= $(which $(TOOL_$(NEMU_GCC_TOOL)_CXX))'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_VERSION_CC            ?= $(call NEMU_GCC_VERSION,$(TOOL_$(NEMU_GCC_TOOL)_CC))'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_VERSION_CXX           ?= $(call NEMU_GCC_VERSION,$(TOOL_$(NEMU_GCC_TOOL)_CXX))'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_LIBGCC                ?= $(shell $(TOOL_$(NEMU_GCC_TOOL)_CC) -print-libgcc-file-name)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-pointer-sign      ?= $(call NEMU_GCC_CHECK_CC,-Wno-pointer-sign,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-array_bounds      ?= $(call NEMU_GCC_CHECK_CC,-Wno-array-bounds,)'
# -Wextra produces additional useful warnings but includes -Wno-missing-field-initializers (too noisy)
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wextra                ?= $(call NEMU_GCC_CHECK_CC,-Wextra,)'
	$(QUIET)$(APPEND) '$@' 'ifneq ($$(NEMU_GCC_VERSION_CC),)'
	$(QUIET)$(APPEND) '$@' ' ifneq ($$(int-ge $$(NEMU_GCC_VERSION_CC),40500),)'
	$(QUIET)$(APPEND) '$@' '  NEMU_GCC_Wlogical-op           ?= $(call NEMU_GCC_CHECK_CC,-Wlogical-op,)'
	$(QUIET)$(APPEND) '$@' ' endif'
	$(QUIET)$(APPEND) '$@' 'endif'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-address           ?= $(call NEMU_GCC_CHECK_CXX,-Wno-address,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-delete-non-virtual-dtor    ?= $(call NEMU_GCC_CHECK_CXX,-Wno-delete-non-virtual-dtor,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-int-to-pointer-cast        ?= $(call NEMU_GCC_CHECK_CC,-Wno-int-to-pointer-cast,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-invalid-offsetof           ?= $(call NEMU_GCC_CHECK_CXX,-Wno-invalid-offsetof,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-missing-field-initializers ?= $(call NEMU_GCC_CHECK_CC,-Wno-missing-field-initializers,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-pointer-to-int-cast        ?= $(call NEMU_GCC_CHECK_CC,-Wno-pointer-to-int-cast,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-variadic-macros   ?= $(call NEMU_GCC_CHECK_CXX,-Wno-variadic-macros,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-vla               ?= $(call NEMU_GCC_CHECK_CXX,-Wno-vla,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_Wno-overlength-strings?= $(call NEMU_GCC_CHECK_CC,-Wno-overlength-strings,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_fno-stack-protector   ?= $(call NEMU_GCC_CHECK_CC,-fno-stack-protector,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_fno-dwarf2-cfi-asm    ?= $(call NEMU_GCC_CHECK_CC,-fno-dwarf2-cfi-asm,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_fdiagnostics-show-option ?= $(call NEMU_GCC_CHECK_CC,-fdiagnostics-show-option,)'
# Produce code optimized for the most common IA32/AMD64/EM64T processors. Introduced with gcc version 4.2.
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_mtune-generic         ?= $(call NEMU_GCC_CHECK_CC,-mtune=generic,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_LD_as_needed              ?= $(call NEMU_GCC_CHECK_LD,--as-needed,)'
# gcc version < 3.4 has a bug in handling __attribute__((regparm(3))).
# See http://osdir.com/ml/gcc.prs/2002-08/msg00223.html and probably http://gcc.gnu.org/bugzilla/show_bug.cgi?id=20004
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_BUGGY_REGPARM         ?= $$(int-lt $$(NEMU_GCC_VERSION_CC),30400)'
# Set default attribute for ELF and MACH-O symbols to ``hidden'' to reduce the number
# of relocation entries and PLT indirections in shared libraries. Don't allow for gcc version < 4.
	$(QUIET)$(APPEND) '$@' 'ifneq ($$(NEMU_GCC_VERSION_CC),)'
	$(QUIET)$(APPEND) '$@' ' ifneq ($$(int-ge $$(NEMU_GCC_VERSION_CC),40000),)'
	$(QUIET)$(APPEND) '$@' '  NEMU_GCC_fvisibility-hidden  ?= $(call NEMU_GCC_CHECK_CC,-fvisibility=hidden -DNEMU_HAVE_VISIBILITY_HIDDEN -DRT_USE_VISIBILITY_DEFAULT,)'
	$(QUIET)$(APPEND) '$@' ' endif'
	$(QUIET)$(APPEND) '$@' 'endif'
ifn1of ($(KBUILD_TARGET),haiku)
# Set default attribute for inline functions to ``hidden'' to reduce the number
# of relocation entries and PLT indirections in shared libraries. Don't allow for gcc version < 4.
	$(QUIET)$(APPEND) '$@' 'ifneq ($$(NEMU_GCC_VERSION_CXX),)'
	$(QUIET)$(APPEND) '$@' ' ifneq ($$(int-ge $$(NEMU_GCC_VERSION_CXX),40000),)'
	$(QUIET)$(APPEND) '$@' '  NEMU_GCC_fvisibility-inlines-hidden ?= $(call NEMU_GCC_CHECK_CXX,-fvisibility-inlines-hidden,)'
	$(QUIET)$(APPEND) '$@' ' endif'
	$(QUIET)$(APPEND) '$@' 'endif'
endif
# Prevent warnings about unused parameters as of gcc-4.8 as this warning is now very verbose
	$(QUIET)$(APPEND) '$@' 'ifneq ($$(NEMU_GCC_VERSION_CXX),)'
	$(QUIET)$(APPEND) '$@' ' ifneq ($$(int-ge $$(NEMU_GCC_VERSION_CXX),40800),)'
	$(QUIET)$(APPEND) '$@' '  NEMU_GCC_Wno-unused-parameter ?= -Wno-unused-parameter'
	$(QUIET)$(APPEND) '$@' ' endif'
	$(QUIET)$(APPEND) '$@' 'endif'
# C++ Std settings
	$(QUIET)$(APPEND) '$@' 'ifneq ($$(NEMU_GCC_VERSION_CXX),)'
	$(QUIET)$(APPEND) '$@' ' ifneq ($$(int-ge $$(NEMU_GCC_VERSION_CXX),40800),)'
	$(QUIET)$(APPEND) '$@' '  NEMU_GCC_std ?= -std=c++11'
	$(QUIET)$(APPEND) '$@' ' else ifneq ($$(int-ge $$(NEMU_GCC_VERSION_CXX),40600),)'
	$(QUIET)$(APPEND) '$@' '  NEMU_GCC_std ?= -std=c++0x'
	$(QUIET)$(APPEND) '$@' ' endif'
	$(QUIET)$(APPEND) '$@' 'endif'
ifeq ($(KBUILD_TARGET),solaris)
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_msave-args            ?= $(call NEMU_GCC_CHECK_CXX,-msave-args,)'
# Detect the solaris assembler. It is used by the the 4.x gcc compilers,
# apparently. It will not be able to handle IEMAll via a -pipe, only when
# passed a file. The solaris assmbler rulez ... not!
	$(QUIET)$(APPEND) '$@' 'NEMU_AS_VERSION                ?= $(shell `gcc -print-prog-name=as` -V -o /dev/null < /dev/null 2>&1 | kmk_sed -e '1!d' -e 's/^as: *//' )'
	$(QUIET)$(APPEND) '$@' 'if $$(pos Sun Compiler Common,$$(NEMU_AS_VERSION)) > 0'
	$(QUIET)$(APPEND) '$@' ' NEMU_GCC_USING_SOLARIS_AS=1'
	$(QUIET)$(APPEND) '$@' 'endif'
	$(QUIET)$(APPEND) '$@' 'ifndef NEMU_GCC_USING_SOLARIS_AS'
	$(QUIET)$(APPEND) '$@' ' NEMU_GCC_pipe                 ?= -pipe'
	$(QUIET)$(APPEND) '$@' 'endif'
else
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC_pipe                  ?= -pipe'
endif
# Find the compiler includes for IPRT no-crt.
# Note that `$(dir $(gcc -print-libgcc-file-name))/include does not work for a 64-bit cross build on a 32-bit build host.
ifeq ($(KBUILD_HOST),win)
# With the cygwin issues and gcc on windows returning a useless path, just skip this on windows.
	$(QUIET)$(APPEND) '$@' 'NEMU_PATH_GCC_INCS             ?= '
else
	$(QUIET)$(APPEND) '$@' 'NEMU_PATH_GCC_INCS             ?= $(shell LC_ALL=C $(TOOL_$(NEMU_GCC_TOOL)_CC) -print-search-dirs|$(SED_EXT) -ne 's+^install: \(.*[^/][^/]*\)/+\1+p')/include'
endif
# 32-bit (GC) compiler switch detection.
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC32_PATH_CC             ?= $(which $(TOOL_$(NEMU_GCC32_TOOL)_CC))'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC32_PATH_CXX            ?= $(which $(TOOL_$(NEMU_GCC32_TOOL)_CXX))'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC32_VERSION_CC          ?= $(call NEMU_GCC_VERSION,$(TOOL_$(NEMU_GCC32_TOOL)_CC))'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC32_VERSION_CXX         ?= $(call NEMU_GCC_VERSION,$(TOOL_$(NEMU_GCC32_TOOL)_CXX))'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC32_LIBGCC              ?= $(shell $(TOOL_$(NEMU_GCC32_TOOL)_CC) -print-libgcc-file-name)'
	$(QUIET)$(APPEND) '$@' 'NEMU_GCC32_Wno-variadic-macros ?= $(call NEMU_GCC32_CHECK_CXX,-Wno-variadic-macros,)'
# darwin no_compact_linkedit starting at Xcode 3.2
ifeq ($(KBUILD_HOST),darwin)
	$(QUIET)$(APPEND) '$@' 'NEMU_LD_no_compact_linkedit    ?= $(call NEMU_GCC_CHECK_LD,-no_compact_linkedit,)'
endif
# YASM
	$(QUIET)$(APPEND) '$@' 'NEMU_YASM_Wno-segreg-in-64bit  ?= $(call NEMU_YASM_CHECK,-Wno-segreg-in-64bit,)'

ifdef NEMU_PATH_PREFIX_MINGW32
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW32_VERSION_CC                  ?= $(call NEMU_GCC_VERSION,$(NEMU_PATH_PREFIX_MINGW32)gcc -m32)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW32_VERSION_CXX                 ?= $(call NEMU_GCC_VERSION,$(NEMU_PATH_PREFIX_MINGW32)g++ -m32)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW32_Wno-array-bounds            ?= $(call NEMU_GCC_CHECK_EX_CXX,$(NEMU_PATH_PREFIX_MINGW32)g++ -m32,-Wno-array-bounds,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW32_Wno-unused-but-set-variable ?= $(call NEMU_GCC_CHECK_EX_CXX,$(NEMU_PATH_PREFIX_MINGW32)g++ -m32,-Wno-unused-but-set-variable,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW32_Wno-maybe-uninitialized     ?= $(call NEMU_GCC_CHECK_EX_CXX,$(NEMU_PATH_PREFIX_MINGW32)g++ -m32,-Wno-maybe-uninitialized,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW32_USER_LABEL_PREFIX           ?= $(shell echo "__USER_LABEL_PREFIX__" | $(NEMU_PATH_PREFIX_MINGW32)g++ -m32 -E -xc++ - | $(SED) -e "/^$(HASH)/d")'
endif
ifdef NEMU_PATH_PREFIX_MINGW64
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW64_VERSION_CC                  ?= $(call NEMU_GCC_VERSION,$(NEMU_PATH_PREFIX_MINGW64)gcc -m64)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW64_VERSION_CXX                 ?= $(call NEMU_GCC_VERSION,$(NEMU_PATH_PREFIX_MINGW64)g++ -m64)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW64_Wno-array-bounds            ?= $(call NEMU_GCC_CHECK_EX_CXX,$(NEMU_PATH_PREFIX_MINGW64)g++ -m64,-Wno-array-bounds,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW64_Wno-unused-but-set-variable ?= $(call NEMU_GCC_CHECK_EX_CXX,$(NEMU_PATH_PREFIX_MINGW64)g++ -m64,-Wno-unused-but-set-variable,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW64_Wno-maybe-uninitialized     ?= $(call NEMU_GCC_CHECK_EX_CXX,$(NEMU_PATH_PREFIX_MINGW64)g++ -m64,-Wno-maybe-uninitialized,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_MINGW64_USER_LABEL_PREFIX           ?= $(shell echo "__USER_LABEL_PREFIX__" | $(NEMU_PATH_PREFIX_MINGW64)g++ -m64 -E -xc++ - | $(SED) -e "/^$(HASH)/d")'
endif
	$(QUIET)$(APPEND) '$@' 'NEMU_HAVE_FLEX    ?= $(if $(which flex),1,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_HAVE_BISON   ?= $(if $(which bison),1,)'
	$(QUIET)$(APPEND) '$@' 'NEMU_HAVE_XMLLINT ?= $(which xmllint)'
if "$(KBUILD_HOST)" == "solaris" && $(KBUILD_HOST_VERSION_MAJOR) == 5 && $(KBUILD_HOST_VERSION_MINOR) == 11
# uname -v can report "snv_XYZ" or "11.X"
	$(QUIET)$(APPEND) '$@' 'NEMU_SOLARIS_11_VERSION ?= $(shell uname -v | sed "s/snv_//" | cut -f1 -d".")'
# FULLVERSION format e.g. "5.11-0.175.1.0.0.16.0", we're interested in 175 (VERSION), 1 (UPDATE), 16 (BUILD).
	$(QUIET)$(APPEND) '$@' "NEMU_SOLARIS_11_FULLVERSION := $(shell pkg contents -H -t set -o pkg.fmri system/kernel | $(SED_EXT) -e '1!d' -e 's/^.*\@//;s/\:.*//;s/.*,//')"
	$(QUIET)$(APPEND) '$@' 'ifeq ($$(NEMU_SOLARIS_11_VERSION),11)'
	$(QUIET)$(APPEND) '$@' '   NEMU_SOLARIS_11_VERSION        := $$(word 2, $$(subst ., ,$$(word 2,$$(subst -, ,$$(NEMU_SOLARIS_11_FULLVERSION)))))'
	$(QUIET)$(APPEND) '$@' 'endif'
	$(QUIET)$(APPEND) '$@' 'NEMU_SOLARIS_11_UPDATE_VERSION := $$(word 3, $$(subst ., ,$$(word 2,$$(subst -, ,$$(NEMU_SOLARIS_11_FULLVERSION)))))'
	$(QUIET)$(APPEND) '$@' 'NEMU_SOLARIS_11_BUILD_VERSION  := $$(word 6, $$(subst ., ,$$(word 2,$$(subst -, ,$$(NEMU_SOLARIS_11_FULLVERSION)))))'
endif

	$(QUIET)$(ECHO) '========= START OF $@ ========='
	$(QUIET)$(CAT) $@
	$(QUIET)$(ECHO) '=========== END OF $@ ========='

include $(PATH_OUT)/DynamicConfig.kmk
endif # !NEMU_NOINC_DYNAMIC_CONFIG_KMK

#
# Warnings as errors.
#
# GCC: We disable warnings on non-X86 systems because of the variadic
#      macro usage in the logger.
#
ifdef NEMU_WITH_WARNINGS_AS_ERRORS
 if $(NEMU_GCC_VERSION_CXX) >= 40000
  NEMU_GCC_WERR ?= -Werror
 endif
 NEMU_VCC_WERR ?= -WX
 NEMU_VCC_LD_WERR ?= ## @todo later also: -WX
endif


#
# Misc stuff that should be after including DynamicConfig.kmk.
#

# libxml XML linter.
ifeq ($(NEMU_XMLLINT),)
 ifeq ($(KBUILD_HOST),win)
  NEMU_XMLLINT := $(wildcard $(KBUILD_DEVTOOLS)/$(KBUILD_HOST).$(KBUILD_HOST_ARCH)/libxslt/10128/bin/xmllint.exe)
 endif
 ifeq ($(NEMU_XMLLINT),)
  NEMU_XMLLINT := $(NEMU_HAVE_XMLLINT)
 endif
 ifneq ($(NEMU_XMLLINT),)
  NEMU_HAVE_XMLLINT := 1
 else
  NEMU_XMLLINT := xmllint
  NEMU_HAVE_XMLLINT :=
 endif
else
 NEMU_HAVE_XMLLINT := 1
endif



#
# Misc macros.
#

##
# Edits VirtualBox version, vendor and package strings in a text file.
#
# The rule using this must list $(NEMU_SVN_REV_KMK) as a prerequisite.
#
# @param    1        The input filename.
# @param    2        The output filename.
#
NEMU_EDIT_VERSION_CMD_FN = $(SED) \
	-e 's/@NEMU_VERSION_MAJOR@/$(NEMU_VERSION_MAJOR)/g' \
	-e 's/@NEMU_VERSION_MINOR@/$(NEMU_VERSION_MINOR)/g' \
	-e 's/@NEMU_VERSION_BUILD@/$(NEMU_VERSION_BUILD)/g' \
	-e 's/@NEMU_VERSION_STRING@/$(NEMU_VERSION_STRING)/g' \
	-e 's/@NEMU_SVN_REV@/$(NEMU_SVN_REV)/g' \
	-e 's/@NEMU_VENDOR@/$(NEMU_VENDOR)/g' \
	-e 's/@NEMU_VENDOR_SHORT@/$(NEMU_VENDOR_SHORT)/g' \
	-e 's/@NEMU_PRODUCT@/$(NEMU_PRODUCT)/g' \
	-e 's/@NEMU_C_YEAR@/$(NEMU_C_YEAR)/g' \
	-e 's/@NEMU_PACKAGE_STRING@/$(NEMU_PACKAGE_STRING)/g' \
	--output $(2) $(1)

##
# Generates a rule for editing a file using NEMU_EDIT_VERSION_CMD_FN.
#
# @param    1        The target name.
# @param    2        The input filename relative to the current sub-makefile.
# @param    3        The output filename relative to the target output dir.
#                    Optional, defaults to 2.
#
NEMU_EDIT_VERSION_RULE_FN = $(eval $(value NEMU_EDIT_VERSION_RULE_DEF))
define NEMU_EDIT_VERSION_RULE_DEF
$$($(1)_0_OUTDIR)/$(if $(3),$(3),$(2)): $(PATH_SUB_CURRENT)/$(2) $(NEMU_SVN_REV_KMK) | $$(dir $$@)
	$(call MSG_GENERATE,$(1),$@,$<)
	$(QUIET)$(call NEMU_EDIT_VERSION_CMD_FN,$<,$@)
endef


##
# Fill in am import library target based on a somewhat special windows .def file.
#
# @param    1   The target name of the import library.
# @param    2   The name of the real library.
# @param    3   The .def-file paths relative to the current makefile.
#
NEMU_GENERATE_IMPORT_TARGET_FN = $(eval $(NEMU_GENERATE_IMPORT_TARGET_DEF))
define NEMU_GENERATE_IMPORT_TARGET_DEF
$(1)_TEMPLATE = NemuR3Dll
$(1)_INST     = $(INST_LIB)
if $(KBUILD_TARGET) == "darwin"
 $(1)_LDFLAGS = -install_name $(NEMU_DYLD_EXECUTABLE_PATH)/$(2)$(SUFF_DLL)
else ifn1of ($(KBUILD_TARGET), os2 win)
 $(1)_SONAME  = $(2)$(SUFF_DLL)
endif
if1of ($(KBUILD_TARGET), os2 win)
 $(1)_SOURCES = $$($(1)_0_OUTDIR)/$(1)Imp.def
 $(1)_CLEAN   = $$($(1)_0_OUTDIR)/$(1)Imp.def
else
 $(1)_SOURCES = $$($(1)_0_OUTDIR)/$(1)Imp.c
 $(1)_CLEAN   = $$($(1)_0_OUTDIR)/$(1)Imp.c
endif

$$$$($(1)_SOURCES): $(addprefix $(PATH_SUB_CURRENT)/,$(3)) $(PATH_ROOT)/src/bldprogs/deftoimp.sed | $$$$(dir $$$$@)
	$$(call MSG_GENERATE,,$$@)
ifeq ($(KBUILD_TARGET),os2)
	$$(SED) \
		-e '/not-$(KBUILD_TARGET)/d' \
		-e '/not-$(KBUILD_TARGET_ARCH)/d' \
		-e 's/^LIBRARY[[:space:]][[:space:]]*\(.*\)\.dll/LIBRARY \1 INITINSTANCE TERMINSTANCE\nDATA MULTIPLE\n/' \
		-e 's/^[ \t][ \t]*\([_a-zA-Z]\)/    _\1/' \
		-e 's/[ \t]DATA[ \t]*/ /'  \
		--output $$@ $(addprefix $(PATH_SUB_CURRENT)/,$(3))
else ifeq ($(KBUILD_TARGET),win)
	$$(SED) \
		-e '/not-$(KBUILD_TARGET)/d' \
		-e '/not-$(KBUILD_TARGET_ARCH)/d' \
		--output $$@ $(addprefix $(PATH_SUB_CURRENT)/,$(3))
else
	$$(QUIET)$$(APPEND) -tn $$@ \
		'#ifdef NEMU_HAVE_VISIBILITY_HIDDEN' \
		'# define EXPORT __attribute__((visibility("default")))' \
		'# define EXPORT_DATA __attribute__((visibility("default")))' \
		'#else' \
		'# define EXPORT' \
		'# define EXPORT_DATA' \
		'#endif' \
		''
	$$(SED) \
		-e '/not-$(KBUILD_TARGET)/d' \
		-e '/not-$(KBUILD_TARGET_ARCH)/d' \
		-f $(PATH_ROOT)/src/bldprogs/deftoimp.sed \
		--append $$@ $(addprefix $(PATH_SUB_CURRENT)/,$(3))
endif
endef # NEMU_GENERATE_IMPORT_TARGET_DEF


#
# Code Signing.
#
# There are two signing modes; 'test' and 'release'.
#  - The 'test' mode is tailored local development, where typically test
#    certificates are involved. Only the bar minimum of files are signed and
#    nothing is timestamped (if we can control timestamping) in order to reduce
#    build time and to allow working offline.
#  - The 'release' mode is tailored for creating builds that are give to other
#    people, like the ones the build servers create.  As much as possible is
#    signed and timestamped.
#
ifdef NEMU_SIGNING_MODE
 NEMU_SIGNING_MODE := $(strip $(NEMU_SIGNING_MODE))
 ifn1of ($(NEMU_SIGNING_MODE), test release)
  $(error NEMU_SIGNING_MODE must be either 'test' or 'release'. The value '$(NEMU_SIGNING_MODE)' is not recognized.)
 endif

 ifeq ($(KBUILD_HOST),win)
  #
  # Windows
  #

  # NEMU_PATH_SELFSIGN points to the Vista WDK bin/SelfSign directory.
  ifndef NEMU_PATH_SELFSIGN
   NEMU_PATH_SELFSIGN := $(lastword $(sort $(wildcard $(KBUILD_DEVTOOLS)/win.x86/selfsign/*)))
   ifeq ($(NEMU_PATH_SELFSIGN),)
    NEMU_PATH_SELFSIGN := $(KBUILD_DEVTOOLS)/win.x86/selfsign/r1
   endif
  endif
  NEMU_SIGNTOOL ?= $(KBUILD_DEVTOOLS)/bin/retry.cmd $(NEMU_PATH_SELFSIGN)/SignTool.exe
  NEMU_INF2CAT  ?= $(NEMU_PATH_SELFSIGN)/Inf2Cat.exe

  ifeq ($(NEMU_SIGNING_MODE),test)
   NEMU_CERTIFICATE_SUBJECT_NAME ?= MyTestCertificate
   NEMU_CERTIFICATE_SUBJECT_NAME_ARGS ?= /n "$(NEMU_CERTIFICATE_SUBJECT_NAME)"
  else # release
   NEMU_CERTIFICATE_SUBJECT_NAME ?= Oracle Corporation
   NEMU_CERTIFICATE_SUBJECT_NAME_ARGS ?= /n "$(NEMU_CERTIFICATE_SUBJECT_NAME)" /a
   # TEMPORARY HACK!
   if defined(NEMU_ONLY_VALIDATIONKIT)
    NEMU_CROSS_CERTIFICATE_FILE ?= $(NEMU_PATH_SELFSIGN)/MSCV-VSClass3.cer
   else
    NEMU_CROSS_CERTIFICATE_FILE ?= $(NEMU_PATH_SELFSIGN)/VeriSign Class 3 Public Primary Certification Authority - G5.cer
   endif
   NEMU_CROSS_CERTIFICATE_FILE_ARGS ?= /ac "$(NEMU_CROSS_CERTIFICATE_FILE)"
   NEMU_TSA_URL ?= http://timestamp.verisign.com/scripts/timestamp.dll
   NEMU_TSA_URL_ARGS ?= /t "$(NEMU_TSA_URL)"
  endif
  NEMU_CERTIFICATE_STORE ?= my
  NEMU_CERTIFICATE_STORE_ARGS ?= /s "$(NEMU_CERTIFICATE_STORE)"
  NEMU_CERTIFICATE_FINGERPRINT_ARGS := $(if-expr "$(NEMU_CERTIFICATE_FINGERPRINT)" != "" \
  	,/sha1 "$(subst $(SP),,$(NEMU_CERTIFICATE_FINGERPRINT))",)

  ## Commands for signing a driver image after link.
  NEMU_SIGN_DRIVER_CMDS ?= $(if $(eq $(tool_do),LINK_LIBRARY),,$(call NEMU_SIGN_IMAGE_FN,$(out)))
  ## Sign a file (generic).
  # @param 1  The file to sign.
  # @param 2  File description. Optional.
  # @param 3  Additional parameters. Optional.
  NEMU_SIGN_FILE_FN     ?= $(NEMU_SIGNTOOL) sign \
	$(NEMU_CROSS_CERTIFICATE_FILE_ARGS) \
	$(NEMU_CERTIFICATE_STORE_ARGS) \
	$(NEMU_CERTIFICATE_SUBJECT_NAME_ARGS) \
       $(NEMU_CERTIFICATE_FINGERPRINT_ARGS) \
	$(NEMU_TSA_URL_ARGS) \
	$(if $(strip $(2)),/d "$(strip $(2))",) \
	$(3) \
	$(1)
  ## Sign an executable image.
  # @param 1  The file to sign.
  # @param 2  File description. Optional.
  NEMU_SIGN_IMAGE_FN     ?= $(call NEMU_SIGN_FILE_FN,$(1),$(2),/ph)

  ## Create a security catalog file.
  # @param 1  The directory containing the stuff to sign.
  # @param 2  The expected .cat name. (Inf2Cat lowercases it)
  # @param 3  The list of OSes, separated by ';'.
  NEMU_MAKE_CAT_HLP_FN ?= \
	$(RM) -f $(2)\
	$(NL)$(TAB)$(NEMU_INF2CAT) /driver:$(strip $(1)) /os:$(strip $(subst ;,$(COMMA),$(3))) /verbose \
	$(NL)$(TAB)$(MV) $(2) $(2) \
	$(NL)$(TAB)$(call NEMU_SIGN_FILE_FN,$(2))
  NEMU_MAKE_CAT64_FN   ?= $(call NEMU_MAKE_CAT_HLP_FN,$(1),$(2),XP_X64;Server2003_X64;Vista_X64)
  NEMU_MAKE_CAT32_FN   ?= $(call NEMU_MAKE_CAT_HLP_FN,$(1),$(2),2000;XP_X86;Server2003_X86;Vista_X86)
  ifeq ($(KBUILD_TARGET_ARCH),x86)
   NEMU_MAKE_CAT_FN    ?= $(call NEMU_MAKE_CAT32_FN,$(1),$(2))
  else
   NEMU_MAKE_CAT_FN    ?= $(call NEMU_MAKE_CAT64_FN,$(1),$(2))
  endif

  # Go nuts, sign everything.
  if "$(NEMU_SIGNING_MODE)" == "release" || defined(NEMU_WITH_HARDENING)
   ## Commands for signing an executable or a dll image after link.
   NEMU_SIGN_IMAGE_CMDS  ?= $(if $(eq $(tool_do),LINK_LIBRARY),,$(call NEMU_SIGN_IMAGE_FN,$(out)))
  endif
  ## Enable signing of the additions.
  NEMU_SIGN_ADDITIONS   ?= 1

 else ifeq ($(KBUILD_HOST),darwin)
  #
  # Darwin code signing.
  #
  # Currently release signing is done when packing.  This may change later.
  # (Installer package signing is done elsewhere (NEMU_MACOSX_INSTALLER_SIGN).)
  #
  if defined(NEMU_CERTIFICATE_FINGERPRINT) && !defined(NEMU_CERTIFICATE_SUBJECT_NAME)
    NEMU_CERTIFICATE_SUBJECT_NAME = $(subst $(SP),,$(NEMU_CERTIFICATE_FINGERPRINT))
  endif
  ifeq ($(NEMU_SIGNING_MODE),test)
   NEMU_CERTIFICATE_SUBJECT_NAME ?= $(error You need to set NEMU_CERTIFICATE_SUBJECT_NAME in LocalConfig.kmk.)
   NEMU_CERTIFICATE_SUBJECT_NAME_ARGS ?= --sign "$(NEMU_CERTIFICATE_SUBJECT_NAME)"
  else
   NEMU_CERTIFICATE_SUBJECT_NAME ?= Developer ID Application: Oracle America, Inc.
   NEMU_CERTIFICATE_SUBJECT_NAME_ARGS ?= --sign "$(NEMU_CERTIFICATE_SUBJECT_NAME)"
  endif

  NEMU_CODESIGN ?= codesign
  if 0
   NEMU_DARWIN_KEXT_SIGN_FILES = CodeDirectory CodeRequirement CodeResources CodeSignature
  else
   NEMU_DARWIN_KEXT_SIGN_FILES = CodeResources
  endif

  # The above version with complicated requirements is what Xcode 5.0.1GM suggest for kexts.
  NEMU_SIGN_BUNDLE_FN = $(call MSG_TOOL,SIGNTOOL,,$(1),$(2))$(NLTAB)$(NEMU_CODESIGN) \
	--verbose=9 \
	--force \
	--file-list - \
       $(3) \
	$(NEMU_CERTIFICATE_SUBJECT_NAME_ARGS) \
	$(1) $(if $(2),--identifier "$(2)",)

  ## Sign a Mach-O image.
  # @param 1  The bundle to sign.
  # @param 2  Identifier, optional.
  NEMU_SIGN_MACHO_FN = $(call MSG_TOOL,SIGNTOOL,,$(1),$(2))$(NLTAB)$(NEMU_CODESIGN) \
	--verbose=9 \
	--force \
	--file-list - \
	$(NEMU_CERTIFICATE_SUBJECT_NAME_ARGS) \
	$(1) \
	$(if $(2),--identifier "$(2)",)

  ## Sign a VMM Mach-O image.
  # @param 1  The bundle to sign.
  # @param 2  Identifier, optional.
  ifdef NEMU_NOT_OSX_105
  NEMU_SIGN_VMM_MOD_FN = $(NEMU_SIGN_MACHO_FN)
  else
  NEMU_SIGN_VMM_MOD_FN = $(call MSG_TOOL,SIGNTOOL,,$(1),$(2))$(NLTAB)$(NEMU_CODESIGN) \
	--verbose=9 \
	--force \
	--file-list - \
	$(NEMU_CERTIFICATE_SUBJECT_NAME_ARGS) \
	$(1) -D $(1).codesign \
	$(if $(2),--identifier "$(2)",)
  endif

  ## Sign a non-executable file.
  # @param 1  The bundle to sign.
  # @param 2  Identifier, optional.
  ifdef NEMU_NOT_OSX_105
  NEMU_SIGN_FILE_FN = $(call MSG_TOOL,SIGNTOOL,,$(1),$(2))$(NLTAB)$(NEMU_CODESIGN) \
	--verbose=9 \
	--force \
	--file-list - \
	$(NEMU_CERTIFICATE_SUBJECT_NAME_ARGS) \
	$(1) \
	$(if $(2),--identifier "$(2)",)
  else
  NEMU_SIGN_FILE_FN =
  endif


  ## @def NEMU_TEST_SIGN_KEXT
  # Adds test signing to a $1.kext target (the plist installer target).
  #
  # After both targets has been defined:
  #    $(evalcall2 NEMU_TEST_SIGN_KEXT,NemuDrv)
  #
  # @param 1   The kext name.  Assumes there is a SYSMODS target of name $1
  #            as well as an .plist installer by the name of '$1.kext'.
  # @remarks   Currently assumes only binary + Info.plist in the bundle, no
  #            other files.  Should that be requirement, add them as a list
  #            in the 2nd parameter.
  # @note      This is only for the 'test' signing mode, we skip this in
  #             'release' signing mode as to not waste time on the build boxes.
  ifeq ($(NEMU_SIGNING_MODE),test) ## @todo when kBuild is updated to r2742+, this should be enabled for both modes.
   define NEMU_TEST_SIGN_KEXT
  $1_INSTTYPE.darwin = none

  $1.kext_SOURCES  += $$($1.kext_0_OUTDIR)/Contents/MacOS/$1=>MacOS/$1 \
  	$(foreach extfile, $(NEMU_DARWIN_KEXT_SIGN_FILES) \
	        , $$($1.kext_0_OUTDIR)/Contents/_CodeSignature/$(extfile)=>_CodeSignature/$(extfile))
  $1.kext_SYMLINKS += $(foreach symfile, $(NEMU_DARWIN_KEXT_SIGN_SYMLINKS), $(symfile)=>_CodeSignature/$(symfile))
  $1.kext_CLEAN    += \
  	$(foreach extfile, $(NEMU_DARWIN_KEXT_SIGN_FILES)   , $$($1.kext_0_OUTDIR)/Contents/_CodeSignature/$(extfile)) \
  	$(foreach symfile, $(NEMU_DARWIN_KEXT_SIGN_SYMLINKS), $$($1.kext_0_OUTDIR)/Contents/$(symfile)) \
	$$($1.kext_0_OUTDIR)/Contents/MacOS/$1 \
	$$($1.kext_0_OUTDIR)/$1.kext/Contents/_CodeSignature/
  $1.kext_BLDDIRS  += $$($1.kext_0_OUTDIR)/Contents/MacOS/

  $$$$($1.kext_0_OUTDIR)/Contents/MacOS/$1 \
  + $(foreach file,$(NEMU_DARWIN_KEXT_SIGN_FILES), $$$$($1.kext_0_OUTDIR)/Contents/_CodeSignature/$(file)): \
 		$$$$($1.kext_0_OUTDIR)/Contents/Info.plist $$$$($1_1_TARGET) | $$$$($1.kext_0_OUTDIR)/
	$(RM) -Rf -- "$$($1.kext_0_OUTDIR)/Contents/_CodeSignature/" "$$($1.kext_0_OUTDIR)/Contents/MacOS/"
	$(MKDIR) -p -- "$$($1.kext_0_OUTDIR)/Contents/MacOS/"
	$(INSTALL) -m 644 $$($1_1_TARGET) $$($1.kext_0_OUTDIR)/Contents/MacOS/$1
	$(call NEMU_SIGN_BUNDLE_FN,$$($1.kext_0_OUTDIR),org.virtualbox.app.kext.$1,)
   endef
  else
   NEMU_TEST_SIGN_KEXT =
  endif


 else ifeq ($(KBUILD_HOST),solaris)
  #
  # Solaris code signing.
  #

  ifeq ($(NEMU_SIGNING_MODE),test)
   NEMU_CERTIFICATE_FILE  ?= $(error You need to set NEMU_CERTIFICATE_FILE in LocalConfig.kmk.)
   NEMU_TOKEN_NAME        ?= $(error You need to set NEMU_TOKEN_NAME in LocalConfig.kmk.)
   NEMU_PIN_FILE          ?= $(error You need to set NEMU_PIN_FILE in LocalConfig.kmk.)
  else
   NEMU_CERTIFICATE_FILE  ?= $(PATH_ROOT)/oracle.pem
   NEMU_TOKEN_NAME        ?= "Sun Software PKCS\#11 softtoken"
   NEMU_PIN_FILE          ?= $(PATH_ROOT)/oracle.pin
  endif
  NEMU_CERTIFICATE_FILE_ARGS ?= -c $(NEMU_CERTIFICATE_FILE)
  NEMU_TOKEN_NAME_ARGS       ?= -T $(NEMU_TOKEN_NAME)
  NEMU_PIN_ARGS              ?= -P $(NEMU_PIN_FILE)

  NEMU_ELFSIGN ?= elfsign

  ## Commands for signing a driver image after link.
  NEMU_SIGN_DRIVER_CMDS ?= $(if $(eq $(tool_do),LINK_LIBRARY),,$(call NEMU_SIGN_ELF_FN,$(out)))
  # Sign an ELF image.
  # @param 1   The elf object file to sign.
  NEMU_SIGN_ELF_FN ?= $(NEMU_ELFSIGN) \
	sign \
	$(NEMU_CERTIFICATE_FILE_ARGS) \
	$(NEMU_TOKEN_NAME_ARGS) \
	$(NEMU_PIN_ARGS) \
	-e $(1)

 else
  # Not Windows, Mac OS X or Solaris build host, ignore.
  NEMU_SIGNING_MODE :=
 endif

#
# Complain if windows hardening is enabled but not code signing.
#
else if "$(KBUILD_TARGET)" == "win" && defined(NEMU_WITH_HARDENING) && !defined(NEMU_ONLY_BUILD)
 $(error You need to enable code signing for a hardened windows build to work.)
endif

#
# Windows .inf editing.
#
ifeq ($(KBUILD_TARGET_ARCH),x86)
 NEMU_EDIT_INF_FN = $(call NEMU_EDIT_INF32_FN,$(1),$(2))
else
 NEMU_EDIT_INF_FN = $(call NEMU_EDIT_INF64_FN,$(1),$(2))
endif
## Edit an inf file an x86 target.
# @param    1   The inf file to edit.
# @param    2   The output file.
NEMU_EDIT_INF32_FN = $(SED) $(if $(NEMU_SIGNING_MODE),-e 's/^;cat  *//', -e '/^;cat /d') \
	-e 's/^;x86  *//' \
	-e '/^;amd64 /d' \
	-e 's/^;edit-DriverVer.*/DriverVer = $(date-utc %m\/%d\/%Y),$(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)/' \
	--output $(2) \
	$(1)
## Edit an inf file an x86 target.
# @param    1   The inf file to edit.
# @param    2   The output file.
NEMU_EDIT_INF64_FN = $(SED) \
	$(if $(NEMU_SIGNING_MODE),-e 's/^;cat  *//', -e '/^;cat /d')\
	-e 's/^;amd64  *//' \
	-e '/^;x86 /d' \
	-e 's/^;edit-DriverVer.*/DriverVer = $(date-utc %m\/%d\/%Y),$(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)/' \
	--output $(2) \
	$(1)

##
# Helper macro for re-signing DLL images from tools that we ship so they won't
# cause trouble for the hardened build requirements.
#
# Invoke via $(call NEMU_RE_SIGN_DLL_FN) inside the SOURCES list.  Necessary
# _CLEAN entry will be added to the target.  If hardening is not enabled or
# we're not on windows, the source will be returned.
#
# @returns  Name of the output file name.  May have leading space, but no trailing.
# @param    1   Target name.
# @param    2   The source name.
# @param    3   Optional prefix to avoid name collisions.
#
if defined(NEMU_SIGNING_MODE) && "$(KBUILD_TARGET)" == "win"
 NEMU_RE_SIGN_DLL_FN = $(if-expr !defined($(1)_NEMU_RE_SIGNED_$(3)$(notdir $(2))),\
	$(evalcall NEMU_RE_SIGN_DLL_INTERNAL_FN,$1,$2,$3)\
	,)$($(1)_0_OUTDIR)/$(3)$(notdir $2)

define NEMU_RE_SIGN_DLL_INTERNAL_FN
local n = $(3)$(notdir $2)
ifndef $(1)_NEMU_RE_SIGNED_$(n)
 $(1)_NEMU_RE_SIGNED_$(n) := 1
 $(eval $(1)_CLEAN += $$($(1)_0_OUTDIR)/$(n))

 $$($(1)_0_OUTDIR)/$(n): $(2) $(NEMU_VERSION_STAMP) | $$(dir $$@)
	$(call MSG_TOOL,SIGNTOOL,,$<,$@)
	$(RM) -f -- "$@"
	$(CP) -- "$<" "$@"
	$(NEMU_VCC_EDITBIN) /LargeAddressAware /DynamicBase /NxCompat /Release /IntegrityCheck \
		/Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
		"$@"
	$(call NEMU_SIGN_IMAGE_FN,$@)
endif
endef # NEMU_RESIGN_DLL_FN
else
 NEMU_RE_SIGN_DLL_FN = $(2)
endif


##
# @param
NEMU_RESIGN_DLL_FN =


#
# File version info and description macros (ignored on most OSes).
#

##
# Internal macro.
#
# @param 1     The target name.
# @param 2     The description
# @param 3     Optional icon file.
# @param 4     The template base name.
# @param 5     Additional RC options.
#
# @remarks     ASSUMES RCFLAGS isn't a simple variable (var := value).
define NEMU_SET_VER_INFO_INTERNAL
ifeq ($(KBUILD_TARGET),win)
$(1)_SOURCES.win += $(PATH_ROOT)/src/Nemu/Artwork/win/$(4)
$(1)_RCFLAGS += /v /dIN_INTERNAL_NAME="\"$(1)\"" /dIN_FILE_DESCRIPTION="\"$(2)\"" \
	/dIN_ORIGINAL_NAME="\"$$(notdir $$($(1)_1_INST_TARGET))\"" \
	$(if $(3), /dIN_ICON_FILE="\"$(subst \\,/,$(strip $(3)))\"") $(5)
$$$$($(1)_0_OUTDIR)/src/Nemu/Artwork/win/$(basename $(4)).res: \
	$(PATH_ROOT)/include/Nemu/version.h $$$$(NEMU_VERSION_HEADER)
endif
endef

##
# Macro for setting DLL/SO/DYLIB version information and description.
#
# The macro must be invoked using evalcall2 after the whole target has
# been declared.
#
# @param 1     The target name.
# @param 2     The description
# @param 3     Optional icon file.
NEMU_SET_VER_INFO_DLL = $(evalcall2 NEMU_SET_VER_INFO_INTERNAL,$1,$2,$3,TemplateDll.rc,)

##
# Macro for setting EXE version information and description.
#
# The macro must be invoked using call after the whole target has been declared.
#
# @param 1     The target name.
# @param 2     The description
# @param 3     Optional icon file.
NEMU_SET_VER_INFO_EXE = $(evalcall2 NEMU_SET_VER_INFO_INTERNAL,$1,$2,$3,TemplateExe.rc,)

##
# Macro for setting driver version information and description.
#
# The macro must be invoked using call after the whole target has been declared.
#
# @param 1     The target name.
# @param 2     The description
# @param 3     Optional icon file.
# @param 4     Optional VFT2_DRV_xxx define for windows.  Uses VFT2_UNKNOWN by default.
NEMU_SET_VER_INFO_DRV = $(evalcall2 NEMU_SET_VER_INFO_INTERNAL,$1,$2,$3,TemplateDrv.rc,$(if $(4), /dIN_FILE_SUBTYPE=$(4)))

##
# Macro for setting the version information and description for a ring-0 module.
#
# The macro must be invoked using call after the whole target has been declared.
#
# @param 1     The target name.
# @param 2     The description
# @param 3     Optional icon file.
NEMU_SET_VER_INFO_R0 = $(evalcall2 NEMU_SET_VER_INFO_INTERNAL,$1,$2,$3,TemplateR0.rc,)

##
# Macro for setting the version information and description for a raw-mode context module.
#
# The macro must be invoked using call after the whole target has been declared.
#
# @param 1     The target name.
# @param 2     The description
# @param 3     Optional icon file.
NEMU_SET_VER_INFO_RC = $(evalcall2 NEMU_SET_VER_INFO_INTERNAL,$1,$2,$3,TemplateRc.rc,)



#
# Adjust kBuild defaults.
#
kBuildGlobalDefaults_DEBUG_NOSTAGE.win = true
kBuildGlobalDefaults_DEBUG_NOSTAGE.os2 = true
if1of ($(KBUILD_TARGET), darwin win)
 kBuildGlobalDefaults_LD_DEBUG = split
endif


#
# Haiku resource and version generation.
#
ifeq ($(KBUILD_HOST),haiku)
 NEMU_HAIKU_RCTOOL := rc
 NEMU_HAIKU_XRESTOOL := xres
 NEMU_HAIKU_SETVERSIONTOOL := setversion
 # XXX: install won't preserve attributes...
 NEMU_HAIKU_MIMESETTOOL := mimeset

  ## Add optional resources to the program, set its version info, and sniff its mime properties.
  # @param 1  The file to add resources to.
  # @param 2  The resource files.
  # @param 3  The target name.
define NEMU_HAIKU_XRES_SETVER_FN
	$(if $(2),$(call MSG_TOOL,HaikuAddResources,$(3),$(2))
	$(QUIET)$(NEMU_HAIKU_XRESTOOL) -o $(1) $(2),)
	$(call MSG_TOOL,HaikuSetVersion,$(3))
	$(QUIET)$(NEMU_HAIKU_SETVERSIONTOOL) $(1) \
		-app $(NEMU_VERSION_MAJOR) $(NEMU_VERSION_MINOR) $(NEMU_VERSION_BUILD) d $(NEMU_SVN_REV) \
		-short "$(NEMU_PRODUCT)" \
		-long "$(NEMU_PRODUCT) $(NEMU_VERSION_STRING) $(shell /bin/echo -e '\xC2\xA9')2009-$(NEMU_C_YEAR) $(NEMU_VENDOR)"
	$(call MSG_TOOL,HaikuMimeSet,$(3))
	$(QUIET)$(NEMU_HAIKU_MIMESETTOOL) -f $(1)
endef

 NEMU_HAIKU_XRES_SETVER_CMDS  ?= $(if $(eq $(tool_do),LINK_PROGRAM),$(call NEMU_HAIKU_XRES_SETVER_FN,$(out),$($(target)_RSRCS),$(target)),)
endif

#
# Default prefixes and suffixes.
#
NEMU_PREF_LIB =
if1of ($(KBUILD_TARGET), os2 win)
NEMU_SUFF_LIB = .lib
else
NEMU_SUFF_LIB = .a
endif
if1of ($(KBUILD_HOST), os2 win)
NEMU_HOSTSUFF_LIB = .lib
else
NEMU_HOSTSUFF_LIB = .a
endif
NEMU_SUFF_DLL = $(SUFF_DLL)
ifeq ($(KBUILD_TARGET),os2) # GXX3OMF produces out .o at the moment.
NEMU_SUFF_OBJ = .o
else
NEMU_SUFF_OBJ = $(SUFF_OBJ)
endif
NEMUW32GUEST_SUFF_LIB = .lib
NEMULNX32GUEST_SUFF_LIB = .a

#
# SDKs for external libraries.
#
SDK_NEMU_LIBXML2          = .
SDK_NEMU_LIBXML2_INCS   ?= $(PATH_ROOT)/src/libs/libxml2-2.9.2/include
SDK_NEMU_LIBXML2_DEFS  ?= _REENTRANT
SDK_NEMU_LIBXML2_DEFS.win += WIN32 _WINDOWS _MBCS
# note: no linking to LIB here, we do that explicitly in src/Nemu/Runtime/Makefile.kmk to link
# libxml against NemuRT

SDK_NEMU_LIBPNG       = .
SDK_NEMU_LIBPNG_INCS ?= $(PATH_ROOT)/src/libs/libpng-1.2.54
SDK_NEMU_LIBPNG_LIBS ?= $(PATH_STAGE_LIB)/Nemu-libpng$(NEMU_SUFF_LIB)

SDK_NEMU_ZLIB         = .
if1of ($(KBUILD_TARGET), os2 solaris win)
 SDK_NEMU_ZLIB_INCS  ?= $(PATH_ROOT)/src/libs/zlib-1.2.8
 SDK_NEMU_ZLIB_LIBS  ?= $(PATH_STAGE_LIB)/Nemu-zlib$(NEMU_SUFF_LIB)
else
 SDK_NEMU_ZLIB_INCS  ?=
 SDK_NEMU_ZLIB_LIBS  ?= z
 SDK_NEMU_ZLIB_DEFS.linux ?= _LARGEFILE64_SOURCE
endif

SDK_NEMU_ZLIB-x86    = .
SDK_NEMU_ZLIB-x86_EXTENDS = NEMU_ZLIB
if1of ($(KBUILD_TARGET), os2 solaris win)
 SDK_NEMU_ZLIB_LIBS-x86  ?= $(PATH_STAGE_LIB)/Nemu-zlib-x86$(NEMU_SUFF_LIB)
endif

SDK_NEMU_ZLIB_STATIC  = .
SDK_NEMU_ZLIB_STATIC_EXTENDS ?= NEMU_ZLIB
if1of ($(KBUILD_TARGET), os2 win) # Not required on solaris.
 SDK_NEMU_ZLIB_STATIC_LIBS ?= $(PATH_STAGE_LIB)/Nemu-zlib-static$(NEMU_SUFF_LIB)
endif

SDK_NEMU_OPENSSL      = Only for NemuRT and/or statically linked programs.
SDK_NEMU_OPENSSL_NEMU_DEFAULT_INCS := $(PATH_OUT)/obj/crypto-headers/include
SDK_NEMU_OPENSSL_INCS ?= $(SDK_NEMU_OPENSSL_NEMU_DEFAULT_INCS)
SDK_NEMU_OPENSSL_ORDERDEPS ?= $(crypto-headers_1_TARGET)
SDK_NEMU_OPENSSL_LIBS ?= \
	$(PATH_STAGE_LIB)/Nemu-libssl$(NEMU_SUFF_LIB) \
	$(PATH_STAGE_LIB)/Nemu-libcrypto$(NEMU_SUFF_LIB)

SDK_NEMU_OPENSSL-x86      = Only for NemuRT and/or statically linked programs.
SDK_NEMU_OPENSSL-x86_NEMU_DEFAULT_INCS := $(PATH_OUT)/obj/crypto-headers/include
SDK_NEMU_OPENSSL-x86_INCS ?= $(SDK_NEMU_OPENSSL_NEMU_DEFAULT_INCS)
SDK_NEMU_OPENSSL-x86_ORDERDEPS ?= $(crypto-headers_1_TARGET)
SDK_NEMU_OPENSSL-x86_LIBS ?= \
	$(PATH_STAGE_LIB)/Nemu-libssl-x86$(NEMU_SUFF_LIB) \
	$(PATH_STAGE_LIB)/Nemu-libcrypto-x86$(NEMU_SUFF_LIB)

SDK_NEMU_OPENSSL2      = What you should be using.
SDK_NEMU_OPENSSL2_EXTENDS = NEMU_OPENSSL
if "$(SDK_NEMU_OPENSSL_INCS)" == "$(SDK_NEMU_OPENSSL_NEMU_DEFAULT_INCS)"
 SDK_NEMU_OPENSSL2_LIBS = $(NO_SUCH_VARIABLE)
endif

SDK_NemuOpenSslExtPack                 = Internal use only.
SDK_NemuOpenSslExtPack_INCS            = $(SDK_NEMU_OPENSSL_NEMU_DEFAULT_INCS)
SDK_NemuOpenSslExtPack_ORDERDEPS       = $(crypto-headers_1_TARGET)
SDK_NemuOpenSslExtPack_LIBS    = \
	$(PATH_STAGE_LIB)/NemuExtPack-libssl$(NEMU_SUFF_LIB) \
	$(PATH_STAGE_LIB)/NemuExtPack-libcrypto$(NEMU_SUFF_LIB)

ifdef NEMU_WITH_S3
NEMU_WITH_LIBCURL = 1
SDK_NEMU_LIBCURL       = .
SDK_NEMU_LIBCURL_INCS ?= $(PATH_ROOT)/src/libs/curl-7.45.0/include
SDK_NEMU_LIBCURL_LIBS ?= $(PATH_STAGE_LIB)/Nemu-libcurl$(NEMU_SUFF_LIB)
SDK_NEMU_LIBCURL_DEFS ?= BUILDING_LIBCURL

SDK_NEMU_LIBCURL-x86           = .
SDK_NEMU_LIBCURL-x86_INCS     ?= $(PATH_ROOT)/src/libs/curl-7.45.0/include
SDK_NEMU_LIBCURL-x86_LIBS.x86 ?= $(PATH_STAGE_LIB)/Nemu-libcurl-x86$(NEMU_SUFF_LIB)
SDK_NEMU_LIBCURL-x86_DEFS     ?= BUILDING_LIBCURL
endif

SDK_NEMU_VPX       = .
SDK_NEMU_VPX_DEFAULT_INCS := $(PATH_ROOT)/src/libs/libvpx
SDK_NEMU_VPX_INCS ?= $(SDK_NEMU_VPX_DEFAULT_INCS)
SDK_NEMU_VPX_LIBS ?= $(PATH_STAGE_LIB)/Nemu-libvpx$(NEMU_SUFF_LIB)

#
# Special SDK for the problematic NTDLL.LIB.
#
SDK_NEMU_NTDLL = Mini NTDLL import library, required IPRT.
SDK_NEMU_NTDLL_LIBS.x86   ?= $(PATH_STAGE_LIB)/RuntimeR3NtDll-x86.lib
SDK_NEMU_NTDLL_LIBS.amd64 ?= $(PATH_STAGE_LIB)/RuntimeR3NtDll-amd64.lib

#
# The linux kernel headers(/sources).
#
if1of ($(KBUILD_TARGET), linux)
 ifeq ($(origin NEMU_LINUX_SRC),undefined)
  ifneq ($(wildcard /lib/modules/$(shell uname -r)/build/include/linux/autoconf.h  /lib/modules/$(shell uname -r)/build/include/generated/autoconf.h),)
   export NEMU_LINUX_SRC := /lib/modules/$(shell uname -r)/build
  else
   export NEMU_LINUX_SRC := /usr/src/linux
  endif
 endif
 ifneq ($(NEMU_LINUX_SRC),)
  ifeq ($(origin NEMU_LINUX_INCS),undefined)
   export NEMU_LINUX_INCS := $(NEMU_LINUX_SRC)/include
   # XXX hack alert! Support split Linux kernels (make O=<build directory>). kernelpath points to
   #                 the obj directory while NEMU_LINUX_SRC points to the virgin source directory.
   # XXX put this crap elsewhere
   kernelpath := $(shell $(SED_EXT) -ne 's+^KERNELSRC.*= *\(.*\)+\1+p' $(NEMU_LINUX_SRC)/Makefile)
   ifeq ($(kernelpath),)
    # Linux >= 2.6.25
    kernelpath := $(shell $(SED_EXT) -ne 's+^MAKEARGS *:= *-C *\(\S*\).*+\1+p' $(NEMU_LINUX_SRC)/Makefile)
   endif
   ifneq ($(kernelpath),)
    # absolute path?
    ifneq ($(patsubst /%,,$(kernelpath)),)
     # no, relative path
     kernelpath := $(realpath $(NEMU_LINUX_SRC)/$(kernelpath))
    endif
   endif
   ifneq ($(kernelpath),)
    NEMU_LINUX_INCS += $(NEMU_LINUX_SRC)/include2 $(kernelpath)/include
   else
    kernelpath := $(NEMU_LINUX_SRC)
   endif
   #
   NEMU_LINUX_INCS  += $(kernelpath)/include/asm-i386/mach-default \
                       $(kernelpath)/include/asm-x86/mach-default \
                       $(kernelpath)/include/drm \
                       $(kernelpath)/arch/x86/include \
                       $(kernelpath)/arch/x86/include/asm/mach-default \
                       $(kernelpath)/arch/x86/include/uapi \
                       $(NEMU_LINUX_SRC)/arch/x86/include/generated \
                       $(NEMU_LINUX_SRC)/arch/x86/include/generated/uapi \
                       $(kernelpath)/include/uapi \
                       $(NEMU_LINUX_SRC)/include/generated/uapi \
                       $(kernelpath)/include
  endif
 endif
 # Since Linux 2.6.15, <linux/autoconf.h> is included like this. It cannot hurt to do the
 # same for older Linux kernels
 ifneq ($(wildcard $(kernelpath)/include/linux/kconfig.h),)
  # Linux >= 3.1
  export NEMU_LINUX_INCLUDE := -include $(kernelpath)/include/linux/kconfig.h
 else ifneq ($(wildcard $(NEMU_LINUX_SRC)/include/generated/autoconf.h),)
  # Linux >= 2.6.33
  export NEMU_LINUX_INCLUDE := -include $(NEMU_LINUX_SRC)/include/generated/autoconf.h
 else ifneq ($(wildcard $(NEMU_LINUX_SRC)/include/linux/autoconf.h),)
  # Linux < 2.6.33
  export NEMU_LINUX_INCLUDE := -include $(NEMU_LINUX_SRC)/include/linux/autoconf.h
 endif
endif

#
# Determine Solaris version.
#
ifeq ($(KBUILD_TARGET),solaris)
 NEMU_SOLARIS_VERSION := $(expr $(KBUILD_HOST_VERSION_MAJOR) * 100 + $(KBUILD_HOST_VERSION_MINOR))
 ifeq ($(NEMU_SOLARIS_VERSION),510)
  DEFS.solaris += RT_OS_SOLARIS_10
  # Solaris 10 does not include crossbow.
  NEMU_SOLARIS_10 = 1
  # We cannot compile additions on Solaris 10, due kernel interface deps
  NEMU_WITHOUT_ADDITIONS := 1
  NEMU_WITH_ADDITIONS =
 else ifeq ($(NEMU_SOLARIS_VERSION),511)
  # OSS audio support for Solaris
  NEMU_WITH_SOLARIS_OSS := $(if-expr $(NEMU_SOLARIS_11_VERSION) >= 115,1,)
 endif

 # XPCOM namespace cleanup issue with Solaris GCC 4.5.2 and newer, see @bugref{5838}.
 if $(NEMU_GCC_VERSION_CXX) >= 40502
  NEMU_WITH_XPCOM_NAMESPACE_CLEANUP =
 endif
endif

#
# NemuTpG tool.
#
TOOL_NemuTpG = The VirtualBox Tracepoint Generator
TOOL_NemuTpG_DTRACE_DEPORD          = $(NEMU_NEMUTPG)
TOOL_NemuTpG_DTRACE_HDR_FLAGS      := \
		$(if-expr $(intersects $(KBUILD_TARGET_ARCH),$(KBUILD_ARCHES_64)),-64,-32) \
		-h --host-$(NEMU_HC_ARCH_BITS)-bit #-vvv
define TOOL_NemuTpG_DTRACE_HDR_CMDS
	$(QUIET)$(NEMU_NEMUTPG) $(flags) -o "$(out)" -s "$(source)"
endef
TOOL_NemuTpG_DTRACE_OBJ_NOT_NEEDED :=
TOOL_NemuTpG_DTRACE_OBJ_FLAGS      := -G --host-$(NEMU_HC_ARCH_BITS)-bit #-vvv
define TOOL_NemuTpG_DTRACE_OBJ_CMDS
	$(QUIET)$(NEMU_NEMUTPG) \
		$(if-expr $(intersects $(bld_trg_arch),$(KBUILD_ARCHES_64)),-64,-32) \
		$(flags) \
		-o "$(out)" -s "$(source)"
endef


#
# NemuTpG tool - Disabled, only generate the header.
#
TOOL_NemuTpG-Disabled = The VirtualBox Tracepoint Generator, disabled.
TOOL_NemuTpG-Disabled_DTRACE_DEPORD     = $(NEMU_NEMUTPG)
TOOL_NemuTpG-Disabled_DTRACE_HDR_FLAGS := -h
define TOOL_NemuTpG-Disabled_DTRACE_HDR_CMDS
	$(QUIET)$(NEMU_NEMUTPG) $(flags) -o "$(out)" -s "$(source)"
endef
TOOL_NemuTpG-Disabled_DTRACE_OBJ_NOT_NEEDED := $(KBUILD_OSES)


#
# dtrace+NemuTpG tool for ring-3 to ring-0 pointer conversion.
#
TOOL_DTraceAndNemuTpG = DTrace and the VirtualBox Tracepoint Generator working together on static ring-3 probes.
TOOL_DTraceAndNemuTpG_EXTENDS = StandardDTrace
TOOL_DTraceAndNemuTpG_DTRACE_DEPORD   = $(NEMU_NEMUTPG)
TOOL_DTraceAndNemuTpG_DTRACE_HDR_CMDS =
define TOOL_DTraceAndNemuTpG_DTRACE_HDR_CMDS
	$(TOOL_StandardDTrace_DTRACE_HDR_CMDS)
	$(QUIET)$(NEMU_NEMUTPG) --generate-wrapper-header --host-$(NEMU_HC_ARCH_BITS)-bit --ring-3-context \
		$(filter-out -C, $(filter-out -h,$(flags))) \
		-o "$(out).tmp" -s "$(source)"
	$(APPEND) "$(out).tmp"
	$(SED) -e 's/\(#define.*\)(arg0/\1_ORIGINAL(arg0/' --append "$(out).tmp" "$(out)"
	$(MV) -f -- "$(out).tmp" "$(out)"
endef
TOOL_DTraceAndNemuTpG_DTRACE_OBJ_NOT_NEEDED = $(TOOL_StandardDTrace_DTRACE_OBJ_NOT_NEEDED)
TOOL_DTraceAndNemuTpG_DTRACE_OBJ_CMDS = $(TOOL_StandardDTrace_DTRACE_OBJ_CMDS)


ifdef NEMU_WITH_RAW_MODE
 #
 # Template for building RC things.
 #
 TEMPLATE_NemuRc = Nemu Raw-Mode Context
 TEMPLATE_NemuRc_ASTOOL              = $(NEMU_ASTOOL)
 TEMPLATE_NemuRc_ASFLAGS             = $(NEMU_ASFLAGS32)
 TEMPLATE_NemuRc_DEFS                = IN_RC IPRT_NO_CRT RT_WITH_NOCRT_ALIASES $(ARCH_BITS_DEFS)
 TEMPLATE_NemuRc_INCS                = $(PATH_ROOT)/include/iprt/nocrt
 TEMPLATE_NemuRc_SYSSUFF             = .rc
 TEMPLATE_NemuRc_BLD_TRG_ARCH        = x86
 TEMPLATE_NemuRc_MODE                = a+r,u+w

 TEMPLATE_NemuRc_USES               += dtrace
 TEMPLATE_NemuRc_DTRACE_HDR_FLAGS    = --raw-mode-context
 TEMPLATE_NemuRc_DTRACE_OBJ_FLAGS    = --raw-mode-context --probe-fn-name "VMMRCProbeFire"
 ifdef NEMU_WITH_DTRACE_RC
  TEMPLATE_NemuRc_DTRACETOOL         = NemuTpG
  TEMPLATE_NemuRc_DEFS              += NEMU_WITH_DTRACE NEMU_WITH_DTRACE_RC
 else
  TEMPLATE_NemuRc_DTRACETOOL         = NemuTpG-Disabled
 endif

 ifeq ($(NEMU_LDR_FMT32),pe)
  TEMPLATE_NemuRc_TOOL               = $(NEMU_VCC_TOOL_STEM)X86
  TEMPLATE_NemuRc_RCDEFS             = NEMU_SVN_REV=$(NEMU_SVN_REV) NEMU_SVN_REV_MOD_5K=$(expr $(NEMU_SVN_REV) % 50000)
  ifdef TODO_MORE_WARNINGS
   TEMPLATE_NemuRc_CXXFLAGS          = -Zi -Zl -GR- -EHs- -GF -GS- -Zc:wchar_t- -Gs8192 $(NEMU_VCC_GC_OPT) $(NEMU_VCC_GC_FP) -W4 -wd4244 -wd4996 -wd4127 -wd4100 -wd4214 -wd4706 $(NEMU_VCC_WERR)
  else
   TEMPLATE_NemuRc_CXXFLAGS          = -Zi -Zl -GR- -EHs- -GF -GS- -Zc:wchar_t- -Gs8192 $(NEMU_VCC_GC_OPT) $(NEMU_VCC_GC_FP) -W3 -wd4244 -wd4996 $(NEMU_VCC_WERR)
  endif
  TEMPLATE_NemuRc_CFLAGS             = $(TEMPLATE_NemuRc_CXXFLAGS)
  TEMPLATE_NemuRc_LDFLAGS            =  -Ignore:4197 \
  	-Driver -Subsystem:NATIVE -Incremental:NO -Align:64 -MapInfo:Exports -NoD $(NEMU_VCC_LD_WERR) -Release -Debug \
  	-Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
  	-Stub:$(PATH_ROOT)/src/Nemu/HostDrivers/Support/win/winstub.com
  ifdef NEMU_SIGNING_MODE
   TEMPLATE_NemuRc_LDFLAGS          += -IntegrityCheck
  endif
  TEMPLATE_NemuRc_LIBS               = \
  	$(PATH_SDK_$(NEMU_WINDDK)_LIB.x86)/int64.lib
  TEMPLATE_NemuRc_LIBS              += \
  	$(PATH_STAGE_LIB)/RuntimeRCStub$(NEMU_SUFF_LIB)
  TEMPLATE_NemuRc_POST_CMDS          = $(NEMU_SIGN_IMAGE_CMDS)
 endif # pe

 ifeq ($(NEMU_LDR_FMT32),elf)
 TEMPLATE_NemuRc_TOOL                = $(NEMU_GCC32_TOOL)
 TEMPLATE_NemuRc_CXXFLAGS            = -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC32_Wno-variadic-macros) -fno-exceptions $(NEMU_GCC_GC_OPT) $(NEMU_GCC_GC_FP) -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -fno-strict-aliasing $(NEMU_GCC_fno-stack-protector) $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_fvisibility-inlines-hidden) -fno-rtti $(NEMU_GCC_IPRT_FMT_CHECK)
 TEMPLATE_NemuRc_CFLAGS              = -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_C)   $(NEMU_GCC32_Wno-variadic-macros) -fno-exceptions $(NEMU_GCC_GC_OPT) $(NEMU_GCC_GC_FP) -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -fno-strict-aliasing $(NEMU_GCC_fno-stack-protector) $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_IPRT_FMT_CHECK)
  ifeq ($(KBUILD_TARGET),solaris)
   TEMPLATE_NemuRc_LDFLAGS           = -r
  else
   TEMPLATE_NemuRc_LDFLAGS           = -nostdlib -Bsymbolic -g
   ## @todo WTF doesn't the globals work? Debug info is supposed to be split everywhere. GRR
   TEMPLATE_NemuRc_LD_DEBUG          = split
  endif
  ifn1of ($(KBUILD_TARGET), solaris freebsd)
   TEMPLATE_NemuRc_LIBS               = \
	$(NEMU_GCC32_LIBGCC) # instricts
  endif
  if1of ($(KBUILD_TARGET),linux)
   TEMPLATE_NemuRc_POST_CMDS         = $(if $(eq $(tool_do),LINK_SYSMOD),if readelf -S $(out)|grep -q "[cd]tors"; then echo "Found ctors/dtors in $(out)!"; exit 1; fi)
  endif
 endif

 ifeq ($(NEMU_LDR_FMT32),macho)
 TEMPLATE_NemuRc_TOOL                = GXX4MACHO
 TEMPLATE_NemuRc_DEFS               += $(NEMU_DARWIN_DEF_SDK_DEFS)
 TEMPLATE_NemuRc_CXXFLAGS            = $(NEMU_DARWIN_DEF_SDK_CXXFLAGS) -m32 -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC32_Wno-variadic-macros) -fno-common -msoft-float -static $(NEMU_GCC_fno-stack-protector) -fno-exceptions $(NEMU_GCC_GC_OPT) $(NEMU_GCC_GC_FP) -fno-strict-aliasing -fno-rtti
 TEMPLATE_NemuRc_CFLAGS              = $(NEMU_DARWIN_DEF_SDK_CFLAGS)   -m32 -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_C)   $(NEMU_GCC32_Wno-variadic-macros) -fno-common -msoft-float -static $(NEMU_GCC_fno-stack-protector) -fno-exceptions $(NEMU_GCC_GC_OPT) $(NEMU_GCC_GC_FP) -fno-strict-aliasing
 TEMPLATE_NemuRc_LDFLAGS             = $(NEMU_DARWIN_DEF_SDK_LDFLAGS)  -m32 -nostdlib
 #TEMPLATE_NemuRc_LDFLAGS.release     = -Wl,-S ???
 endif

 ifeq ($(NEMU_LDR_FMT32),lx)
 TEMPLATE_NemuRc_TOOL                = GXX3OMF
 TEMPLATE_NemuRc_CXXFLAGS            = -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC32_Wno-variadic-macros) $(NEMU_GCC_GC_OPT) $(NEMU_GCC_GC_FP) -fno-strict-aliasing -fno-exceptions -fno-rtti
 TEMPLATE_NemuRc_CFLAGS              = -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_C)   $(NEMU_GCC32_Wno-variadic-macros) $(NEMU_GCC_GC_OPT) $(NEMU_GCC_GC_FP) -fno-strict-aliasing -fno-exceptions
 TEMPLATE_NemuRc_LDFLAGS             = -Zdll -nostdlib
 TEMPLATE_NemuRc_LIBS                = \
	$(NEMU_GCC32_LIBGCC) \
	$(NEMU_OBJ_SYS0) \
	end
 endif


 #
 # Template for building a RC ring-3 testcase (tstVMStructGC, tstDevStructGC).
 #
 TEMPLATE_NemuRcExe = Nemu Raw-Mode as ring-3 testcase
 TEMPLATE_NemuRcExe_EXTENDS = NemuRc
 TEMPLATE_NemuRcExe_DEFS = $(filter-out IPRT_NO_CRT RT_WITH_NOCRT_ALIASES,$(TEMPLATE_NemuRc_DEFS))
 TEMPLATE_NemuRcExe_INCS = $(NO_SUCH_VARIABLE)
 TEMPLATE_NemuRcExe_MODE = $(NO_SUCH_VARIABLE)

 ifeq ($(NEMU_LDR_FMT32),pe)
  TEMPLATE_NemuRcExe_LDFLAGS = -Ignore:4197 \
  	-Incremental:NO -MapInfo:Exports -NoD -Debug \
  	-Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
  	-Stub:$(PATH_ROOT)/src/Nemu/HostDrivers/Support/win/winstub.com
  TEMPLATE_NemuRcExe_SDKS    = ReorderCompilerIncs $(NEMU_WINPSDK)
  TEMPLATE_NemuRcExe_LIBS    = \
  	$(PATH_TOOL_$(NEMU_VCC_TOOL_STEM)X86_LIB)/libcmt.lib \
  	$(PATH_TOOL_$(NEMU_VCC_TOOL_STEM)X86_LIB)/oldnames.lib
 endif

 ifeq ($(NEMU_LDR_FMT32),elf)
  TEMPLATE_NemuRcExe_CFLAGS   = $(filter-out -nostdinc,$(TEMPLATE_NemuRc_CFLAGS)) -O0
  TEMPLATE_NemuRcExe_CXXFLAGS = $(filter-out -nostdinc,$(TEMPLATE_NemuRc_CXXFLAGS)) -O0
  TEMPLATE_NemuRcExe_LDFLAGS  = -g
  TEMPLATE_NemuRcExe_LDFLAGS.dbgopt = -g
  TEMPLATE_NemuRcExe_LDFLAGS.strict = -g
  TEMPLATE_NemuRcExe_LDFLAGS.release = -g
  if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), freebsd.amd64)
   # The FreeBSD port of gcc isn't picking up -m32 where it should.
   TEMPLATE_NemuRcExe_DEFS.$(KBUILD_TARGET)    = $(TEMPLATE_NemuRc_DEFS.$(KBUILD_TARGET))    IPRT_DONT_USE_SYSTEM_STDINT_H
   TEMPLATE_NemuRcExe_LDFLAGS.$(KBUILD_TARGET) = /usr/lib32/crt1.o /usr/lib32/crti.o /usr/lib32/crtbegin.o $(TEMPLATE_NemuRc_LDFLAGS.$(KBUILD_TARGET)) -nostdlib -v
   TEMPLATE_NemuRcExe_LIBPATH.$(KBUILD_TARGET) = /usr/lib32
   TEMPLATE_NemuRcExe_LIBS.$(KBUILD_TARGET)    = /usr/lib32/crtend.o /usr/lib32/crtn.o /usr/lib32/libc.so
  endif
 endif

 ifeq ($(NEMU_LDR_FMT32),macho)
  TEMPLATE_NemuRcExe_CFLAGS   = $(filter-out -static -nostdinc,$(TEMPLATE_NemuRc_CFLAGS))
  TEMPLATE_NemuRcExe_CXXFLAGS = $(filter-out -static -nostdinc,$(TEMPLATE_NemuRc_CXXFLAGS))
  TEMPLATE_NemuRcExe_LDFLAGS  = -g -m32
 endif

 ifeq ($(NEMU_LDR_FMT32),lx)
  TEMPLATE_NemuRcExe_CFLAGS   = $(filter-out -nostdinc,$(TEMPLATE_NemuRc_CFLAGS))
  TEMPLATE_NemuRcExe_CXXFLAGS = $(filter-out -nostdinc,$(TEMPLATE_NemuRc_CXXFLAGS))
  TEMPLATE_NemuRcExe_LDFLAGS  = -g
  TEMPLATE_NemuRcExe_LIBS     = $(NO_SUCH_VARIABLE)
 endif
endif # NEMU_WITH_RAW_MODE


#
# Template for building R0 things.
#
TEMPLATE_NemuR0 = Nemu Ring 0
TEMPLATE_NemuR0_ASTOOL              = $(NEMU_ASTOOL)
TEMPLATE_NemuR0_ASFLAGS             = $(NEMU_ASFLAGS)
TEMPLATE_NemuR0_DEFS                = IN_RING0 IN_RING0_AGNOSTIC IPRT_NO_CRT RT_WITH_NOCRT_ALIASES $(ARCH_BITS_DEFS)
TEMPLATE_NemuR0_INCS                = $(PATH_ROOT)/include/iprt/nocrt
TEMPLATE_NemuR0_SYSSUFF             = .r0
TEMPLATE_NemuR0_MODE                = a+r,u+w

TEMPLATE_NemuR0_USES               += dtrace
TEMPLATE_NemuR0_DTRACE_HDR_FLAGS    = --ring-0-context-agnostic
TEMPLATE_NemuR0_DTRACE_OBJ_FLAGS    = --ring-0-context-agnostic
ifdef NEMU_WITH_DTRACE_R0
 TEMPLATE_NemuR0_DTRACETOOL         = NemuTpG
 TEMPLATE_NemuR0_DEFS              += NEMU_WITH_DTRACE NEMU_WITH_DTRACE_R0
else
 TEMPLATE_NemuR0_DTRACETOOL         = NemuTpG-Disabled
endif

ifeq ($(NEMU_LDR_FMT),pe)
TEMPLATE_NemuR0_TOOL                = $(NEMU_VCC_TOOL)
TEMPLATE_NemuR0_RCDEFS              = NEMU_SVN_REV=$(NEMU_SVN_REV) NEMU_SVN_REV_MOD_5K=$(expr $(NEMU_SVN_REV) % 50000)
 ifdef TODO_MORE_WARNINGS
TEMPLATE_NemuR0_CXXFLAGS            = -Zi -Zl -GR- -EHs- -GF -GS- -Zc:wchar_t- $(NEMU_VCC_OPT) $(NEMU_VCC_FP) -W4 -wd4244 -wd4127 -wd4100 -wd4214 -wd4706 -wd4996 $(NEMU_VCC_WERR)
 else
TEMPLATE_NemuR0_CXXFLAGS            = -Zi -Zl -GR- -EHs- -GF -GS- -Zc:wchar_t- $(NEMU_VCC_OPT) $(NEMU_VCC_FP) -W3 -wd4244 -wd4996 $(NEMU_VCC_WERR)
 endif
TEMPLATE_NemuR0_CFLAGS              = $(TEMPLATE_NemuR0_CXXFLAGS)
TEMPLATE_NemuR0_LDFLAGS             = -Ignore:4197 \
	-Driver -Subsystem:NATIVE -Incremental:NO -Align:4096 -MapInfo:Exports -NoD $(NEMU_VCC_LD_WERR) -Release -Debug \
	-Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-Stub:$(PATH_ROOT)/src/Nemu/HostDrivers/Support/win/winstub.com
 ifdef NEMU_WITH_DTRACE_R0
TEMPLATE_NemuR0_LDFLAGS            += -Merge:VTGPrLc.Data=VTGPrLc.Begin -Merge:VTGPrLc.End=VTGPrLc.Begin -Merge:VTGPrLc.Begin=VTGObj
 endif
 ifdef NEMU_SIGNING_MODE
  TEMPLATE_NemuR0_LDFLAGS          += -IntegrityCheck
 endif
TEMPLATE_NemuR0_LIBS                = \
	$(PATH_STAGE_LIB)/RuntimeR0Stub$(NEMU_SUFF_LIB)
 include $(KBUILD_PATH)/sdks/$(NEMU_WINDDK).kmk ## TODO: Add a kBuild feature for loading SDKs.
TEMPLATE_NemuR0_LIBS.x86            = \
	$(PATH_SDK_$(NEMU_WINDDK)_LIB.x86)/int64.lib
TEMPLATE_NemuR0_POST_CMDS           = $(NEMU_SIGN_DRIVER_CMDS)
endif # pe

ifeq ($(NEMU_LDR_FMT),elf)
TEMPLATE_NemuR0_TOOL                = $(NEMU_GCC_TOOL)
TEMPLATE_NemuR0_CFLAGS              = -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_C)   $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions $(NEMU_GCC_fno-stack-protector) -fno-common $(NEMU_GCC_fvisibility-hidden) -std=gnu99 $(NEMU_GCC_IPRT_FMT_CHECK)
TEMPLATE_NemuR0_CXXFLAGS            = -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions $(NEMU_GCC_fno-stack-protector) -fno-common $(NEMU_GCC_fvisibility-inlines-hidden) $(NEMU_GCC_fvisibility-hidden) -fno-rtti $(NEMU_GCC_IPRT_FMT_CHECK)
TEMPLATE_NemuR0_CFLAGS.amd64        = -m64 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -fno-asynchronous-unwind-tables -ffreestanding
TEMPLATE_NemuR0_CXXFLAGS.amd64      = -m64 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -fno-asynchronous-unwind-tables
ifeq ($(KBUILD_TARGET),solaris)
 TEMPLATE_NemuR0_LDFLAGS            = -r
 TEMPLATE_NemuR0_LDFLAGS.solaris    = -u _init -u _info
 TEMPLATE_NemuR0_LIBS.solaris       = \
	$(PATH_STAGE_LIB)/RuntimeR0Stub$(NEMU_SUFF_LIB)
 ifdef NEMU_GCC_USING_SOLARIS_AS
  TEMPLATE_NemuR0_CFLAGS.amd64 += -Wa,-xmodel=kernel
  TEMPLATE_NemuR0_CXXFLAGS.amd64 += -Wa,-xmodel=kernel
 endif
 # Solaris driver signing.
 TEMPLATE_NemuR0_POST_CMDS          = $(NEMU_SIGN_DRIVER_CMDS)
else
 TEMPLATE_NemuR0_LDFLAGS            = -nostdlib -Bsymbolic -g
 ## @todo WTF doesn't the globals work? Debug info is supposed to be split everywhere. GRR
 TEMPLATE_NemuR0_LD_DEBUG           = split
endif
ifn1of ($(KBUILD_TARGET),solaris freebsd)
 TEMPLATE_NemuR0_LIBS               = \
	$(NEMU_GCC_LIBGCC) # instricts
endif
if1of ($(KBUILD_TARGET),linux)
 TEMPLATE_NemuR0_POST_CMDS          =  $(if $(eq $(tool_do),LINK_SYSMOD),if readelf -S $(out)|grep -q "[cd]tors"; then echo "Found ctors/dtors in $(out)!"; exit 1; fi)
endif
endif

ifeq ($(NEMU_LDR_FMT),macho)
TEMPLATE_NemuR0_TOOL                = GXX4MACHO
TEMPLATE_NemuR0_DEFS               += $(NEMU_DARWIN_DEF_SDK_DEFS)
TEMPLATE_NemuR0_CXXFLAGS            = $(NEMU_DARWIN_DEF_SDK_CXXFLAGS) -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC_Wno-variadic-macros) \
	-fno-common -msoft-float -static -fno-rtti -fno-exceptions $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing \
	-mno-sse -mno-mmx -mno-sse2 -mno-3dnow $(NEMU_GCC_fno-stack-protector)
TEMPLATE_NemuR0_CXXFLAGS.amd64      = -m64 -mno-red-zone -mno-sse3 -mno-sse4 -mno-sse4.1 -mno-sse4.2  -mno-sse4a -fno-unwind-tables
TEMPLATE_NemuR0_CXXFLAGS.x86        = -m32
TEMPLATE_NemuR0_CFLAGS              = $(NEMU_DARWIN_DEF_SDK_CFLAGS)   -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_C)   $(NEMU_GCC_Wno-variadic-macros) \
	-fno-common -msoft-float -static -fno-exceptions $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing \
	-mno-sse -mno-mmx -mno-sse2 -mno-3dnow $(NEMU_GCC_fno-stack-protector)
TEMPLATE_NemuR0_CFLAGS.amd64        = -m64 -mno-red-zone -mno-sse3 -mno-sse4 -mno-sse4.1 -mno-sse4.2  -mno-sse4a -fno-unwind-tables
TEMPLATE_NemuR0_CFLAGS.x86          = -m32
TEMPLATE_NemuR0_LDFLAGS             = $(NEMU_DARWIN_DEF_SDK_LDFLAGS) -nostdlib
#TEMPLATE_NemuR0_LDFLAGS.release     = -Wl,-S ???
TEMPLATE_NemuR0_LDFLAGS.amd64       = -m64 -static
TEMPLATE_NemuR0_LDFLAGS.x86         = -m32
endif

ifeq ($(NEMU_LDR_FMT),lx)
TEMPLATE_NemuR0_TOOL                = GXX3OMF
TEMPLATE_NemuR0_CFLAGS              = -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_C)   $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions -fno-common
TEMPLATE_NemuR0_CXXFLAGS            = -nostdinc -g $(NEMU_GCC_pipe) $(NEMU_GCC_WERR) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions -fno-common -fno-rtti
TEMPLATE_NemuR0_LDFLAGS             = -nostdlib -Zdll
TEMPLATE_NemuR0_LIBS                = \
	$(NEMU_GCC_LIBGCC) \
	$(NEMU_OBJ_SYS0) \
	end
endif


#
# Template for building SUPDRV R0 things.
#
TEMPLATE_NEMUR0DRV                     = Nemu SUPDRV Ring 0
TEMPLATE_NEMUR0DRV_ASTOOL              = $(NEMU_ASTOOL)
TEMPLATE_NEMUR0DRV_ASFLAGS             = $(NEMU_ASFLAGS)
TEMPLATE_NEMUR0DRV_DEFS                = IN_RING0 IN_RT_R0 $(ARCH_BITS_DEFS)
TEMPLATE_NEMUR0DRV_USES               += dtrace
ifdef NEMU_WITH_DTRACE_R0DRV
 TEMPLATE_NEMUR0DRV_DTRACETOOL         = NemuTpG
 TEMPLATE_NEMUR0DRV_DEFS              += NEMU_WITH_DTRACE NEMU_WITH_DTRACE_R0DRV
 ifdef NEMU_WITH_NATIVE_DTRACE
  TEMPLATE_NEMUR0DRV_DEFS             += NEMU_WITH_NATIVE_DTRACE
 endif
else
 TEMPLATE_NEMUR0DRV_DTRACETOOL         = NemuTpG-Disabled
endif

ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NEMUR0DRV_TOOL               = $(NEMU_VCC_TOOL)
 TEMPLATE_NEMUR0DRV_RCDEFS             = NEMU_SVN_REV=$(NEMU_SVN_REV) NEMU_SVN_REV_MOD_5K=$(expr $(NEMU_SVN_REV) % 50000)
 TEMPLATE_NEMUR0DRV_DEFS.x86           = _X86_
 TEMPLATE_NEMUR0DRV_DEFS.x86          += NO_INTERLOCKED_INTRINSICS # Avoids intrisic VC/WDK trouble
 TEMPLATE_NEMUR0DRV_DEFS.x86          += WIN9X_COMPAT_SPINLOCK     # Avoid multiply defined _KeInitializeSpinLock@4
 TEMPLATE_NEMUR0DRV_DEFS.amd64         = _AMD64_
 TEMPLATE_NEMUR0DRV_CXXFLAGS           = -Zi -Zl -GR- -EHs- -GF -Gz -W3 -GS- -wd4996 -Zc:wchar_t- -Gs4096 $(NEMU_VCC_OPT) $(NEMU_VCC_FP)
 TEMPLATE_NEMUR0DRV_CFLAGS             = $(TEMPLATE_NEMUR0DRV_CXXFLAGS)
 TEMPLATE_NEMUR0DRV_LDFLAGS            = -Ignore:4197 \
 	-Driver -Subsystem:NATIVE -Incremental:NO -Align:4096 -MapInfo:Exports -NoD -Release -Debug \
	-Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-Stub:$(PATH_ROOT)/src/Nemu/HostDrivers/Support/win/winstub.com
 ifdef NEMU_WITH_DTRACE_R0DRV
  TEMPLATE_NEMUR0DRV_LDFLAGS          += -Merge:VTGPrLc.Data=VTGPrLc.Begin -Merge:VTGPrLc.End=VTGPrLc.Begin -Merge:VTGPrLc.Begin=VTGObj
 endif
 ifdef NEMU_SIGNING_MODE
  TEMPLATE_NEMUR0DRV_LDFLAGS          += -IntegrityCheck
 endif
 TEMPLATE_NEMUR0DRV_POST_CMDS          = $(NEMU_SIGN_DRIVER_CMDS)
endif

ifeq ($(KBUILD_TARGET),linux)
TEMPLATE_NEMUR0DRV_TOOL                = $(NEMU_GCC_TOOL)
TEMPLATE_NEMUR0DRV_INSTTYPE.linux      = none
TEMPLATE_NEMUR0DRV_DEFS               += __KERNEL__ MODULE
TEMPLATE_NEMUR0DRV_INCS                = $(NEMU_LINUX_INCS)
TEMPLATE_NEMUR0DRV_CFLAGS              = -nostdinc -iwithprefix include $(NEMU_LINUX_INCLUDE) \
	$(NEMU_GCC_WARN) -Wstrict-prototypes $(NEMU_GCC_Wno-pointer-sign) -Wno-sign-compare $(NEMU_GCC_fdiagnostics-show-option) \
	$(NEMU_GCC_fno-stack-protector) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) \
	-fno-strict-aliasing -fno-common -Werror-implicit-function-declaration
TEMPLATE_NEMUR0DRV_CFLAGS.x86          = -mpreferred-stack-boundary=2 -msoft-float
TEMPLATE_NEMUR0DRV_CFLAGS.amd64        = -m64 -mno-red-zone -mcmodel=kernel -mno-sse -mno-mmx -mno-sse2 -mno-3dnow \
	-fno-reorder-blocks -ffreestanding -fno-asynchronous-unwind-tables -funit-at-a-time -Wno-sign-compare
TEMPLATE_NEMUR0DRV_CXXFLAGS            = $(filter-out -Wstrict-prototypes -Wno-pointer-sign -ffreestanding -Werror-implicit-function-declaration,$(TEMPLATE_NEMUR0DRV_CFLAGS) $(TEMPLATE_NEMUR0DRV_CFLAGS.$(KBUILD_TARGET_ARCH))) -fno-exceptions -fno-rtti
  ifndef NEMU_LINUX_VERSION_2_4
# 2.6
TEMPLATE_NEMUR0DRV_SYSSUFF             = .ko
TEMPLATE_NEMUR0DRV_LDFLAGS.x86         = -m elf_i386 -r
TEMPLATE_NEMUR0DRV_LDFLAGS.amd64       = -m elf_x86_64 -r
  else
# 2.4
TEMPLATE_NEMUR0DRV_SYSSUFF             = .o
TEMPLATE_NEMUR0DRV_LDFLAGS             = -r -s
  endif
endif

ifeq ($(KBUILD_TARGET),os2)
TEMPLATE_NEMUR0DRV_TOOL                = GXX3OMF
TEMPLATE_NEMUR0DRV_CXXFLAGS            = -g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions -fno-rtti
TEMPLATE_NEMUR0DRV_CFLAGS              = -g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_C)   $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions
TEMPLATE_NEMUR0DRV_LIBS                = $(NEMU_GCC_LIBGCC)
# wlink thinks physdevice doesn't need fixups and should have a stack - stupid!
TEMPLATE_NEMUR0DRV_LDFLAGS             = -Zlinker Option -Zlinker internalrelocs, -Zlinker togglerelocs
endif

ifeq ($(KBUILD_TARGET),darwin)
TEMPLATE_NEMUR0DRV_TOOL                = GXX4MACHO
TEMPLATE_NEMUR0DRV_DEFS               += $(NEMU_DARWIN_DEF_SDK_DEFS) KERNEL KERNEL_PRIVATE DRIVER_PRIVATE APPLE NeXT
TEMPLATE_NEMUR0DRV_INCS               += $(NEMU_PATH_MACOSX_SDK)/System/Library/Frameworks/Kernel.framework/Headers
## @todo try use NEMU_GCC_PEDANTIC_CXX
TEMPLATE_NEMUR0DRV_CXXFLAGS            = $(NEMU_DARWIN_DEF_SDK_CXXFLAGS) \
	-g $(NEMU_GCC_pipe) $(NEMU_GCC_WARN) -Wno-long-long $(NEMU_GCC_fdiagnostics-show-option) \
	-fno-common -nostdinc -fno-builtin -finline $(NEMU_GCC_fvisibility-inlines-hidden) $(NEMU_GCC_fvisibility-hidden) \
	-fno-keep-inline-functions -fno-exceptions -msoft-float \
	-fapple-kext -fno-rtti -fcheck-new -force_cpusubtype_ALL \
	$(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fasm-blocks
TEMPLATE_NEMUR0DRV_CXXFLAGS.amd64      = -m64 -mkernel -mno-red-zone -gdwarf-2
TEMPLATE_NEMUR0DRV_CXXFLAGS.x86        = -m32 -static
TEMPLATE_NEMUR0DRV_CFLAGS              = $(NEMU_DARWIN_DEF_SDK_CFLAGS) \
	-g $(NEMU_GCC_pipe) $(NEMU_GCC_WARN) -Wno-long-long -fno-common -nostdinc -fno-builtin -finline \
	-fno-keep-inline-functions -fno-exceptions $(NEMU_GCC_fvisibility-hidden) -msoft-float \
	-Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations \
	-Werror-implicit-function-declaration -force_cpusubtype_ALL \
	$(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fasm-blocks
TEMPLATE_NEMUR0DRV_CFLAGS.amd64        = -m64 -mkernel -mno-red-zone -gdwarf-2
TEMPLATE_NEMUR0DRV_CFLAGS.x86          = -m32 -static
TEMPLATE_NEMUR0DRV_LDFLAGS             =  $(filter-out $(NEMU_DARWIN_NO_COMPACT_LINKEDIT),$(NEMU_DARWIN_DEF_SDK_LDFLAGS)) \
	-nostdlib -Wl,-kext,-new_linker -Wl,-Y,1455 -keep_private_extern
TEMPLATE_NEMUR0DRV_LDFLAGS.amd64       = -m64
TEMPLATE_NEMUR0DRV_LDFLAGS.x86         = -m32
TEMPLATE_NEMUR0DRV_LIBS                = kmodc++ kmod cc_kext cpp_kext $(NEMU_GCC_LIBGCC)
endif

ifeq ($(KBUILD_TARGET),solaris)
## The Solaris /usr/platform/i86pc/include and /usr/include directories.
NEMU_SOLARIS_SYS_INCS ?= /usr/platform/i86pc/include /usr/include

TEMPLATE_NEMUR0DRV_TOOL                = $(NEMU_GCC_TOOL)
TEMPLATE_NEMUR0DRV_DEFS               += _MACHDEP _KERNEL _STRICT_STDC
TEMPLATE_NEMUR0DRV_INCS                = $(NEMU_SOLARIS_SYS_INCS)
TEMPLATE_NEMUR0DRV_LDFLAGS             = -r -dy
TEMPLATE_NEMUR0DRV_LDFLAGS.amd64       = $(if $(eq $(KBUILD_HOST),solaris),-64,-m elf_x86_64)
# Exclude -Wall because of solaris headers' pragma ident warnings that gcc refuses to supress.
TEMPLATE_NEMUR0DRV_CFLAGS              = -Wpointer-arith -Winline $(NEMU_GCC_Wno-pointer-sign) \
	-Wmissing-prototypes -Wstrict-prototypes $(NEMU_GCC_fdiagnostics-show-option) \
	-Wshadow -Wuninitialized -Wunused-function -Wunused-label -Wunused-value -Wunused-variable \
	-Wformat  -Wimplicit-int -Wimplicit-function-declaration -Werror-implicit-function-declaration -Wparentheses \
	-O2 -fno-omit-frame-pointer -ffreestanding -nodefaultlibs -fno-strict-aliasing -fno-common -std=c99
TEMPLATE_NEMUR0DRV_CFLAGS.x86          = -m32 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow
TEMPLATE_NEMUR0DRV_CFLAGS.amd64        = -m64 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow $(NEMU_GCC_msave-args) \
	-mno-red-zone -mcmodel=kernel $(if-expr defined(NEMU_GCC_USING_SOLARIS_AS),-Wa$(COMMA)-xmodel=kernel,) \
	-fno-reorder-blocks -fno-asynchronous-unwind-tables -funit-at-a-time
TEMPLATE_NEMUR0DRV_CXXFLAGS           = -Wpointer-arith -Winline \
	-Wshadow -Wuninitialized -Wunused-function -Wunused-label -Wunused-value -Wunused-variable \
	-Wformat \
	-O2 -nodefaultlibs -fno-omit-frame-pointer -fno-strict-aliasing -fno-common -fno-exceptions -fno-rtti
TEMPLATE_NEMUR0DRV_CXXFLAGS.x86       = $(TEMPLATE_NEMUR0DRV_CFLAGS.x86)
TEMPLATE_NEMUR0DRV_CXXFLAGS.amd64     = $(TEMPLATE_NEMUR0DRV_CFLAGS.amd64)
TEMPLATE_NEMUR0DRV_POST_CMDS          = $(NEMU_SIGN_DRIVER_CMDS)
endif # Solaris

ifeq ($(KBUILD_TARGET),freebsd)
# x86 FreeBSD (6.2 or something):
#  cc -O2 -fno-strict-aliasing -pipe -Werror -D_KERNEL -DKLD_MODULE \
#   -nostdinc -I- -I. -I@ -I@/contrib/altq -I@/../include -I/usr/include \
#   -finline-limit=8000 -fno-common -mno-align-long-strings -mpreferred-stack-boundary=2 \
#   -mno-mmx -mno-3dnow -mno-sse -mno-sse2 -ffreestanding -Wall -Wredundant-decls -Wnested-externs \
#   -Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual -fformat-extensions \
#   -std=c99 -c ../my.c
#  ld -d -warn-common -r -d -o my.kld my.o
#  :> export_syms
#  awk -f /usr/src/sys/modules/my/../../conf/kmod_syms.awk my.kld export_syms | xargs -J% objcopy % my.kld
#  ld -Bsharable -d warn-commnon -o my.ko my.kld
#
# AMD64 FreeBSD (7.1):
#  cc -O2 -fno-strict-aliasing -pipe -D_KERNEL -DKLD_MODULE -std=c99 -nostdinc -I. -I@ -I@/contrib/altq \
#  -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  \
#  -fno-omit-frame-pointer -mcmodel=kernel -mno-red-zone -mfpmath=387 -mno-sse -mno-sse2 -mno-mmx \
#  -mno-3dnow -msoft-float -fno-asynchronous-unwind-tables -ffreestanding \
#  -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual -Wundef -Wno-pointer-sign \
#  -fformat-extensions -c /usr/src/sys/modules/my/../../dev/my/if_my.c
#  ld  -d -warn-common -r -d -o if_my.ko if_my.o
#  :> export_syms
#  awk -f /usr/src/sys/modules/my/../../conf/kmod_syms.awk if_my.ko  export_syms | xargs -J% objcopy % if_my.ko

# Note: @ -> /usr/src/sys  and  machine -> /usr/src/sys/i386/include

## The location of the FreeBSD kernel source.
NEMU_FREEBSD_SRC ?= /usr/src/sys
## The FreeBSD /usr/include.
NEMU_FREEBSD_SYS_INCS ?= /usr/include

TEMPLATE_NEMUR0DRV_TOOL                = $(NEMU_GCC_TOOL)
TEMPLATE_NEMUR0DRV_LDTOOL              = FREEBSDKMODLD
TEMPLATE_NEMUR0DRV_DEFS               += _KERNEL KLD_MODULE
TEMPLATE_NEMUR0DRV_INCS                = \
	$(NEMU_FREEBSD_SRC) \
	$(NEMU_FREEBSD_SRC)/contrib/altq \
	$(NEMU_FREEBSD_SRC)/../include \
	$(NEMU_FREEBSD_SYS_INCS)
# omitting: -Wcast-qual, -Wredundant-decls
TEMPLATE_NEMUR0DRV_CFLAGS              =  \
	$(NEMU_GCC_WARN) -Wpointer-arith -Winline $(NEMU_GCC_Wno-pointer-sign) $(NEMU_GCC_fdiagnostics-show-option) \
	-Wstrict-prototypes -Wmissing-prototypes -Wstrict-prototypes \
	-Wimplicit-function-declaration -Werror-implicit-function-declaration \
	-O2 -ffreestanding -fno-strict-aliasing -fno-common -finline-limit=8000 \
	$(NEMU_GCC_fno-stack-protector) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) \
	-nostdinc -std=c99
TEMPLATE_NEMUR0DRV_CFLAGS.x86          = -m32 -mno-align-long-strings -mpreferred-stack-boundary=2 -mno-mmx -mno-3dnow -mno-sse -mno-sse2
TEMPLATE_NEMUR0DRV_CFLAGS.amd64        = -m64 --param inline-unit-growth=100 --param large-function-growth=1000 \
	-fno-omit-frame-pointer -mcmodel=kernel -mno-red-zone -mfpmath=387 -mno-sse -mno-sse2 -mno-mmx \
	-mno-3dnow -msoft-float -fno-asynchronous-unwind-tables -Wundef
TEMPLATE_NEMUR0DRV_CXXFLAGS            = -fno-exceptions -fno-rtti \
	$(NEMU_GCC_WARN) -Wpointer-arith -Winline \
	-O2 -fno-strict-aliasing -fno-common -finline-limit=8000 \
	$(NEMU_GCC_fno-stack-protector) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) \
	-nostdinc
TEMPLATE_NEMUR0DRV_CXXFLAGS.x86        = $(TEMPLATE_NEMUR0DRV_CFLAGS.x86)
TEMPLATE_NEMUR0DRV_CXXFLAGS.amd64      = $(TEMPLATE_NEMUR0DRV_CFLAGS.amd64)
TEMPLATE_NEMUR0DRV_SYSSUFF             = .ko
TEMPLATE_NEMUR0DRV_LDFLAGS             = -d --warn-common
TEMPLATE_NEMUR0DRV_LDFLAGS.x86         = -m elf_i386_fbsd
TEMPLATE_NEMUR0DRV_LDFLAGS.amd64       = -m elf_x86_64_fbsd

TOOL_FREEBSDKMODLD = FreeBSD kernel module linker.
# See kBuild/tools/GCC3.kmk for docs.
TOOL_FREEBSDKMODLD_LINK_SYSMOD_OUTPUT_MAYBE = $(outbase).map
TOOL_FREEBSDKMODLD_LINK_SYSMOD_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))
TOOL_FREEBSDKMODLD_LINK_SYSMOD_DEPORD =
 ifeq ($(KBUILD_TARGET_ARCH),amd64)
TOOL_FREEBSDKMODLD_LINK_SYSMOD_OUTPUT =
define TOOL_FREEBSDKMODLD_LINK_SYSMOD_CMDS
# Link intermediate .kld (a relocatable object).
	ld $(flags) -r -o  $(out) $(objs) \
		$(foreach p,$(libpath), -L$(p))\
		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(basename $(lib))), $(lib)))
# Strip non-exported symbols private and localize the exported ones.
	awk -f $(NEMU_FREEBSD_SRC)/conf/kmod_syms.awk  $(out) $(if $(othersrc), $(othersrc),/dev/null) \
		| xargs -J% objcopy % $(out)

## Strip debug info (comment out if debugging or something).
	objcopy --strip-debug $(out)
endef
 else # x86
TOOL_FREEBSDKMODLD_LINK_SYSMOD_OUTPUT = $(outbase).kld
define TOOL_FREEBSDKMODLD_LINK_SYSMOD_CMDS
# Link intermediate .kld (a relocatable object).
	ld $(flags) -r -o $(outbase).kld $(objs) \
		$(foreach p,$(libpath), -L$(p))\
		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(basename $(lib))), $(lib)))
# Strip non-exported symbols private and localize the exported ones.
	awk -f $(NEMU_FREEBSD_SRC)/conf/kmod_syms.awk $(outbase).kld $(if $(othersrc), $(othersrc),/dev/null) \
		| xargs -J% objcopy % $(outbase).kld

# Link the final .ko (a shared object).
	ld $(flags) -Bshareable -o $(out) $(outbase).kld
endef
 endif # x86

endif # FreeBSD

ifeq ($(KBUILD_TARGET),haiku)
## The Haiku include directories
NEMU_HAIKU_SYS_INCS ?= /boot/develop/headers/os/kernel /boot/develop/headers/os/drivers

TEMPLATE_NEMUR0DRV_TOOL                = $(NEMU_GCC_TOOL)
TEMPLATE_NEMUR0DRV_LDTOOL              = $(NEMU_GCC_TOOL)
TEMPLATE_NEMUR0DRV_DEFS                = _KERNEL_MODE=1 _STRICT_STDC IN_RING0 IN_RT_R0
TEMPLATE_NEMUR0DRV_INCS                = $(NEMU_HAIKU_SYS_INCS)
#TODO: sort this out
TEMPLATE_NEMUR0DRV_LDFLAGS             = -shared -no-undefined -dc -dy -lroot -rpath-link /boot/system/develop/lib/x86 --no-add-needed /boot/system/develop/lib/_KERNEL_ --no-add-needed /boot/system/develop/lib/haiku_version_glue.o
TEMPLATE_NEMUR0DRV_CFLAGS              = -fno-PIC \
	$(NEMU_GCC_WARN) -Wstrict-prototypes $(NEMU_GCC_Wno-pointer-sign) -Wno-sign-compare \
	$(NEMU_GCC_fno-stack-protector) $(NEMU_GCC_R0_OPT) $(NEMU_GCC_R0_FP) -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration
TEMPLATE_NEMUR0DRV_CFLAGS.x86          = -mno-sse -mno-mmx -mno-sse2 -mno-3dnow
TEMPLATE_NEMUR0DRV_CFLAGS.x86          = -m32 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow
TEMPLATE_NEMUR0DRV_CFLAGS.amd64        = -m64 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow \
	-fno-reorder-blocks -ffreestanding -fno-asynchronous-unwind-tables -funit-at-a-time \
	-Wno-sign-compare
TEMPLATE_NEMUR0DRV_CXXFLAGS           = -fno-PIC -Wpointer-arith \
	-Wshadow -Wuninitialized -Wunused-function -Wunused-label -Wunused-value -Wunused-variable \
	-Wformat \
	-O2 -nodefaultlibs -fno-omit-frame-pointer -fno-strict-aliasing -fno-common -fno-exceptions -fno-rtti
TEMPLATE_NEMUR0DRV_CXXFLAGS.x86       = $(TEMPLATE_NEMUR0DRV_CFLAGS.x86) -fno-exceptions -fno-rtti
TEMPLATE_NEMUR0DRV_CXXFLAGS.amd64     = $(TEMPLATE_NEMUR0DRV_CFLAGS.amd64) -fno-exceptions -fno-rtti
endif # Haiku

ifdef NEMU_WITH_NEMUDRV
 ifndef TEMPLATE_NEMUR0DRV_TOOL
  $(warning Warning: Nemu Build: Target $(KBUILD_HOST) is not officially supported!)
 endif
endif

ifn1of ($(KBUILD_TARGET), darwin os2 win solaris)
 # This doesn't work if supdrv is natively loading NemuVMMR0.r0 et al, but
 # fortunately it isn't really necessary.
 TEMPLATE_NEMUR0DRV_CFLAGS    += -include $(PATH_ROOT)/include/Nemu/SUPDrvMangling.h
 TEMPLATE_NEMUR0DRV_CXXFLAGS  += -include $(PATH_ROOT)/include/Nemu/SUPDrvMangling.h
endif

#
# Template for building libraries used by ring-0 drivers.
#
TEMPLATE_NemuR0DrvLib = Nemu Ring 0 Driver Library
TEMPLATE_NemuR0DrvLib_EXTENDS = NEMUR0DRV
TEMPLATE_NemuR0DrvLib_INSTTYPE = stage
TEMPLATE_NemuR0DrvLib_INSTTYPE.linux = stage


#
# Template for building R3 executables and static libraries which are linked into executables.
# Note! This is the base template for a whole lot of other ones, so be careful when changing it.
#
TEMPLATE_NEMUR3EXE                     = Nemu Ring 3 Exe
TEMPLATE_NEMUR3EXE_ASTOOL              = $(NEMU_ASTOOL)
TEMPLATE_NEMUR3EXE_ASFLAGS.x86         = $(NEMU_ASFLAGS32)
TEMPLATE_NEMUR3EXE_ASFLAGS.amd64       = $(NEMU_ASFLAGS64)
TEMPLATE_NEMUR3EXE_DEFS                = IN_RING3 $(ARCH_BITS_DEFS)
TEMPLATE_NEMUR3EXE_DEFS.win            = _CRT_SECURE_NO_DEPRECATE
TEMPLATE_NEMUR3EXE_USES                = dtrace
if defined(NEMU_WITH_DTRACE_R3) && defined(NEMU_WITH_NATIVE_DTRACE)
 TEMPLATE_NEMUR3EXE_DTRACETOOL         = DTraceAndNemuTpG
 TEMPLATE_NEMUR3EXE_DTRACE_OBJ_FLAGS   = -C
 TEMPLATE_NEMUR3EXE_DTRACE_HDR_FLAGS   = -C
 TEMPLATE_NEMUR3EXE_DEFS              += NEMU_WITH_DTRACE NEMU_WITH_DTRACE_R3 NEMU_WITH_NATIVE_DTRACE
else
  TEMPLATE_NEMUR3EXE_DTRACE_HDR_FLAGS  = --ring-3-context
  TEMPLATE_NEMUR3EXE_DTRACE_OBJ_FLAGS  = --ring-3-context --pic --probe-fn-imported --probe-fn-name "SUPTracerFireProbe"
 if defined(NEMU_WITH_DTRACE_R3)
  TEMPLATE_NEMUR3EXE_DTRACETOOL        = NemuTpG
  TEMPLATE_NEMUR3EXE_DEFS             += NEMU_WITH_DTRACE NEMU_WITH_DTRACE_R3
 else
  TEMPLATE_NEMUR3EXE_DTRACETOOL        = NemuTpG-Disabled
 endif
endif
TEMPLATE_NEMUR3EXE_LIBS.kprofile       = $(LIB_KPROFILE)
ifeq ($(KBUILD_TARGET),win)
# TEMPLATE_NEMUR3EXE_TOOL               = $(NEMU_VCC_TOOL)
 TEMPLATE_NEMUR3EXE_TOOL.win.x86       = $(NEMU_VCC_TOOL_STEM)X86
 TEMPLATE_NEMUR3EXE_TOOL.win.amd64     = $(NEMU_VCC_TOOL_STEM)AMD64
 TEMPLATE_NEMUR3EXE_RCDEFS             = NEMU_SVN_REV=$(NEMU_SVN_REV) NEMU_SVN_REV_MOD_5K=$(expr $(NEMU_SVN_REV) % 50000)
 TEMPLATE_NEMUR3EXE_SDKS               = ReorderCompilerIncs $(NEMU_WINPSDK)
 TEMPLATE_NEMUR3EXE_CXXFLAGS           = -Zi -Zl -GR- -EHsc -GF -MD$(NEMU_VCC_CRT_TYPE) -W3 -wd4065 -wd4244 -wd4996 -Zc:wchar_t- $(NEMU_VCC_OPT) $(NEMU_VCC_FP)
 TEMPLATE_NEMUR3EXE_CXXFLAGS.debug     = -RTCsu
 TEMPLATE_NEMUR3EXE_CXXFLAGS.dbgopt    = $(NO_SUCH_VARIABLE)
 TEMPLATE_NEMUR3EXE_CXXFLAGS.kprofile  = -Gh -GH
 TEMPLATE_NEMUR3EXE_CFLAGS             = $(TEMPLATE_NEMUR3EXE_CXXFLAGS)
 TEMPLATE_NEMUR3EXE_CFLAGS.debug       = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.debug)
 TEMPLATE_NEMUR3EXE_CFLAGS.dbgopt      = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.dbgopt)
 TEMPLATE_NEMUR3EXE_CFLAGS.kprofile    = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.kprofile)
 TEMPLATE_NEMUR3EXE_LDFLAGS            = -Ignore:4197 \
	/NOD /INCREMENTAL:NO /MAPINFO:EXPORTS /LargeAddressAware /DynamicBase /NxCompat /Release /Debug \
	/Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	/STUB:$(PATH_ROOT)/src/Nemu/HostDrivers/Support/win/winstub.com \
	/DISALLOWLIB:libc.lib \
	/DISALLOWLIB:libcd.lib \
	/DISALLOWLIB:libcmt.lib \
	/DISALLOWLIB:libcmtd.lib \
	/DISALLOWLIB:msvcrt$(NEMU_VCC_CRT_TYPE_N).lib \
	/DISALLOWLIB:msvcprt$(NEMU_VCC_CRT_TYPE_N).lib
 ifdef NEMU_WITH_DTRACE_R3
  TEMPLATE_NEMUR3EXE_LDFLAGS          += -Merge:VTGPrLc.Data=VTGPrLc.Begin -Merge:VTGPrLc.End=VTGPrLc.Begin -Merge:VTGPrLc.Begin=VTGObj
 endif
 if defined(NEMU_SIGNING_MODE) && defined(NEMU_WITH_HARDENING)
   TEMPLATE_NEMUR3EXE_LDFLAGS         += -IntegrityCheck
 endif

 TEMPLATE_NEMUR3EXE_LIBS.x86           = \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/msvcrt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/msvcprt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/oldnames.lib
 TEMPLATE_NEMUR3EXE_LIBS.amd64         = \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.amd64)_LIB)/msvcrt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.amd64)_LIB)/msvcprt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.amd64)_LIB)/oldnames.lib
 TEMPLATE_NEMUR3EXE_POST_CMDS          = $(NEMU_SIGN_IMAGE_CMDS)
 if defined(NEMU_WITH_MORE_NT4_COMPAT_BINARIES) && "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.x86"
  TEMPLATE_NEMUR3EXE_POST_CMDS.win.x86 = $(if $(eq $(tool_do),LINK_LIBRARY),,$(NEMU_PE_SET_VERSION) $(out)$$(NLTAB)$(TEMPLATE_NEMUR3EXE_POST_CMDS))
  TEMPLATE_NEMUR3EXE_LNK_DEPS.win.x86  = $(if $(eq $(tool_do),LINK_LIBRARY),,$(NEMU_PE_SET_VERSION))
  TEMPLATE_NEMUR3EXE_LDFLAGS.win.x86   = \
  	-Include:_vcc100_kernel32_fakes_cpp \
	-Include:_vcc100_kernel32_fakes_asm
  TEMPLATE_NEMUR3EXE_LIBS.win.x86      = \
  	$(PATH_STAGE_LIB)/RuntimeR3VccTricks2$(NEMU_SUFF_LIB)
  TEMPLATE_NEMUR3EXE_LIBS.x86          = \
  	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/oldnames.lib \
  	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/libcmt$(NEMU_VCC_CRT_TYPE).lib \
  	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/libcpmt$(NEMU_VCC_CRT_TYPE).lib
 endif

else # the gcc guys
TEMPLATE_NEMUR3EXE_TOOL                = $(NEMU_GCC_TOOL)
TEMPLATE_NEMUR3EXE_CXXFLAGS            = -g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_OPT) $(NEMU_GCC_FP) -fno-strict-aliasing $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_fvisibility-inlines-hidden) $(NEMU_GCC_IPRT_FMT_CHECK)
TEMPLATE_NEMUR3EXE_CXXFLAGS.x86        = -m32
TEMPLATE_NEMUR3EXE_CXXFLAGS.amd64      = -m64
TEMPLATE_NEMUR3EXE_CXXFLAGS.sparc32    = -m32
TEMPLATE_NEMUR3EXE_CXXFLAGS.sparc64    = -m64
TEMPLATE_NEMUR3EXE_CXXFLAGS.kprofile   = -finstrument-functions
TEMPLATE_NEMUR3EXE_CFLAGS              = -g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_C)   $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_OPT) $(NEMU_GCC_FP) -fno-strict-aliasing $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_IPRT_FMT_CHECK)
TEMPLATE_NEMUR3EXE_CFLAGS.x86          = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.x86)
TEMPLATE_NEMUR3EXE_CFLAGS.amd64        = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.amd64)
TEMPLATE_NEMUR3EXE_CFLAGS.sparc32      = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.sparc32)
TEMPLATE_NEMUR3EXE_CFLAGS.sparc64      = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.sparc64)
TEMPLATE_NEMUR3EXE_CFLAGS.debug        = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.debug)
TEMPLATE_NEMUR3EXE_CFLAGS.kprofile     = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.kprofile)
TEMPLATE_NEMUR3EXE_OBJCFLAGS           = $(TEMPLATE_NEMUR3EXE_CFLAGS)
TEMPLATE_NEMUR3EXE_OBJCFLAGS.x86       = $(TEMPLATE_NEMUR3EXE_CFLAGS.x86)
TEMPLATE_NEMUR3EXE_OBJCFLAGS.amd64     = $(TEMPLATE_NEMUR3EXE_CFLAGS.amd64)
TEMPLATE_NEMUR3EXE_OBJCFLAGS.debug     = $(TEMPLATE_NEMUR3EXE_CFLAGS.debug)
TEMPLATE_NEMUR3EXE_OBJCFLAGS.kprofile  = $(TEMPLATE_NEMUR3EXE_CFLAGS.kprofile)
TEMPLATE_NEMUR3EXE_OBJCXXFLAGS         = $(TEMPLATE_NEMUR3EXE_CXXFLAGS)
TEMPLATE_NEMUR3EXE_OBJCXXFLAGS.x86     = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.x86)
TEMPLATE_NEMUR3EXE_OBJCXXFLAGS.amd64   = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.amd64)
TEMPLATE_NEMUR3EXE_OBJCXXFLAGS.debug   = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.debug)
TEMPLATE_NEMUR3EXE_OBJCXXFLAGS.kprofile= $(TEMPLATE_NEMUR3EXE_CXXFLAGS.kprofile)
TEMPLATE_NEMUR3EXE_LDFLAGS.x86         = -m32
TEMPLATE_NEMUR3EXE_LDFLAGS.amd64       = -m64
TEMPLATE_NEMUR3EXE_LDFLAGS.sparc32     = -m32
TEMPLATE_NEMUR3EXE_LDFLAGS.sparc64     = -m64
TEMPLATE_NEMUR3EXE_LDFLAGS.linux       = -Wl,-z,noexecstack,-z,relro $(NEMU_LD_as_needed)
TEMPLATE_NEMUR3EXE_LDFLAGS.solaris     = -Wl,-z,ignore # same as NEMU_LD_as_needed

 ifeq ($(KBUILD_TARGET),linux)
TEMPLATE_NEMUR3EXE_LIBS                = pthread m rt dl
 else ifeq ($(KBUILD_TARGET),os2)
TEMPLATE_NEMUR3EXE_TOOL                = GXX3OMF
TEMPLATE_NEMUR3EXE_LIBS                = socket iconv
 else ifeq ($(KBUILD_TARGET),darwin)
TEMPLATE_NEMUR3EXE_TOOL                = GXX4MACHO
TEMPLATE_NEMUR3EXE_LIBS                =
TEMPLATE_NEMUR3EXE_DEFS.darwin         = $(NEMU_DARWIN_DEF_SDK_DEFS)
TEMPLATE_NEMUR3EXE_CFLAGS.darwin       = $(NEMU_DARWIN_DEF_SDK_CFLAGS) -fno-common
TEMPLATE_NEMUR3EXE_CXXFLAGS.darwin     = $(NEMU_DARWIN_DEF_SDK_CXXFLAGS)
TEMPLATE_NEMUR3EXE_OBJCFLAGS.darwin    = $(NEMU_DARWIN_DEF_SDK_OBJCFLAGS)
TEMPLATE_NEMUR3EXE_OBJCXXFLAGS.darwin  = $(NEMU_DARWIN_DEF_SDK_OBJCXXFLAGS)
TEMPLATE_NEMUR3EXE_LDFLAGS.darwin      = $(NEMU_DARWIN_DEF_SDK_LDFLAGS)
TEMPLATE_NEMUR3EXE_LDFLAGS.darwin.x86  = -read_only_relocs suppress
  ifdef NEMU_WITH_DTRACE_R3
   TEMPLATE_NEMUR3EXE_CXXFLAGS := $(filter-out -pedantic,$(TEMPLATE_NEMUR3EXE_CXXFLAGS)) -fdollars-in-identifiers # annoying gcc option precedence.
  endif
 else ifeq ($(KBUILD_TARGET),haiku)
TEMPLATE_NEMUR3EXE_TOOL                = GXX3
TEMPLATE_NEMUR3EXE_POST_CMDS          = $(NEMU_HAIKU_XRES_SETVER_CMDS)
TEMPLATE_NEMUR3EXE_LIBS                = network iconv stdc++ supc++
TEMPLATE_NEMUR3EXE_LIBPATH            += \
	/boot/common/lib
# Haiku uses PIC by default...
TEMPLATE_NEMUR3EXE_CFLAGS             += -fno-pic
TEMPLATE_NEMUR3EXE_CXXFLAGS           += -fno-pic
TEMPLATE_NEMUR3EXE_LDFLAGS            += -fno-pic
 else if1of ($(KBUILD_TARGET), freebsd netbsd openbsd)
TEMPLATE_NEMUR3EXE_TOOL                = GXX3
TEMPLATE_NEMUR3EXE_LIBS                = pthread
TEMPLATE_NEMUR3EXE_INCS               += \
	/usr/include \
	/usr/X11R6/include \
	/usr/local/include
TEMPLATE_NEMUR3EXE_LIBPATH            += \
	/usr/lib \
	/usr/X11R6/lib \
	/usr/local/lib
 else ifeq ($(KBUILD_TARGET),solaris)
TEMPLATE_NEMUR3EXE_TOOL                = GXX3PLAIN
TEMPLATE_NEMUR3EXE_DEFS               += LIBICONV_PLUG _REENTRANT # Avoid the GNU libiconv, for now at least.
TEMPLATE_NEMUR3EXE_LIBS                = rt socket
 else
$(warning Warning: NEMU Build: Target $(KBUILD_TARGET) is not officially supported!)
TEMPLATE_NEMUR3EXE_CXXFLAGS.profile    = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.release)
TEMPLATE_NEMUR3EXE_CXXFLAGS.kprofile   = $(TEMPLATE_NEMUR3EXE_CXXFLAGS.krelease)
 endif
 ifdef NEMU_WITH_RUNPATH
  TEMPLATE_NEMUR3EXE_LDFLAGS          += '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)'
 else ifdef NEMU_WITH_RELATIVE_RUNPATH
  TEMPLATE_NEMUR3EXE_LDFLAGS          += '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)'
 endif
 ifdef NEMU_WITH_ORIGIN
  TEMPLATE_NEMUR3EXE_LDFLAGS.linux    += $(NEMU_GCC_ORIGIN_OPT)
 endif
endif

#
# Template for building R3 shared objects / DLLs.
# This is mostly identical to the NEMUR3EXE template. (Avoid PIC if possible!)
#				       -
TEMPLATE_NEMUR3                        = Nemu Ring 3 SO/DLLs
TEMPLATE_NEMUR3_EXTENDS                = NEMUR3EXE
TEMPLATE_NEMUR3_DEFS.darwin            = $(TEMPLATE_NEMUR3EXE_DEFS.darwin) PIC
TEMPLATE_NEMUR3_LDFLAGS.darwin         = $(TEMPLATE_NEMUR3EXE_LDFLAGS.darwin) \
	-current_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-compatibility_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)
ifn1of ($(KBUILD_TARGET), darwin win os2)
 TEMPLATE_NEMUR3_DEFS                  = $(TEMPLATE_NEMUR3EXE_DEFS) PIC
 TEMPLATE_NEMUR3_CFLAGS                = $(TEMPLATE_NEMUR3EXE_CFLAGS) -fPIC
 TEMPLATE_NEMUR3_CXXFLAGS              = $(TEMPLATE_NEMUR3EXE_CXXFLAGS) -fPIC
 TEMPLATE_NEMUR3_LDFLAGS               = $(TEMPLATE_NEMUR3EXE_LDFLAGS) -fPIC
endif
ifeq ($(KBUILD_TARGET),haiku)
 # Haiku uses PIC by default...
 TEMPLATE_NEMUR3_CFLAGS               = $(TEMPLATE_NEMUR3EXE_CFLAGS) -fno-pic
 TEMPLATE_NEMUR3_CXXFLAGS             = $(TEMPLATE_NEMUR3EXE_CXXFLAGS) -fno-pic
 TEMPLATE_NEMUR3_LDFLAGS              = $(TEMPLATE_NEMUR3EXE_LDFLAGS) -fno-pic
endif

#
# Temporary: Renaming the template and warnings will be errors (soon).
#
TEMPLATE_NemuR3Dll                     += Nemu ring-3 SO/DLLs, no warnings
TEMPLATE_NemuR3Dll_EXTENDS             += NEMUR3
TEMPLATE_NemuR3Dll_EXTENDS_BY          += appending
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NemuR3Dll_CFLAGS            += $(NEMU_VCC_WERR)
 TEMPLATE_NemuR3Dll_CXXFLAGS          += $(NEMU_VCC_WERR)
 TEMPLATE_NemuR3Dll_LDFLAGS           += $(NEMU_VCC_LD_WERR)
else
 TEMPLATE_NemuR3Dll_CFLAGS            += $(NEMU_GCC_WERR)
 TEMPLATE_NemuR3Dll_CXXFLAGS          += $(NEMU_GCC_WERR)
endif

# x86 edition of the above template for use on AMD64 targets.
TEMPLATE_NemuR3Dll-x86                = 32-bit Nemu ring-3 SO/DLLs, no warnings
TEMPLATE_NemuR3Dll-x86_EXTENDS        = NemuR3Dll
TEMPLATE_NemuR3Dll-x86_BLD_TRG_ARCH   = x86
TEMPLATE_NemuR3Dll-x86_DEFS           = $(filter-out HC_ARCH_BITS%,$(TEMPLATE_NemuR3Dll_DEFS)) \
	HC_ARCH_BITS=32 ARCH_BITS=32


#
# Template for building performance critical stuff with warnings-as-errors.
#
TEMPLATE_NemuR3DllNoPic                    = Nemu ring-3 SO/DLLs without PIC, without warnings.
TEMPLATE_NemuR3DllNoPic_EXTENDS            = NEMUR3
if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), linux.x86 freebsd.x86)
 TEMPLATE_NemuR3DllNoPic_DEFS              = $(TEMPLATE_NEMUR3EXE_DEFS)
 TEMPLATE_NemuR3DllNoPic_CFLAGS            = $(TEMPLATE_NEMUR3EXE_CFLAGS)   $(NEMU_GCC_WERR)
 TEMPLATE_NemuR3DllNoPic_CXXFLAGS          = $(TEMPLATE_NEMUR3EXE_CXXFLAGS) $(NEMU_GCC_WERR)
 TEMPLATE_NemuR3DllNoPic_LDFLAGS           = $(TEMPLATE_NEMUR3EXE_LDFLAGS)
else ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NemuR3DllNoPic_CFLAGS            = $(TEMPLATE_NEMUR3_CFLAGS)   $(NEMU_VCC_WERR)
 TEMPLATE_NemuR3DllNoPic_CFLAGS.debug      = $(filter-out -RTC%,$(TEMPLATE_NEMUR3_CFLAGS.debug))
 TEMPLATE_NemuR3DllNoPic_CFLAGS.release    = $(TEMPLATE_NEMUR3_CFLAGS.release) -GS-
 TEMPLATE_NemuR3DllNoPic_CXXFLAGS          = $(TEMPLATE_NEMUR3_CXXFLAGS) $(NEMU_VCC_WERR)
 TEMPLATE_NemuR3DllNoPic_CXXFLAGS.debug    = $(filter-out -RTC%,$(TEMPLATE_NEMUR3_CXXFLAGS.debug)) # RTCsu Prevents IEM opt.
 TEMPLATE_NemuR3DllNoPic_CXXFLAGS.release  = $(TEMPLATE_NEMUR3_CXXFLAGS.release) -GS-
 TEMPLATE_NemuR3DllNoPic_LDFLAGS           = $(TEMPLATE_NEMUR3_LDFLAGS)  $(NEMU_VCC_LD_WERR)
else
 TEMPLATE_NemuR3DllNoPic_CFLAGS            = $(TEMPLATE_NEMUR3_CFLAGS)   $(NEMU_GCC_WERR)
 TEMPLATE_NemuR3DllNoPic_CXXFLAGS          = $(TEMPLATE_NEMUR3_CXXFLAGS) $(NEMU_GCC_WERR)
endif

# x86 edition of the above template for use on AMD64 targets.
TEMPLATE_NemuR3DllNoPic-x86                = 32-bit Nemu ring-3 SO/DLLs without PIC, without warnings.
TEMPLATE_NemuR3DllNoPic-x86_EXTENDS        = NemuR3DllNoPic
TEMPLATE_NemuR3DllNoPic-x86_BLD_TRG_ARCH   = x86
TEMPLATE_NemuR3DllNoPic-x86_DEFS           = $(filter-out HC_ARCH_BITS%,$(TEMPLATE_NemuR3DllNoPic_DEFS)) \
	HC_ARCH_BITS=32 ARCH_BITS=32


#
# Template for building performance critical stuff without warnings-as-errors.
#
TEMPLATE_NemuR3DllWarnNoPic                = Nemu ring-3 SO/DLLs without PIC, with warnings.
TEMPLATE_NemuR3DllWarnNoPic_EXTENDS        = NEMUR3
if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), linux.x86 freebsd.x86)
 TEMPLATE_NemuR3DllWarnNoPic_DEFS          = $(TEMPLATE_NEMUR3EXE_DEFS)
 TEMPLATE_NemuR3DllWarnNoPic_CFLAGS        = $(TEMPLATE_NEMUR3EXE_CFLAGS)
 TEMPLATE_NemuR3DllWarnNoPic_CXXFLAGS      = $(TEMPLATE_NEMUR3EXE_CXXFLAGS)
 TEMPLATE_NemuR3DllWarnNoPic_LDFLAGS       = $(TEMPLATE_NEMUR3EXE_LDFLAGS)
else ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NemuR3DllWarnNoPic_CFLAGS.release   = $(TEMPLATE_NEMUR3_CFLAGS.release) -GS-
 TEMPLATE_NemuR3DllWarnNoPic_CXXFLAGS.release = $(TEMPLATE_NEMUR3_CXXFLAGS.release) -GS-
endif

#
# Template for building static R3 executables and any static
# libraries they link with.
#
TEMPLATE_NEMUR3STATIC                  = Nemu Static Ring 3 EXE
TEMPLATE_NEMUR3STATIC_EXTENDS          = NEMUR3EXE
TEMPLATE_NEMUR3STATIC_DEFS             = IN_RT_STATIC IN_RT_R3 IN_SUP_STATIC $(TEMPLATE_NEMUR3EXE_DEFS)
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NEMUR3STATIC_CFLAGS          = $(filter-out -MD$(NEMU_VCC_CRT_TYPE), $(TEMPLATE_NEMUR3EXE_CFLAGS)) -MT$(NEMU_VCC_CRT_TYPE)
 TEMPLATE_NEMUR3STATIC_CXXFLAGS        = $(filter-out -MD$(NEMU_VCC_CRT_TYPE), $(TEMPLATE_NEMUR3EXE_CFLAGS)) -MT$(NEMU_VCC_CRT_TYPE)
 TEMPLATE_NEMUR3STATIC_LDFLAGS         = $(filter-out /DISALLOWLIB:libcmt$(NEMU_VCC_CRT_TYPE).lib /DISALLOWLIB:libcpmt$(NEMU_VCC_CRT_TYPE).lib, $(TEMPLATE_NEMUR3EXE_LDFLAGS)) \
	/DISALLOWLIB:msvcrt.lib \
	/DISALLOWLIB:msvcrtd.lib \
	/DISALLOWLIB:msvcprt.lib \
	/DISALLOWLIB:msvcprtd.lib
 TEMPLATE_NEMUR3STATIC_LIBS.x86           = \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3STATIC_TOOL.win.x86)_LIB)/oldnames.lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3STATIC_TOOL.win.x86)_LIB)/libcmt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3STATIC_TOOL.win.x86)_LIB)/libcpmt$(NEMU_VCC_CRT_TYPE).lib
 TEMPLATE_NEMUR3STATIC_LIBS.amd64         = \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3STATIC_TOOL.win.amd64)_LIB)/libcmt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3STATIC_TOOL.win.amd64)_LIB)/libcpmt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3STATIC_TOOL.win.amd64)_LIB)/oldnames.lib
else ifn1of ($(KBUILD_TARGET), darwin linux solaris)
 # The gcc guys sans darwin, linux and solaris (don't depend on statically compiled system libs there)
 TEMPLATE_NEMUR3STATIC_CFLAGS          = $(TEMPLATE_NEMUR3EXE_CFLAGS) -static
 TEMPLATE_NEMUR3STATIC_CXXFLAGS        = $(TEMPLATE_NEMUR3EXE_CXXFLAGS) -static
 TEMPLATE_NEMUR3STATIC_OBJCFLAGS       = $(TEMPLATE_NEMUR3EXE_OBJCFLAGS) -static
 TEMPLATE_NEMUR3STATIC_OBJCXXFLAGS     = $(TEMPLATE_NEMUR3EXE_OBJCXXFLAGS) -static
 TEMPLATE_NEMUR3STATIC_LDFLAGS         = $(TEMPLATE_NEMUR3EXE_LDFLAGS) -static
else ifeq ($(KBUILD_TARGET),solaris)
 TEMPLATE_NEMUR3STATIC_LIBS            = $(TEMPLATE_NEMUR3EXE_LIBS) nsl
 TEMPLATE_NEMUR3STATIC_LDFLAGS         = $(filter-out '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)' '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)',$(TEMPLATE_NEMUR3EXE_LDFLAGS))
else
 TEMPLATE_NEMUR3STATIC_LDFLAGS         = $(filter-out '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)' '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)',$(TEMPLATE_NEMUR3EXE_LDFLAGS))
endif

#
# Temporary: Renaming the template and warnings will be errors (soon).
# Unlike NEMUR3STATIC, this is strict wrt warnings and includes IPRT.
#
TEMPLATE_NemuR3Static               = New name for NEMUR3STATIC
TEMPLATE_NemuR3Static_EXTENDS       = NEMUR3STATIC
TEMPLATE_NemuR3Static_EXTENDS_BY    = appending
TEMPLATE_NemuR3Static_SDKS         += NEMU_OPENSSL
TEMPLATE_NemuR3Static_SDKS.win     += NEMU_NTDLL
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NemuR3Static_CFLAGS      += $(NEMU_VCC_WERR)
 TEMPLATE_NemuR3Static_CXXFLAGS    += $(NEMU_VCC_WERR)
 TEMPLATE_NemuR3Static_LDFLAGS     += $(NEMU_VCC_LD_WERR)
else
 TEMPLATE_NemuR3Static_CFLAGS      += $(NEMU_GCC_WERR)
 TEMPLATE_NemuR3Static_CXXFLAGS    += $(NEMU_GCC_WERR)
endif
TEMPLATE_NemuR3Static_LIBS         += \
 	$(NEMU_LIB_RUNTIME_STATIC)
ifndef SDK_NEMU_OPENSSL_LIBS
 TEMPLATE_NemuR3Static_LIBS        += \
 	$(PATH_STAGE_LIB)/Nemu-libcrypto$(NEMU_SUFF_LIB) \
 	$(PATH_STAGE_LIB)/Nemu-libssl$(NEMU_SUFF_LIB)
endif
ifndef SDK_NEMU_LIBXML2_LIBS
 TEMPLATE_NemuR3Static_LIBS        += \
 	$(PATH_STAGE_LIB)/Nemu-libxml2-static$(NEMU_SUFF_LIB)
endif
if1of ($(KBUILD_TARGET),os2 win)
 TEMPLATE_NemuR3Static_LIBS        += \
 	$(PATH_STAGE_LIB)/Nemu-liblzf-static$(NEMU_SUFF_LIB) \
 	$(PATH_STAGE_LIB)/Nemu-zlib-static$(NEMU_SUFF_LIB)
else
 TEMPLATE_NemuR3Static_LIBS        += \
 	$(PATH_STAGE_LIB)/Nemu-liblzf$(NEMU_SUFF_LIB) \
 	$(SDK_NEMU_ZLIB_LIBS)
 ifeq ($(KBUILD_TARGET),linux)
  TEMPLATE_NemuR3Static_LIBS       += crypt
 else if1of ($(KBUILD_TARGET),darwin freebsd)
  TEMPLATE_NemuR3Static_LIBS       += iconv
 else ifeq ($(KBUILD_TARGET),solaris)
  TEMPLATE_NemuR3Static_LIBS       += kstat
 endif
endif


#
# Same as NEMUR3EXE but without C++ exceptions.
#
# NEMUR3EXE does C++ exceptions and may assumes that extern "C" functions
# doesn't throw them. Use this template (and NEMUR3DLLNOXCPT) with care
# and only where the C++ overhead is really unwanted.
#
TEMPLATE_NEMUR3EXENOXCPT               = Nemu Ring 3 Exe without C++ exception
TEMPLATE_NEMUR3EXENOXCPT_EXTENDS       = NEMUR3EXE
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NEMUR3EXENOXCPT_CFLAGS       = $(filter-out -EH%,$(TEMPLATE_NEMUR3EXE_CFLAGS)  ) -EHs-
 TEMPLATE_NEMUR3EXENOXCPT_CXXFLAGS     = $(filter-out -EH%,$(TEMPLATE_NEMUR3EXE_CXXFLAGS)) -EHs-
else
 TEMPLATE_NEMUR3EXENOXCPT_CXXFLAGS     = $(TEMPLATE_NEMUR3EXE_CXXFLAGS) -fno-exceptions
endif

#
# Same as NEMUR3 but without C++ exceptions.
#
TEMPLATE_NEMUR3DLLNOXCPT               = Nemu Ring 3 SO/DLLs without C++ exception
TEMPLATE_NEMUR3DLLNOXCPT_EXTENDS       = NEMUR3
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NEMUR3DLLNOXCPT_CFLAGS       = $(filter-out -EH%,$(TEMPLATE_NEMUR3_CFLAGS)  ) -EHs-
 TEMPLATE_NEMUR3DLLNOXCPT_CXXFLAGS     = $(filter-out -EH%,$(TEMPLATE_NEMUR3_CXXFLAGS)) -EHs-
else
 TEMPLATE_NEMUR3DLLNOXCPT_CXXFLAGS     = $(TEMPLATE_NEMUR3_CXXFLAGS) -fno-exceptions
endif

#
# Template for building hardened Ring-3 executables.
# These shall have no extra runpaths, esp. not origin ones.
#
TEMPLATE_NEMUR3HARDENEDEXE = Hardened Nemu Ring-3 EXE
TEMPLATE_NEMUR3HARDENEDEXE_EXTENDS = NEMUR3EXE
TEMPLATE_NEMUR3HARDENEDEXE_DEBUG_INST.win = $(INST_DEBUG)hardened-exes/
ifdef NEMU_WITH_HARDENING
 TEMPLATE_NEMUR3HARDENEDEXE_LIBS = $(NEMU_LIB_SUPHARDENED) $(TEMPLATE_NEMUR3EXE_LIBS)
else
 TEMPLATE_NEMUR3HARDENEDEXE_LIBS = $(TEMPLATE_NEMUR3EXE_LIBS)
endif
TEMPLATE_NEMUR3HARDENEDEXE_LDFLAGS.darwin = $(TEMPLATE_NEMUR3EXE_LDFLAGS.darwin) -framework IOKit
ifeq ($(KBUILD_TARGET),linux)
# not necessary except USE_LIB_PCAP is defined in SUPR3HardenedMain.cpp
# TEMPLATE_NEMUR3HARDENEDEXE_LIBS += cap
endif
ifeq ($(KBUILD_TARGET),win) # No CRT!
 TEMPLATE_NEMUR3HARDENEDEXE_SDKS          = NEMU_NTDLL $(TEMPLATE_NEMUR3EXE_SDKS)
 TEMPLATE_NEMUR3HARDENEDEXE_LIBS.x86      = \
	$(PATH_SDK_$(NEMU_WINDDK)_LIB.x86)/int64.lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3HARDENEDEXE_TOOL.win.x86)_LIB)/chkstk.obj
 TEMPLATE_NEMUR3HARDENEDEXE_CXXFLAGS      = $(filter-out -RTC% -GZ -GS,$(TEMPLATE_NEMUR3EXE_CXXFLAGS)) -GS-
 TEMPLATE_NEMUR3HARDENEDEXE_CXXFLAGS.debug= $(filter-out -RTC% -GZ -GS,$(TEMPLATE_NEMUR3EXE_CXXFLAGS.debug)) -GS- #-O2 -Oy-
 TEMPLATE_NEMUR3HARDENEDEXE_CFLAGS        = $(filter-out -RTC% -GZ -GS,$(TEMPLATE_NEMUR3EXE_CFLAGS)) -GS-
 TEMPLATE_NEMUR3HARDENEDEXE_CFLAGS.debug  = $(filter-out -RTC% -GZ -GS,$(TEMPLATE_NEMUR3EXE_CFLAGS.debug)) -GS- -O2 -Oy-
 TEMPLATE_NEMUR3HARDENEDEXE_LDFLAGS       = $(TEMPLATE_NEMUR3EXE_LDFLAGS) \
	/DISALLOWLIB:msvcrt$(NEMU_VCC_CRT_TYPE).lib \
	/DISALLOWLIB:msvcprt$(NEMU_VCC_CRT_TYPE).lib
 TEMPLATE_NEMUR3HARDENEDEXE_LDFLAGS.win.x86   = $(TEMPLATE_NEMUR3EXE_LDFLAGS.win.x86)   /entry:suplibHardenedWindowsMain
 TEMPLATE_NEMUR3HARDENEDEXE_LDFLAGS.win.amd64 = $(TEMPLATE_NEMUR3EXE_LDFLAGS.win.amd64) /entry:suplibHardenedWindowsMain
 TEMPLATE_NEMUR3HARDENEDEXE_LIBS.x86       = $(NOT_SUCH_VARIABLE)
 TEMPLATE_NEMUR3HARDENEDEXE_LIBS.amd64     = $(NOT_SUCH_VARIABLE)
else ifn1of ($(KBUILD_TARGET), os2)
 TEMPLATE_NEMUR3HARDENEDEXE_LDFLAGS       = $(filter-out '$(NEMU_GCC_RPATH_OPT)%,$(TEMPLATE_NEMUR3EXE_LDFLAGS))
 TEMPLATE_NEMUR3HARDENEDEXE_LDFLAGS.linux = $(filter-out $(NEMU_GCC_ORIGIN_OPT),$(TEMPLATE_NEMUR3EXE_LDFLAGS.linux))
endif

#
# Template for building hardened Ring-3 libraries.
#
TEMPLATE_NEMUR3HARDENEDLIB = Hardened Nemu Ring-3 LIB
TEMPLATE_NEMUR3HARDENEDLIB_EXTENDS = NEMUR3HARDENEDEXE
TEMPLATE_NEMUR3HARDENEDLIB_LIBS = $(NO_SUCH_VARIABLE)


#
# Template for building hardened Ring-3 testcase executables.
#
TEMPLATE_NemuR3HardenedTstExe = Nemu Ring-3 Hardened Testcase Exe (currently windows only!)
TEMPLATE_NemuR3HardenedTstExe_EXTENDS = NEMUR3HARDENEDEXE
TEMPLATE_NemuR3HardenedTstExe_INST = $(INST_TESTCASE)

#
# Template for building hardened Ring-3 testcase DLLs (pairs with NemuR3HardenedTstExe).
#
TEMPLATE_NemuR3HardenedTstDll = Nemu Ring-3 Hardened Testcase Dll (currently windows only!)
TEMPLATE_NemuR3HardenedTstDll_EXTENDS = NemuR3TstDll
TEMPLATE_NemuR3HardenedTstDll_INST = $(INST_TESTCASE)
 TEMPLATE_NemuR3HardenedTstDll_LDFLAGS.win = $(TEMPLATE_NemuR3TstDll_LDFLAGS.win) -IntegrityCheck
ifn1of ($(KBUILD_TARGET), win os2)
 TEMPLATE_NemuR3HardenedTstDll_LDFLAGS       = $(filter-out '$(NEMU_GCC_RPATH_OPT)%,$(TEMPLATE_NemuR3TstDll_LDFLAGS))
 TEMPLATE_NemuR3HardenedTstDll_LDFLAGS.linux = $(filter-out $(NEMU_GCC_ORIGIN_OPT),$(TEMPLATE_NemuR3TstDll_LDFLAGS.linux))
endif

#
# Template for building set-uid-to-root helper programs.
# In hardened builds, these may only contain absolute runpaths!
#
TEMPLATE_NemuR3SetUidToRoot = Set-uid-to-root helper program.
if1of ($(KBUILD_TARGET),win)
 TEMPLATE_NemuR3SetUidToRoot_EXTENDS = NEMUR3EXE
else
 TEMPLATE_NemuR3SetUidToRoot_EXTENDS = NEMUR3HARDENEDEXE
endif
TEMPLATE_NemuR3SetUidToRoot_LIBS = $(NO_SUCH_VARIABLE)
ifdef NEMU_WITH_RUNPATH
 TEMPLATE_NemuR3SetUidToRoot_LDFLAGS += '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)'
endif
ifndef NEMU_WITH_HARDENING
 ifdef NEMU_WITH_RELATIVE_RUNPATH
  TEMPLATE_NemuR3SetUidToRoot_LDFLAGS += '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)'
 endif
 ifdef NEMU_WITH_ORIGIN
  TEMPLATE_NemuR3SetUidToRoot_LDFLAGS.linux += $(NEMU_GCC_ORIGIN_OPT)
 endif
endif

#
# Template for building R3 tools.
#
TEMPLATE_NemuR3Tool            = Nemu Ring 3 Tools
TEMPLATE_NemuR3Tool_EXTENDS    = NEMUR3EXE
TEMPLATE_NemuR3Tool_INST       = $(NEMU_INST_TOOLS)
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NemuR3Tool_CFLAGS    = $(TEMPLATE_NEMUR3EXE_CFLAGS) $(NEMU_VCC_WERR)
 TEMPLATE_NemuR3Tool_CXXFLAGS  = $(TEMPLATE_NEMUR3EXE_CXXFLAGS) $(NEMU_VCC_WERR)
 TEMPLATE_NemuR3Tool_LDFLAGS   = $(TEMPLATE_NEMUR3EXE_LDFLAGS) $(NEMU_VCC_LD_WERR)
else
 TEMPLATE_NemuR3Tool_CFLAGS    = $(TEMPLATE_NEMUR3EXE_CFLAGS) $(NEMU_GCC_WERR)
 TEMPLATE_NemuR3Tool_CXXFLAGS  = $(TEMPLATE_NEMUR3EXE_CXXFLAGS) $(NEMU_GCC_WERR)
 ifdef NEMU_WITH_RUNPATH
  TEMPLATE_NemuR3Tool_LDFLAGS  = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)' $(TEMPLATE_NEMUR3EXE_LDFLAGS)
 else ifdef NEMU_WITH_RELATIVE_RUNPATH
  TEMPLATE_NemuR3Tool_LDFLAGS  = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)/..' $(TEMPLATE_NEMUR3EXE_LDFLAGS)
 endif
endif
TEMPLATE_NemuR3Tool_LIBS       = $(LIB_RUNTIME) $(TEMPLATE_NEMUR3EXE_LIBS)
if defined(NEMU_WITH_MORE_NT4_COMPAT_BINARIES) && "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.x86"
 TEMPLATE_NemuR3Tool_LIBS.x86  = \
 	$(PATH_STAGE_LIB)/RuntimeR3VccTricks2$(NEMU_SUFF_LIB) \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/oldnames.lib
endif

#
# Template for building R3 shared objects / DLLs with the 10.5 Mac OS X SDK.
# Identical to NEMUR3EXE, except for the DYLIB, the classic_linker and SDK bits.
#
TEMPLATE_NEMUR3OSX105  = Nemu Ring 3 SO/DLLs for OS X 10.5
TEMPLATE_NEMUR3OSX105_EXTENDS = NEMUR3EXE
TEMPLATE_NEMUR3OSX105_DEFS.darwin        = $(NEMU_DARWIN_DEF_SDK_10_5_DEFS) PIC
TEMPLATE_NEMUR3OSX105_CFLAGS.darwin      = $(NEMU_DARWIN_DEF_SDK_10_5_CFLAGS) -fno-common
TEMPLATE_NEMUR3OSX105_CXXFLAGS.darwin    = $(NEMU_DARWIN_DEF_SDK_10_5_CXXFLAGS)
TEMPLATE_NEMUR3OSX105_OBJCFLAGS.darwin   = $(NEMU_DARWIN_DEF_SDK_10_5_OBJCFLAGS)
TEMPLATE_NEMUR3OSX105_OBJCXXFLAGS.darwin = $(NEMU_DARWIN_DEF_SDK_10_5_OBJCFLAGS)
TEMPLATE_NEMUR3OSX105_LDFLAGS.darwin     = $(NEMU_DARWIN_DEF_SDK_10_5_LDFLAGS) \
	-read_only_relocs suppress \
	-current_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-compatibility_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)

#
# Template for building R3 shared objects / DLLs with the 10.7 Mac OS X SDK.
# Identical to NemuR3Dll, except for the DYLIB, the classic_linker and SDK bits.
#
TEMPLATE_NemuR3DllOsX107  = Nemu Ring 3 SO/DLLs for OS X 10.7
TEMPLATE_NemuR3DllOsX107_EXTENDS = NemuR3Dll
TEMPLATE_NemuR3DllOsX107_TOOL               = LLVMGXX42MACHO
TEMPLATE_NemuR3DllOsX107_DEFS.darwin        = $(NEMU_DARWIN_DEF_SDK_10_7_DEFS) PIC
TEMPLATE_NemuR3DllOsX107_CFLAGS.darwin      = $(NEMU_DARWIN_DEF_SDK_10_7_CFLAGS) -fno-common
TEMPLATE_NemuR3DllOsX107_CXXFLAGS.darwin    = $(NEMU_DARWIN_DEF_SDK_10_7_CXXFLAGS)
TEMPLATE_NemuR3DllOsX107_OBJCFLAGS.darwin   = $(NEMU_DARWIN_DEF_SDK_10_7_OBJCFLAGS)
TEMPLATE_NemuR3DllOsX107_OBJCXXFLAGS.darwin = $(NEMU_DARWIN_DEF_SDK_10_7_OBJCFLAGS)
TEMPLATE_NemuR3DllOsX107_LDFLAGS.darwin     = $(NEMU_DARWIN_DEF_SDK_10_7_LDFLAGS) \
	-current_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-compatibility_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)


#
# Ring-3 testcase, running automatically during the build.
# This is the NEMUR3EXE template only with a different install dir.
#
TEMPLATE_NEMUR3AUTOTST  = Nemu Ring 3 Testcase Exe
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NEMUR3AUTOTST_EXTENDS = NemuR3Static
 TEMPLATE_NEMUR3AUTOTST_LIBS    = $(NO_SUCH_VARIABLE)
else
 TEMPLATE_NEMUR3AUTOTST_EXTENDS = NEMUR3EXE
endif
TEMPLATE_NEMUR3AUTOTST_INST    = $(INST_TESTCASE)
if "$(KBUILD_TARGET)" == "win" && defined(NEMU_SIGNING_MODE)
 TEMPLATE_NEMUR3AUTOTST_POST_CMDS = $(NO_SUCH_VARIABLE)
 TEMPLATE_NEMUR3AUTOTST_LDFLAGS = $(filter-out -IntegrityCheck, $(TEMPLATE_NemuR3Static_LDFLAGS))
endif

#
# Ring-3 testcase.
# This is the NEMUR3EXE template only with a different install dir.
#
TEMPLATE_NEMUR3TSTEXE  = Nemu Ring 3 Testcase Exe
TEMPLATE_NEMUR3TSTEXE_EXTENDS = NEMUR3EXE
TEMPLATE_NEMUR3TSTEXE_INST    = $(INST_TESTCASE)
TEMPLATE_NEMUR3TSTEXE_LIBS    = $(LIB_RUNTIME) $(TEMPLATE_NEMUR3EXE_LIBS)
ifdef NEMU_WITH_RUNPATH
 TEMPLATE_NEMUR3TSTEXE_LDFLAGS = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)' $(TEMPLATE_NEMUR3EXE_LDFLAGS)
else ifdef NEMU_WITH_RELATIVE_RUNPATH
 TEMPLATE_NEMUR3TSTEXE_LDFLAGS = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)/..' $(TEMPLATE_NEMUR3EXE_LDFLAGS)
endif
if "$(KBUILD_TARGET)" == "win" && defined(NEMU_SIGNING_MODE)
 TEMPLATE_NEMUR3TSTEXE_POST_CMDS =
 TEMPLATE_NEMUR3TSTEXE_LDFLAGS = $(filter-out -IntegrityCheck, $(TEMPLATE_NEMUR3EXE_LDFLAGS))
endif
if defined(NEMU_WITH_MORE_NT4_COMPAT_BINARIES) && "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.x86"
 TEMPLATE_NEMUR3TSTEXE_POST_CMDS.win.x86 = $(if $(eq $(tool_do),LINK_LIBRARY),,$(NEMU_PE_SET_VERSION) $(out))
 TEMPLATE_NEMUR3TSTEXE_LIBS.x86 = \
 	$(PATH_STAGE_LIB)/RuntimeR3VccTricks2$(NEMU_SUFF_LIB) \
 	$(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/oldnames.lib
endif

#
# Ring-3 testcase (no -pedantic)
#
TEMPLATE_NEMUR3TSTNPEXE  = Nemu Ring 3 Testcase Exe Non-pedantic
TEMPLATE_NEMUR3TSTNPEXE_EXTENDS = NEMUR3TSTEXE
ifneq ($(KBUILD_TARGET),win) # (only gcc)
 TEMPLATE_NEMUR3TSTNPEXE_TOOL             = $(NEMU_GCC_TOOL)
 TEMPLATE_NEMUR3TSTNPEXE_CXXFLAGS         = $(filter-out -pedantic -Wshadow,$(TEMPLATE_NEMUR3TSTEXE_CXXFLAGS)) -Wno-sign-compare
 TEMPLATE_NEMUR3TSTNPEXE_CFLAGS           = $(filter-out -pedantic -Wshadow -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations,$(TEMPLATE_NEMUR3TSTEXE_CFLAGS)) -Wno-sign-compare
endif


#
# Ring-3 testcase DLL.
#
TEMPLATE_NemuR3TstDll = Nemu Ring-3 Testcase Dll
TEMPLATE_NemuR3TstDll_EXTENDS = NEMUR3TSTEXE
ifn1of ($(KBUILD_TARGET), darwin win os2)
 TEMPLATE_NemuR3TstDll_DEFS     = $(TEMPLATE_NEMUR3TSTEXE_DEFS) PIC
 TEMPLATE_NemuR3TstDll_CFLAGS   = $(TEMPLATE_NEMUR3TSTEXE_CFLAGS) -fPIC
 TEMPLATE_NemuR3TstDll_CXXFLAGS = $(TEMPLATE_NEMUR3TSTEXE_CXXFLAGS) -fPIC
 TEMPLATE_NemuR3TstDll_LDFLAGS  = $(TEMPLATE_NEMUR3TSTEXE_LDFLAGS) -fPIC
endif


#
# Template for the CppUnit kind of testcases.
#
TEMPLATE_NEMUCPPUNITEXE  = Nemu CppUnit Testcase Exe
TEMPLATE_NEMUCPPUNITEXE_EXTENDS = NEMUR3TSTEXE
## @todo make a CPPUNIT SDK and add cppunit tools packages for windows, mac, solaris and OS/2.
#TEMPLATE_NEMUCPPUNITEXE_SDKS = CPPUNIT -
TEMPLATE_NEMUCPPUNITEXE_LIBS = \
	$(TEMPLATE_NEMUR3TSTEXE_LIBS) \
	cppunit

#
# Template for building bad C/C++ style R3 executables (no -pedantic).
#
TEMPLATE_NEMUR3NPEXE                     = Nemu Ring 3 Non-pedantic
TEMPLATE_NEMUR3NPEXE_EXTENDS             = NEMUR3EXE
ifneq ($(KBUILD_TARGET),win) # (only gcc)
 TEMPLATE_NEMUR3NPEXE_TOOL               = $(NEMU_GCC_TOOL)
 TEMPLATE_NEMUR3NPEXE_CXXFLAGS           = $(filter-out -pedantic -Wshadow,$(TEMPLATE_NEMUR3EXE_CXXFLAGS)) -Wno-sign-compare
 TEMPLATE_NEMUR3NPEXE_CFLAGS             = $(filter-out -pedantic -Wshadow -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations,$(TEMPLATE_NEMUR3EXE_CFLAGS)) \
	-Wno-sign-compare -Werror-implicit-function-declaration
endif


#
# Template for building bad C/C++ style R3 shared libraries / Dlls (no -pedantic).
# (Same transformation as for NEMUR3NPEXE.)
#
# @deprecated Use NemuR3DllNonPedantic!
#
TEMPLATE_NEMUR3NP = Nemu Ring 3 Non-pedantic
TEMPLATE_NEMUR3NP_EXTENDS = NEMUR3
ifneq ($(KBUILD_TARGET),win) # (only gcc)
 TEMPLATE_NEMUR3NP_TOOL                  = $(NEMU_GCC_TOOL)
 TEMPLATE_NEMUR3NP_CXXFLAGS              = $(filter-out -pedantic -Wshadow,$(TEMPLATE_NEMUR3_CXXFLAGS)) -Wno-sign-compare
 TEMPLATE_NEMUR3NP_CFLAGS                = $(filter-out -pedantic -Wshadow -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations,$(TEMPLATE_NEMUR3_CFLAGS)) \
	-Wno-sign-compare -Werror-implicit-function-declaration
 TEMPLATE_NEMUR3NP_OBJCFLAGS             = $(filter-out -pedantic -Wstrict-prototypes,$(TEMPLATE_NEMUR3_OBJCFLAGS))
 TEMPLATE_NEMUR3NP_OBJCXXFLAGS           = $(filter-out -pedantic,$(TEMPLATE_NEMUR3_OBJCXXFLAGS))
endif


#
# Template for building bad C/C++ style R3 shared libraries / Dlls (no -pedantic).
# (Same transformation as for NemuR3ExeNonPedantic.)
#
TEMPLATE_NemuR3DllNonPedantic               = Nemu ring-3 Non-pedantic, with warnings.
TEMPLATE_NemuR3DllNonPedantic_EXTENDS       = NEMUR3
ifneq ($(KBUILD_TARGET),win) # (only gcc)
 TEMPLATE_NemuR3DllNonPedantic_TOOL         = $(NEMU_GCC_TOOL)
 TEMPLATE_NemuR3DllNonPedantic_CXXFLAGS     = $(filter-out -pedantic -Wshadow,$(TEMPLATE_NEMUR3_CXXFLAGS)) -Wno-sign-compare
 TEMPLATE_NemuR3DllNonPedantic_CFLAGS       = $(filter-out -pedantic -Wshadow -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations,$(TEMPLATE_NEMUR3_CFLAGS)) \
	-Wno-sign-compare -Werror-implicit-function-declaration
endif

# x86 edition of the above template for use on AMD64 targets.
TEMPLATE_NemuR3DllNonPedantic-x86           = 32-bit Nemu ring-3 SO/DLLs, no warnings
TEMPLATE_NemuR3DllNonPedantic-x86_EXTENDS   = NemuR3DllNonPedantic
TEMPLATE_NemuR3DllNonPedantic-x86_BLD_TRG_ARCH = x86
TEMPLATE_NemuR3DllNonPedantic-x86_DEFS      = $(filter-out HC_ARCH_BITS%,$(TEMPLATE_NemuR3Dll_DEFS)) \
	HC_ARCH_BITS=32 ARCH_BITS=32



#
# Template for building libraries that are linked into NemuRT.dll
# and it's variations, pedantic variation.
#
TEMPLATE_NemuR3RuntimeDll = For libraries that are linked into NemuRT.
TEMPLATE_NemuR3RuntimeDll_EXTENDS = NemuR3Dll
if defined(NEMU_WITH_MORE_NT4_COMPAT_BINARIES) && "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.x86"
 TEMPLATE_NemuR3RuntimeDll_CFLAGS   = $(filter-out -MD$(NEMU_VCC_CRT_TYPE), $(TEMPLATE_NemuR3Dll_CFLAGS)) -MT$(NEMU_VCC_CRT_TYPE)
 TEMPLATE_NemuR3RuntimeDll_CXXFLAGS = $(filter-out -MD$(NEMU_VCC_CRT_TYPE), $(TEMPLATE_NemuR3Dll_CXXFLAGS)) -MT$(NEMU_VCC_CRT_TYPE)
 TEMPLATE_NemuR3RuntimeDll_LIBS.x86 = $(filter-out $(PATH_TOOL_$(TEMPLATE_NEMUR3EXE_TOOL.win.x86)_LIB)/%, $(TEMPLATE_NemuR3Dll_LIBS.x86)) \
 	$(PATH_TOOL_$(TEMPLATE_NemuR3RuntimeDll_TOOL.win.x86)_LIB)/oldnames.lib \
 	$(PATH_TOOL_$(TEMPLATE_NemuR3RuntimeDll_TOOL.win.x86)_LIB)/libcmt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NemuR3RuntimeDll_TOOL.win.x86)_LIB)/libcpmt$(NEMU_VCC_CRT_TYPE).lib
endif

#
# Template for building libraries that are linked into NemuRT.dll
# and it's variations, non-pedantic variation.
#
TEMPLATE_NemuR3RuntimeDllNonPedantic = For libraries that are linked into NemuRT, but must be excluded from -pedantic warnings.
TEMPLATE_NemuR3RuntimeDllNonPedantic_EXTENDS = NemuR3DllNonPedantic
if defined(NEMU_WITH_MORE_NT4_COMPAT_BINARIES) && $(KBUILD_TARGET_ARCH) == "x86"
 TEMPLATE_NemuR3RuntimeDllNonPedantic_CFLAGS   = $(filter-out -MD$(NEMU_VCC_CRT_TYPE), $(TEMPLATE_NemuR3DllNonPedantic_CFLAGS)) -MT$(NEMU_VCC_CRT_TYPE)
 TEMPLATE_NemuR3RuntimeDllNonPedantic_CXXFLAGS = $(filter-out -MD$(NEMU_VCC_CRT_TYPE), $(TEMPLATE_NemuR3DllNonPedantic_CXXFLAGS)) -MT$(NEMU_VCC_CRT_TYPE)
endif


#
# Template for building libraries, shared libraries / modules
# which only depends on IPRT for crt.
#
TEMPLATE_NemuNoCrtGccLib = Nemu no-crt GCC libraries and modules, yasm/nasm.
TEMPLATE_NemuNoCrtGccLib_DEFS              = IN_RING3 IPRT_NO_CRT $(ARCH_BITS_DEFS)
TEMPLATE_NemuNoCrtGccLib_ASDEFS            = ASM_CALL64_GCC
TEMPLATE_NemuNoCrtGccLib_CFLAGS            = -nostdinc -fno-strict-aliasing -fno-math-errno $(NEMU_GCC_WARN) -Werror-implicit-function-declaration
TEMPLATE_NemuNoCrtGccLib_CFLAGS.x86        = -m32
TEMPLATE_NemuNoCrtGccLib_CFLAGS.amd64      = -m64 -mcmodel=medium -fno-common
TEMPLATE_NemuNoCrtGccLib_CFLAGS.sparc32    = -m32
TEMPLATE_NemuNoCrtGccLib_CFLAGS.sparc64    = -m64
TEMPLATE_NemuNoCrtGccLib_CFLAGS.release    = -O2 -fno-strict-aliasing
TEMPLATE_NemuNoCrtGccLib_CFLAGS.profile    = $(TEMPLATE_NemuNoCrtGccLib_CFLAGS.release)
TEMPLATE_NemuNoCrtGccLib_CFLAGS.kprofile   = $(TEMPLATE_NemuNoCrtGccLib_CFLAGS.release)
TEMPLATE_NemuNoCrtGccLib_CFLAGS.darwin     = -static
TEMPLATE_NemuNoCrtGccLib_CXXFLAGS          = $(TEMPLATE_NemuNoCrtGccLib_CFLAGS)
TEMPLATE_NemuNoCrtGccLib_CXXFLAGS.$(KBUILD_TARGET) = $(TEMPLATE_NemuNoCrtGccLib_CFLAGS.$(KBUILD_TARGET))
TEMPLATE_NemuNoCrtGccLib_CXXFLAGS.$(KBUILD_TARGET_ARCH) = $(TEMPLATE_NemuNoCrtGccLib_CFLAGS.$(KBUILD_TARGET_ARCH))
TEMPLATE_NemuNoCrtGccLib_INCS              = $(PATH_ROOT)/include/iprt/nocrt

ifeq (disabled-by-mingw-w64 $(KBUILD_TARGET).$(KBUILD_TARGET_ARCH),win.amd64)
 # cross compile to 64-bit ELF (linux).
 TEMPLATE_NemuNoCrtGccLib_TOOL             = XGCCAMD64LINUX
 TEMPLATE_NemuNoCrtGccLib_ASTOOL           = YASM
 TEMPLATE_NemuNoCrtGccLib_ASFLAGS          = -f elf64 -DASM_FORMAT_ELF -D__YASM__ -w+orphan-labels -g dwarf2
 TEMPLATE_NemuNoCrtGccLib_LIBS             = $(KBUILD_DEVTOOLS)/win.x86/x86_64-unknown-linux-gnu/20060701-r2/lib/gcc/x86_64-unknown-linux-gnu/3.4.6/libgcc.a
 TEMPLATE_NemuNoCrtGccLib_LDFLAGS          = -nostdlib

else if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), win.x86 win.amd64)
 # Use the default GCC (MinGW) with the Microsoft linker.
 # (Drop all '-g' options as we're unable to strip the debug info.)
 TEMPLATE_NemuNoCrtGccLib_TOOL             = $(NEMU_GCC_TOOL)
 TEMPLATE_NemuNoCrtGccLib_ASTOOL           = $(NEMU_ASTOOL)
 TEMPLATE_NemuNoCrtGccLib_ASFLAGS          = $(NEMU_ASFLAGS)
 TEMPLATE_NemuNoCrtGccLib_LDTOOL           = $(NEMU_VCC_TOOL)
 TEMPLATE_NemuNoCrtGccLib_LDFLAGS          = -Incremental:NO -MapInfo:Exports -NoD -Ignore:4197
 TEMPLATE_NemuNoCrtGccLib_LIBS             = $(NEMU_GCC_LIBGCC)
 TEMPLATE_NemuNoCrtGccLib_CFLAGS          := $(filter-out -g,$(TEMPLATE_NemuNoCrtGccLib_CFLAGS)) -s
 TEMPLATE_NemuNoCrtGccLib_CXXFLAGS        := $(filter-out -g,$(TEMPLATE_NemuNoCrtGccLib_CXXFLAGS)) -s

else
 # Use the default GCC.
 # The use of --exclude-libs ALL is to avoid confusing the linux ld.so.
 TEMPLATE_NemuNoCrtGccLib_TOOL             = $(NEMU_GCC_TOOL)
 TEMPLATE_NemuNoCrtGccLib_ASTOOL           = $(NEMU_ASTOOL)
 TEMPLATE_NemuNoCrtGccLib_ASFLAGS          = $(NEMU_ASFLAGS)
 TEMPLATE_NemuNoCrtGccLib_CFLAGS          += $(NEMU_GCC_fno-stack-protector)
 TEMPLATE_NemuNoCrtGccLib_CXXFLAGS        += $(NEMU_GCC_fno-stack-protector)
 ifeq ($(KBUILD_TARGET_ARCH),amd64)
  # in 64-bit mode we'll build a sys-module (NemuREM2).
  if1of ($(KBUILD_TARGET), darwin solaris)
   TEMPLATE_NemuNoCrtGccLib_LDFLAGS.solaris= -64 -r
  else
   TEMPLATE_NemuNoCrtGccLib_LDFLAGS        = -nostdlib
  endif
 else # x86:
  TEMPLATE_NemuNoCrtGccLib_LDFLAGS         = -nostdlib
  ifn1of ($(KBUILD_TARGET), os2 darwin solaris)
   TEMPLATE_NemuNoCrtGccLib_LDFLAGS       += -Wl,--no-undefined
  endif
 endif # x86
 TEMPLATE_NemuNoCrtGccLib_LDFLAGS.darwin   = $(NEMU_DARWIN_DEF_SDK_LDFLAGS)
 TEMPLATE_NemuNoCrtGccLib_LIBS             = # FIXME - has unwind mess.
endif


#
# Same as NemuNoCrtGccLib only it uses GAS as the assembler instead of yasm/nasm.
#
TEMPLATE_NEMUNOCRTGAS = Nemu no-crt GCC libraries and modules, gas.
TEMPLATE_NEMUNOCRTGAS_EXTENDS = NemuNoCrtGccLib
TEMPLATE_NEMUNOCRTGAS_ASTOOL = $(TEMPLATE_NemuNoCrtGccLib_TOOL)
ifeq ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH),win.x86)
 TEMPLATE_NEMUNOCRTGAS_ASFLAGS = -s
else
 TEMPLATE_NEMUNOCRTGAS_ASFLAGS = -g
endif
TEMPLATE_NEMUNOCRTGAS_ASFLAGS.x86 = -m32
TEMPLATE_NEMUNOCRTGAS_ASFLAGS.amd64 = -m64


#
# Template for building executables that are part of the Nemu Main component
# (COM/XPCOM interface to VirtualBox).
#
TEMPLATE_NEMUMAINEXE         = Nemu Main Executable
TEMPLATE_NEMUMAINEXE_ASTOOL              = $(NEMU_ASTOOL)
TEMPLATE_NEMUMAINEXE_ASFLAGS             = $(NEMU_ASFLAGS)
TEMPLATE_NEMUMAINEXE_DEFS                = IN_RING3 UNICODE NDEBUG=1
TEMPLATE_NEMUMAINEXE_DEFS.win            = _UNICODE
TEMPLATE_NEMUMAINEXE_RCDEFS              = $(TEMPLATE_NEMUR3EXE_RCDEFS)
TEMPLATE_NEMUMAINEXE_LIBS.kprofile       = $(LIB_KPROFILE)
TEMPLATE_NEMUMAINEXE_USES                = dtrace
if defined(NEMU_WITH_DTRACE_R3_MAIN) && defined(NEMU_WITH_NATIVE_DTRACE)
 TEMPLATE_NEMUMAINEXE_DTRACETOOL         = DTraceAndNemuTpG
 TEMPLATE_NEMUMAINEXE_DTRACE_OBJ_FLAGS   = -C
 TEMPLATE_NEMUMAINEXE_DTRACE_HDR_FLAGS   = -C
 TEMPLATE_NEMUMAINEXE_DEFS              += NEMU_WITH_DTRACE NEMU_WITH_DTRACE_R3 NEMU_WITH_DTRACE_R3_MAIN NEMU_WITH_NATIVE_DTRACE
else
  TEMPLATE_NEMUMAINEXE_DTRACE_HDR_FLAGS  = --ring-3-context
  TEMPLATE_NEMUMAINEXE_DTRACE_OBJ_FLAGS  = --ring-3-context --pic --probe-fn-imported --probe-fn-name "SUPTracerFireProbe"
 if defined(NEMU_WITH_DTRACE_R3_MAIN)
  TEMPLATE_NEMUMAINEXE_DTRACETOOL        = NemuTpG
  TEMPLATE_NEMUMAINEXE_DEFS             += NEMU_WITH_DTRACE NEMU_WITH_DTRACE_R3 NEMU_WITH_DTRACE_R3_MAIN
 else
  TEMPLATE_NEMUMAINEXE_DTRACETOOL        = NemuTpG-Disabled
 endif
endif

ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NEMUMAINEXE_SDKS               = ReorderCompilerIncs $(NEMU_WINPSDK) $(NEMU_WINDDK)
 # Note: C4250 is the dominance warning, see r32789.
 #       C4065 is about default only switches.
 #       C4996 is about deprected function (CRT only?).
 #TEMPLATE_NEMUMAINEXE_TOOL               = $(NEMU_VCC_TOOL)
 TEMPLATE_NEMUMAINEXE_TOOL.win.x86       = $(NEMU_VCC_TOOL_STEM)X86
 TEMPLATE_NEMUMAINEXE_TOOL.win.amd64     = $(NEMU_VCC_TOOL_STEM)AMD64
 TEMPLATE_NEMUMAINEXE_CXXFLAGS           = -Zi -Zl -GR -EHsc -GF -MD$(NEMU_VCC_CRT_TYPE) -W3 -wd4065 -wd4996 -wd4250 -Zc:wchar_t- $(NEMU_VCC_OPT) $(NEMU_VCC_FP)
 TEMPLATE_NEMUMAINEXE_CXXFLAGS.debug     = -RTCsu
 TEMPLATE_NEMUMAINEXE_CXXFLAGS.dbgopt    = $(NO_SUCH_VARIABLE)
 TEMPLATE_NEMUMAINEXE_CXXFLAGS.kprofile  = -Gh -GH
 TEMPLATE_NEMUMAINEXE_CFLAGS             = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS)
 TEMPLATE_NEMUMAINEXE_CFLAGS.debug       = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS.debug)
 TEMPLATE_NEMUMAINEXE_CFLAGS.dbgopt      = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS.dbgopt)
 TEMPLATE_NEMUMAINEXE_CFLAGS.kprofile    = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS.kprofile)
 TEMPLATE_NEMUMAINEXE_LDFLAGS            = -Ignore:4197 \
	/NOD /INCREMENTAL:NO /MAPINFO:EXPORTS /LargeAddressAware /DynamicBase /NxCompat /Release /Debug \
	/Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	/STUB:$(PATH_ROOT)/src/Nemu/HostDrivers/Support/win/winstub.com \
	/DISALLOWLIB:libc.lib \
	/DISALLOWLIB:libcd.lib \
	/DISALLOWLIB:libcmt.lib \
	/DISALLOWLIB:libcmtd.lib \
	/DISALLOWLIB:msvcrt$(NEMU_VCC_CRT_TYPE_N).lib \
	/DISALLOWLIB:msvcprt$(NEMU_VCC_CRT_TYPE_N).lib
 if defined(NEMU_SIGNING_MODE) && defined(NEMU_WITH_HARDENING)
  TEMPLATE_NEMUMAINEXE_LDFLAGS          += -IntegrityCheck
 endif
 ifdef NEMU_WITH_DTRACE_R3_MAIN
  TEMPLATE_NEMUMAINEXE_LDFLAGS          += -Merge:VTGPrLc.Data=VTGPrLc.Begin -Merge:VTGPrLc.End=VTGPrLc.Begin -Merge:VTGPrLc.Begin=VTGObj
 endif
 TEMPLATE_NEMUMAINEXE_LIBS               = \
	$(LIB_RUNTIME)
 TEMPLATE_NEMUMAINEXE_LIBS.x86           = \
	$(PATH_TOOL_$(TEMPLATE_NEMUMAINEXE_TOOL.win.x86)_LIB)/msvcrt$(NEMU_VCC_CRT_TYPE).lib \
	$(PATH_TOOL_$(TEMPLATE_NEMUMAINEXE_TOOL.win.x86)_LIB)/msvcprt$(NEMU_VCC_CRT_TYPE).lib \
	$(PATH_TOOL_$(TEMPLATE_NEMUMAINEXE_TOOL.win.x86)_LIB)/oldnames.lib \
	$(PATH_TOOL_$(TEMPLATE_NEMUMAINEXE_TOOL.win.x86)_ATLMFC_LIB)/atls$(NEMU_VCC_CRT_TYPE).lib
 TEMPLATE_NEMUMAINEXE_LIBS.amd64         = \
	$(PATH_TOOL_$(TEMPLATE_NEMUMAINEXE_TOOL.win.amd64)_LIB)/msvcrt$(NEMU_VCC_CRT_TYPE).lib \
	$(PATH_TOOL_$(TEMPLATE_NEMUMAINEXE_TOOL.win.amd64)_LIB)/msvcprt$(NEMU_VCC_CRT_TYPE).lib \
	$(PATH_TOOL_$(TEMPLATE_NEMUMAINEXE_TOOL.win.amd64)_LIB)/oldnames.lib \
	$(PATH_TOOL_$(TEMPLATE_NEMUMAINEXE_TOOL.win.amd64)_ATLMFC_LIB)/atls$(NEMU_VCC_CRT_TYPE).lib
 TEMPLATE_NEMUMAINEXE_POST_CMDS          = $(NEMU_SIGN_IMAGE_CMDS)

else # the GCC guys:

TEMPLATE_NEMUMAINEXE_TOOL                = $(NEMU_GCC_TOOL)
TEMPLATE_NEMUMAINEXE_CXXFLAGS            = -g $(NEMU_GCC_pipe) \
	$(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC_Wno-variadic-macros) -Wno-long-long -Wno-non-virtual-dtor -Wshadow \
	-fshort-wchar -fpermissive -fexceptions -frtti $(NEMU_GCC_OPT) $(NEMU_GCC_FP) -fno-strict-aliasing \
	$(NEMU_GCC_fvisibility-inlines-hidden) $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_std) $(NEMU_GCC_IPRT_FMT_CHECK)
ifdef NEMU_WITH_DTRACE_R3_MAIN
 TEMPLATE_NEMUMAINEXE_CXXFLAGS := $(filter-out -pedantic,$(TEMPLATE_NEMUMAINEXE_CXXFLAGS)) -fdollars-in-identifiers # annoying gcc option precedence.
endif
TEMPLATE_NEMUMAINEXE_CXXFLAGS.x86        = -m32
TEMPLATE_NEMUMAINEXE_CXXFLAGS.amd64      = -m64
TEMPLATE_NEMUMAINEXE_CXXFLAGS.kprofile   = -finstrument-functions
TEMPLATE_NEMUMAINEXE_CFLAGS              = -g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_C) $(NEMU_GCC_Wno-variadic-macros) \
	$(NEMU_GCC_OPT) $(NEMU_GCC_FP) -fno-strict-aliasing $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_IPRT_FMT_CHECK)
TEMPLATE_NEMUMAINEXE_CFLAGS.x86          = -m32
TEMPLATE_NEMUMAINEXE_CFLAGS.amd64        = -m64
TEMPLATE_NEMUMAINEXE_CFLAGS.kprofile     = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS.kprofile)
TEMPLATE_NEMUMAINEXE_OBJCFLAGS           = $(TEMPLATE_NEMUMAINEXE_CFLAGS)
TEMPLATE_NEMUMAINEXE_OBJCFLAGS.x86       = $(TEMPLATE_NEMUMAINEXE_CFLAGS.x86)
TEMPLATE_NEMUMAINEXE_OBJCFLAGS.amd64     = $(TEMPLATE_NEMUMAINEXE_CFLAGS.amd64)
TEMPLATE_NEMUMAINEXE_OBJCFLAGS.kprofile  = $(TEMPLATE_NEMUMAINEXE_CFLAGS.kprofile)
TEMPLATE_NEMUMAINEXE_OBJCXXFLAGS         = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS)
TEMPLATE_NEMUMAINEXE_OBJCXXFLAGS.x86     = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS.x86)
TEMPLATE_NEMUMAINEXE_OBJCXXFLAGS.amd64   = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS.amd64)
TEMPLATE_NEMUMAINEXE_OBJCXXFLAGS.kprofile= $(TEMPLATE_NEMUMAINEXE_CXXFLAGS.kprofile)
TEMPLATE_NEMUMAINEXE_LDFLAGS.x86         = -m32
TEMPLATE_NEMUMAINEXE_LDFLAGS.amd64       = -m64
 ifeq ($(KBUILD_TARGET),linux)
TEMPLATE_NEMUMAINEXE_LIBS                = pthread m rt $(LIB_RUNTIME) dl
TEMPLATE_NEMUMAINEXE_LDFLAGS.linux       = -Wl,-z,noexecstack,-z,relro $(NEMU_LD_as_needed)
 else ifeq ($(KBUILD_TARGET),os2)
TEMPLATE_NEMUMAINEXE_TOOL                = GXX3OMF
TEMPLATE_NEMUMAINEXE_LIBS                = $(LIB_RUNTIME)
 else ifeq ($(KBUILD_TARGET),darwin)
TEMPLATE_NEMUMAINEXE_TOOL                = GXX4MACHO
TEMPLATE_NEMUMAINEXE_DEFS               += $(NEMU_DARWIN_DEF_SDK_DEFS)
TEMPLATE_NEMUMAINEXE_CFLAGS             += $(NEMU_DARWIN_DEF_SDK_CFLAGS)
TEMPLATE_NEMUMAINEXE_CXXFLAGS           += $(NEMU_DARWIN_DEF_SDK_CXXFLAGS)
TEMPLATE_NEMUMAINEXE_OBJCFLAGS          += $(NEMU_DARWIN_DEF_SDK_OBJCFLAGS)
TEMPLATE_NEMUMAINEXE_OBJCXXFLAGS        += $(NEMU_DARWIN_DEF_SDK_OBJCXXFLAGS)
TEMPLATE_NEMUMAINEXE_LDFLAGS.darwin     += -bind_at_load
TEMPLATE_NEMUMAINEXE_LDFLAGS            += $(NEMU_DARWIN_DEF_SDK_LDFLAGS) -framework Carbon
TEMPLATE_NEMUMAINEXE_LIBS                = $(LIB_RUNTIME)
 else ifeq ($(KBUILD_TARGET),haiku)
TEMPLATE_NEMUMAINEXE_TOOL                = GXX3
TEMPLATE_NEMUMAINEXE_LIBS                = $(LIB_RUNTIME) network stdc++ supc++
 else if1of ($(KBUILD_TARGET), freebsd netbsd openbsd)
TEMPLATE_NEMUMAINEXE_TOOL                = GXX3
TEMPLATE_NEMUMAINEXE_LIBS                = $(LIB_RUNTIME)
TEMPLATE_NEMUMAINEXE_INCS               += \
	/usr/include \
	/usr/X11R6/include \
	/usr/local/include
TEMPLATE_NEMUMAINEXE_LIBPATH            += \
	/usr/lib \
	/usr/X11R6/lib \
	/usr/local/lib
else ifeq ($(KBUILD_TARGET),solaris)
TEMPLATE_NEMUMAINEXE_TOOL                = GXX3PLAIN
TEMPLATE_NEMUMAINEXE_DEFS               += _REENTRANT
TEMPLATE_NEMUMAINEXE_LIBS                = $(LIB_RUNTIME) rt thread
 else
$(warning Warning: NEMU Build: Target $(KBUILD_TARGET) is not officially supported!)
TEMPLATE_NEMUMAINEXE_LIBS                =
 endif
TEMPLATE_NEMUMAINEXE_LDFLAGS.solaris     = -Wl,-z,ignore # Same as NEMU_LD_as_needed.
 ifdef NEMU_WITH_RUNPATH
TEMPLATE_NEMUMAINEXE_LDFLAGS            += '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)'
 else ifdef NEMU_WITH_RELATIVE_RUNPATH
TEMPLATE_NEMUMAINEXE_LDFLAGS            += '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)'
 endif
 ifdef NEMU_WITH_ORIGIN
TEMPLATE_NEMUMAINEXE_LDFLAGS.linux      += $(NEMU_GCC_ORIGIN_OPT)
 endif

endif # !win

# Add COM/XPCOM stuff
TEMPLATE_NEMUMAINEXE_LIBS               += \
	$(PATH_STAGE_LIB)/NemuCOM$(NEMU_SUFF_LIB)
ifdef NEMU_WITH_XPCOM
 ## @todo may be worth creating the NEMU_XPCOM SDK def
 TEMPLATE_NEMUMAINEXE_DEFS              += NEMU_WITH_XPCOM
 ifdef NEMU_WITH_XPCOM_NAMESPACE_CLEANUP
  TEMPLATE_NEMUMAINEXE_DEFS             += NEMU_WITH_XPCOM_NAMESPACE_CLEANUP
 endif
 TEMPLATE_NEMUMAINEXE_INCS              += \
	$(NEMU_XPCOM_INCS)
 TEMPLATE_NEMUMAINEXE_LIBS              += \
	$(LIB_XPCOM)
 TEMPLATE_NEMUMAINEXE_INTERMEDIATES     += \
	$(NEMU_PATH_SDK)/bindings/xpcom/include/VirtualBox_XPCOM.h

else  # COM
 TEMPLATE_NEMUMAINEXE_INCS              += \
	$(NEMU_PATH_SDK)/bindings/mscom/include
 TEMPLATE_NEMUMAINEXE_INTERMEDIATES     += \
	$(NEMU_PATH_SDK)/bindings/mscom/include/VirtualBox.h
endif # COM

#
# Template for building the Main DLL modules (such as in-process COM/XPCOM
# components for Main).
#
# This differs from NEMUMAINEXE only in PIC handling and similar DLL stuff.
#
TEMPLATE_NEMUMAINDLL  = Nemu Main Component (shared library)
TEMPLATE_NEMUMAINDLL_EXTENDS = NEMUMAINEXE
ifn1of ($(KBUILD_TARGET), darwin haiku os2 win)
 TEMPLATE_NEMUMAINDLL_DEFS     = PIC $(TEMPLATE_NEMUMAINEXE_DEFS)
 TEMPLATE_NEMUMAINDLL_CFLAGS   = -fPIC $(TEMPLATE_NEMUMAINEXE_CFLAGS)
 TEMPLATE_NEMUMAINDLL_CXXFLAGS = -fPIC $(TEMPLATE_NEMUMAINEXE_CXXFLAGS)
 TEMPLATE_NEMUMAINDLL_LDFLAGS  = -fPIC $(TEMPLATE_NEMUMAINEXE_LDFLAGS)
endif
TEMPLATE_NEMUMAINDLL_LDFLAGS.darwin = $(filter-out -bind_at_load,$(TEMPLATE_NEMUMAINEXE_LDFLAGS.darwin)) \
	-current_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-compatibility_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)

#
# Template identical to NEMUMAINDLL except for where the stuff is
# installed when using XPCOM (components/).
#
# Note! In the hardened build this gets a bit ugly since $ORIGIN/..
#       doesn't work. So, we keep the $ORIGIN from NEMUMAINEXE and let
#       the installers do the necessary .so symlinking.
#
# (No difference when building against COM on Windows.)
#
TEMPLATE_NEMUMAINCOMP            = Nemu Main COM/XPCOM Component (shared library)
TEMPLATE_NEMUMAINCOMP_EXTENDS    = NEMUMAINEXE
ifn1of ($(KBUILD_TARGET), win)
 TEMPLATE_NEMUMAINCOMP_INST      = $(INST_BIN)components/
endif
ifneq ($(KBUILD_TARGET),win)
 ifeq ($(filter-out solaris.x86 %.amd64 %.sparc32 %.sparc64,$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)),) ## TODO: cleanup!
  TEMPLATE_NEMUMAINCOMP_DEFS     = PIC $(TEMPLATE_NEMUMAINEXE_DEFS)
  TEMPLATE_NEMUMAINCOMP_CFLAGS   = -fPIC $(TEMPLATE_NEMUMAINEXE_CFLAGS)
  TEMPLATE_NEMUMAINCOMP_CXXFLAGS = -fPIC $(TEMPLATE_NEMUMAINEXE_CXXFLAGS)
  if defined(NEMU_WITH_RELATIVE_RUNPATH) && !defined(NEMU_WITH_HARDENING)
   TEMPLATE_NEMUMAINCOMP_LDFLAGS = -fPIC $(filter-out '$(NEMU_GCC_RPATH_OPT)%',$(TEMPLATE_NEMUMAINEXE_LDFLAGS)) '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)/..'
  else
   TEMPLATE_NEMUMAINCOMP_LDFLAGS = -fPIC $(TEMPLATE_NEMUMAINEXE_LDFLAGS)
  endif
 else ifndef NEMU_WITH_HARDENING
  ifdef NEMU_WITH_RELATIVE_RUNPATH
   TEMPLATE_NEMUMAINCOMP_LDFLAGS = $(filter-out '$(NEMU_GCC_RPATH_OPT)%',$(TEMPLATE_NEMUMAINEXE_LDFLAGS)) '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)/..'
  endif
 endif
endif
TEMPLATE_NEMUMAINCOMP_LDFLAGS.darwin = $(filter-out -bind_at_load,$(TEMPLATE_NEMUMAINEXE_LDFLAGS.darwin)) \
	-current_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-compatibility_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)

TEMPLATE_NemuMainComp-x86  = 32-bit Nemu Main Component (shared library)
TEMPLATE_NemuMainComp-x86_EXTENDS = NEMUMAINCOMP
TEMPLATE_NemuMainComp-x86_BLD_TRG_ARCH = x86
TEMPLATE_NemuMainComp-x86_DEFS = $(filter-out HC_ARCH_BITS%,$(TEMPLATE_NEMUMAINCOMP_DEFS)) HC_ARCH_BIT=32 ARCH_BITS=32 \
	NEMU_IN_32_ON_64_MAIN_API
TEMPLATE_NemuMainComp-x86_LIBS = \
	$(subst $(PATH_STAGE_LIB)/NemuCOM$(NEMU_SUFF_LIB),$(PATH_STAGE_LIB)/NemuCOM-x86$(NEMU_SUFF_LIB),\
	$(subst $(LIB_RUNTIME),$(NEMU_LIB_RUNTIME_X86),\
	$(subst $(LIB_XPCOM),$(NEMU_LIB_XPCOM_X86),\
	$(TEMPLATE_NEMUMAINCOMP_LIBS))))


#
# Template for building the Main static libraries.
#
# This differs from NEMUMAINDLL only that it zeroes out the _LIBS definition.
#
TEMPLATE_NemuMainLib  = Nemu Main Component (static library)
TEMPLATE_NemuMainLib_EXTENDS = NEMUMAINDLL
TEMPLATE_NemuMainLib_LIBS =

TEMPLATE_NemuMainLib-x86  = 32-bit Nemu Main Component (static library)
TEMPLATE_NemuMainLib-x86_EXTENDS = NemuMainLib
TEMPLATE_NemuMainLib-x86_BLD_TRG_ARCH = x86
TEMPLATE_NemuMainLib-x86_DEFS = $(filter-out HC_ARCH_BITS%,$(TEMPLATE_NemuMainLib_DEFS)) HC_ARCH_BIT=32 ARCH_BITS=32 \
	NEMU_IN_32_ON_64_MAIN_API

#
# Main unit testing, for compiling API implementation files into a testcase.
# This is the NEMUMAINEXE template only with a different install dir.
#
TEMPLATE_NEMUMAINTSTEXE  = Nemu Main Testcase Exe
TEMPLATE_NEMUMAINTSTEXE_EXTENDS = NEMUMAINEXE
TEMPLATE_NEMUMAINTSTEXE_INST    = $(INST_TESTCASE)
ifdef NEMU_WITH_RUNPATH
 TEMPLATE_NEMUMAINTSTEXE_LDFLAGS = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)' $(TEMPLATE_NEMUMAINEXE_LDFLAGS)
else ifdef NEMU_WITH_RELATIVE_RUNPATH
 TEMPLATE_NEMUMAINTSTEXE_LDFLAGS = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)/..' $(TEMPLATE_NEMUMAINEXE_LDFLAGS)
endif
if "$(KBUILD_TARGET)" == "win" && defined(NEMU_SIGNING_MODE)
 TEMPLATE_NEMUMAINTSTEXE_POST_CMDS =
endif

#
# Template for building executables that use the Nemu Main component.
#
TEMPLATE_NEMUMAINCLIENTEXE              = Nemu Main Client (executable)
TEMPLATE_NEMUMAINCLIENTEXE_EXTENDS      = NEMUMAINEXE
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NEMUMAINCLIENTEXE_DEPS		= $(NEMU_PATH_SDK)/bindings/mscom/include/VirtualBox.h
 TEMPLATE_NEMUMAINCLIENTEXE_LIBS.win	= $(TEMPLATE_NEMUMAINEXE_LIBS.win) \
   $(PATH_SDK_$(NEMU_WINPSDK)_LIB)/User32.Lib \
   $(PATH_SDK_$(NEMU_WINPSDK)_LIB)/Shell32.Lib \
   $(PATH_SDK_$(NEMU_WINPSDK)_LIB)/ShLwApi.Lib \
   $(PATH_SDK_$(NEMU_WINPSDK)_LIB)/Ole32.Lib \
   $(PATH_SDK_$(NEMU_WINPSDK)_LIB)/OleAut32.Lib \
   $(PATH_SDK_$(NEMU_WINPSDK)_LIB)/Uuid.Lib
else
 TEMPLATE_NEMUMAINCLIENTEXE_DEPS		= $(NEMU_PATH_SDK)/bindings/xpcom/include/VirtualBox_XPCOM.h
 TEMPLATE_NEMUMAINCLIENTEXE_DEFS		= $(TEMPLATE_NEMUMAINEXE_DEFS) \
	NDEBUG TRIMMED
 TEMPLATE_NEMUMAINCLIENTEXE_CXXFLAGS.linux = $(TEMPLATE_NEMUMAINEXE_CXXFLAGS.linux) \
	-pthread
endif

#
# Template for building shared libraries / DLLs that use the Nemu Main component.
#
# This differs from NEMUMAINCLIENTEXE only in PIC handling and similar DLL stuff.
#
TEMPLATE_NEMUMAINCLIENTDLL              = Nemu MAIN Client (shared library)
TEMPLATE_NEMUMAINCLIENTDLL_EXTENDS      = NEMUMAINCLIENTEXE
ifn1of ($(KBUILD_TARGET), darwin os2 win)
 TEMPLATE_NEMUMAINCLIENTDLL_DEFS        = PIC $(TEMPLATE_NEMUMAINCLIENTEXE_DEFS)
 TEMPLATE_NEMUMAINCLIENTDLL_CFLAGS      = -fPIC $(TEMPLATE_NEMUMAINCLIENTEXE_CFLAGS)
 TEMPLATE_NEMUMAINCLIENTDLL_CXXFLAGS    = -fPIC $(TEMPLATE_NEMUMAINCLIENTEXE_CXXFLAGS)
 TEMPLATE_NEMUMAINCLIENTDLL_LDFLAGS     = -fPIC $(TEMPLATE_NEMUMAINCLIENTEXE_LDFLAGS)
endif
TEMPLATE_NEMUMAINCLIENTDLL_LDFLAGS.darwin = $(filter-out -bind_at_load,$(TEMPLATE_NEMUMAINCLIENTEXE_LDFLAGS.darwin))

#
# Template for building testcases which are API clients.
#
TEMPLATE_NEMUMAINCLIENTTSTEXE           = Nemu Main Client Testcase (executable)
TEMPLATE_NEMUMAINCLIENTTSTEXE_EXTENDS   = NEMUMAINCLIENTEXE
TEMPLATE_NEMUMAINCLIENTTSTEXE_INST      = $(INST_TESTCASE)
ifdef NEMU_WITH_RUNPATH
 TEMPLATE_NEMUMAINCLIENTTSTEXE_LDFLAGS = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)' $(TEMPLATE_NEMUMAINCLIENTEXE_LDFLAGS)
else ifdef NEMU_WITH_RELATIVE_RUNPATH
 TEMPLATE_NEMUMAINCLIENTTSTEXE_LDFLAGS = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)/..' $(TEMPLATE_NEMUMAINCLIENTEXE_LDFLAGS)
endif
if "$(KBUILD_TARGET)" == "win" && defined(NEMU_SIGNING_MODE)
 TEMPLATE_NEMUMAINCLIENTTSTEXE_POST_CMDS =
endif



#
# Templates used for building the extension packs.
#
ifdef NEMU_WITH_EXTPACK
 # Base templates (native or portable).
 TEMPLATE_NemuR3ExtPack = For the ring-3 context extension pack modules.
 if 1 # Native for now.
  TEMPLATE_NemuR3ExtPack_EXTENDS = NEMUR3DLLNOXCPT
  TEMPLATE_NemuR3ExtPack_DEFS = $(TEMPLATE_NEMUR3DLLNOXCPT_DEFS) NEMU_IN_EXTPACK NEMU_IN_EXTPACK_R3
 else
  TEMPLATE_NemuR3ExtPack_EXTENDS = NemuNoCrtGccLib
  TEMPLATE_NemuR3ExtPack_DEFS = $(TEMPLATE_NemuNoCrtGccLib_DEFS) NEMU_IN_EXTPACK NEMU_IN_EXTPACK_R3 IPRT_NO_CRT IN_RING3
  TEMPLATE_NemuR3ExtPack_INCS = $(PATH_ROOT)/include/iprt/nocrt $(TEMPLATE_NEMUR3DLLNOXCPT_INCS)
 endif
 ifneq ($(KBUILD_TARGET),win)
  TEMPLATE_NemuR3ExtPack_CXXFLAGS = $(TEMPLATE_NEMUR3DLLNOXCPT_CXXFLAGS) -fno-rtti
 endif
 TEMPLATE_NemuR3ExtPack_INST = $(INST_EXTPACK)YouShallOverrideThis/
 ifeq ($(KBUILD_TARGET),linux)
  TEMPLATE_NemuR3ExtPack_LDFLAGS = $(filter-out '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)' '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)', $(TEMPLATE_NEMUR3DLLNOXCPT_LDFLAGS))
 else
  if !defined(NEMU_WITH_RUNPATH) && defined(NEMU_WITH_RELATIVE_RUNPATH)
   TEMPLATE_NemuR3ExtPack_LDFLAGS = '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)/../../..' $(filter-out '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)', $(TEMPLATE_NEMUR3DLLNOXCPT_LDFLAGS))
  endif
 endif
 ifdef NEMU_ONLY_EXTPACKS_USE_IMPLIBS
  if1of ($(KBUILD_TARGET), win os2)
   TEMPLATE_NemuR3ExtPack_LIBS = \
   	$(TEMPLATE_LIBS_NEMUR3) \
   	$(if-expr "$(NEMU_LIB_VMM_LAZY)" == "$(LIB_VMM)", $(PATH_STAGE_LIB)/VMMR3Imp$(NEMU_SUFF_LIB), $(NEMU_LIB_VMM_LAZY)) \
   	$(PATH_STAGE_LIB)/NemuRTImp$(NEMU_SUFF_LIB)
  else
   TEMPLATE_NemuR3ExtPack_LIBS = \
   	$(TEMPLATE_LIBS_NEMUR3) \
   	$(if-expr "$(NEMU_LIB_VMM_LAZY)" == "$(LIB_VMM)", $(PATH_STAGE_LIB)/VMMR3Imp$(NEMU_SUFF_DLL), $(NEMU_LIB_VMM_LAZY)) \
   	$(PATH_STAGE_LIB)/NemuRTImp$(NEMU_SUFF_DLL)
  endif
 else
  TEMPLATE_NemuR3ExtPack_LIBS = \
  	$(TEMPLATE_LIBS_NEMUR3) \
  	$(LIB_RUNTIME) \
  	$(NEMU_LIB_VMM_LAZY)
 endif

 TEMPLATE_NemuR0ExtPack = For the ring-0 context extension pack modules.
 TEMPLATE_NemuR0ExtPack_EXTENDS = NemuR0
 TEMPLATE_NemuR0ExtPack_EXTENDS_BY = appending
 TEMPLATE_NemuR0ExtPack_INST = $(INST_EXTPACK)YouShallOverrideThis/
 TEMPLATE_NemuR0ExtPack_DEFS = NEMU_IN_EXTPACK NEMU_IN_EXTPACK_R0
 if1of ($(NEMU_LDR_FMT), pe lx)
  TEMPLATE_NemuR0ExtPack_LIBS = \
	$(PATH_STAGE_LIB)/VMMR0Imp$(NEMU_SUFF_LIB) \
	$(PATH_STAGE_LIB)/SUPR0$(NEMU_SUFF_LIB)
 endif

 TEMPLATE_NemuRcExtPack = For the raw-mode context extension pack modules.
 TEMPLATE_NemuRcExtPack_EXTENDS = NemuRc
 TEMPLATE_NemuRcExtPack_EXTENDS_BY = appending
 TEMPLATE_NemuRcExtPack_SYSSUFF = .rc
 TEMPLATE_NemuRcExtPack_INST = $(INST_EXTPACK)YouShallOverrideThis/
 TEMPLATE_NemuRcExtPack_DEFS = NEMU_IN_EXTPACK NEMU_IN_EXTPACK_RC
 if1of ($(NEMU_LDR_FMT32), pe lx)
  TEMPLATE_NemuRcExtPack_LIBS = \
	$(PATH_STAGE_LIB)/VMMRCBuiltin$(NEMU_SUFF_LIB) \
	$(PATH_STAGE_LIB)/VMMRCImp$(NEMU_SUFF_LIB)
 endif

 TEMPLATE_NemuInsExtPack = For the install targets of an extension pack.
 TEMPLATE_NemuInsExtPack_MODE = 0644
 TEMPLATE_NemuInsExtPack_INST = $(INST_EXTPACK)YouShallOverrideThis/

 # For each individual extension pack
 ifdef NEMU_WITH_EXTPACK_PUEL
  TEMPLATE_NemuR3ExtPackPuel = For the ring-3 context modules in the PUEL extension pack.
  TEMPLATE_NemuR3ExtPackPuel_EXTENDS = NemuR3ExtPack
  TEMPLATE_NemuR3ExtPackPuel_INST = $(INST_EXTPACK_PUEL)$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)/
  TEMPLATE_NemuR3ExtPackPuel_DEFS = $(TEMPLATE_NemuR3ExtPack_DEFS) NEMU_IN_PUEL_EXTPACK

  TEMPLATE_NemuR0ExtPackPuel = For the ring-0 context modules in the PUEL extension pack.
  TEMPLATE_NemuR0ExtPackPuel_EXTENDS = NemuR0ExtPack
  TEMPLATE_NemuR0ExtPackPuel_INST = $(INST_EXTPACK_PUEL)$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)/
  TEMPLATE_NemuR0ExtPackPuel_DEFS = $(TEMPLATE_NemuR0ExtPack_DEFS) NEMU_IN_PUEL_EXTPACK

  TEMPLATE_NemuRcExtPackPuel = For the raw-mode context modules in the PUEL extension pack.
  TEMPLATE_NemuRcExtPackPuel_EXTENDS = NemuRcExtPack
  TEMPLATE_NemuRcExtPackPuel_INST = $(INST_EXTPACK_PUEL)$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)/
  TEMPLATE_NemuRcExtPackPuel_DEFS = $(TEMPLATE_NemuRcExtPack_DEFS) NEMU_IN_PUEL_EXTPACK

  TEMPLATE_NemuInsExtPackPuel = For the install targets of an extension pack.
  TEMPLATE_NemuInsExtPackPuel_EXTENDS = NemuR0ExtPack
  TEMPLATE_NemuInsExtPackPuel_INST = $(INST_EXTPACK_PUEL)
 endif

endif # NEMU_WITH_EXTPACK


#
# Qt 4
# Qt 4
# Qt 4
#
ifdef NEMU_WITH_QTGUI

 # Guess NEMU_WITH_QT4_SUN
 ifndef NEMU_WITH_QT4_SUN
  ifndef NEMU_OSE
   if1of ($(KBUILD_TARGET), darwin solaris win)
    NEMU_WITH_QT4_SUN := 1
   endif
  endif
 endif

 #
 # Handmade configuration of qt4 - very annoying, this needs to
 # be cleaned up properly later some time (not important now).
 #
 ifeq ($(NEMU_PATH_QT4),)
  ifeq ($(KBUILD_TARGET),darwin)
   NEMU_PATH_QT4 := $(lastword $(sort $(wildcard $(KBUILD_DEVTOOLS_TRG)/qt/v4*)))
   ifeq ($(NEMU_PATH_QT4),)
    ifneq ($(wildcard /Library/Frameworks/QtCore.framework),)
     # Using the global installation (for OSE).
     NEMU_PATH_QT4 ?= /usr
     NEMU_PATH_QT4_FRAMEWORKS ?= /Library/Frameworks
    endif
   endif
  else if1of ($(KBUILD_TARGET), win)
   NEMU_PATH_QT4 ?= $(lastword $(filter %-$(tolower $(NEMU_VCC_TOOL_STEM)),$(sort $(wildcard $(KBUILD_DEVTOOLS_TRG)/qt/v4*))))
  else if1of ($(KBUILD_TARGET), linux solaris)
   NEMU_PATH_QT4 ?= $(lastword $(sort $(wildcard $(KBUILD_DEVTOOLS_TRG)/qt/v4*)))
   ifneq ($(NEMU_PATH_QT4),)
    NEMU_WITH_QT4_SUN = 1
   endif
  endif
 endif
 ifeq ($(NEMU_PATH_QT4),)
  if1of ($(USERNAME), bird)
   # gentoo (64-bit)
   NEMU_PATH_QT4          ?= /usr
   NEMU_PATH_QT4_LIB      ?= /usr/lib/qt4
  endif
 endif
 NEMU_PATH_QT4            ?= /usr
 NEMU_PATH_QT4_LIB        ?= $(NEMU_PATH_QT4)/lib

 ifdef NEMU_WITH_QT4_SUN
  NEMU_QT4_INFIX=Nemu
 endif

 NEMU_QT4_MOD = QtCore QtGui $(if $(NEMU_GUI_USE_QGL),QtOpenGL,)
 NEMU_QT4_MOD_NAMES = $(foreach qtmod,$(NEMU_QT4_MOD),$(qtmod)$(NEMU_QT4_INFIX))

 # Hack LD_LIBRARY_PATH for stuff in tools.
 ifdef NEMU_WITH_QT4_SUN
  if1of ($(KBUILD_TARGET), linux)
   export LD_LIBRARY_PATH := $(NEMU_PATH_QT4_LIB):$(LD_LIBRARY_PATH)
  endif
 endif


 #
 # Template for building Qt GUI executables.
 #
 TEMPLATE_NEMUQT4GUIEXE = Nemu Qt GUI Executable
 TEMPLATE_NEMUQT4GUIEXE_USES = qt4
 TEMPLATE_NEMUQT4GUIEXE_QTTOOL = QT4
 TEMPLATE_NEMUQT4GUIEXE_MOCTOOL = QT4
 TEMPLATE_NEMUQT4GUIEXE_UICTOOL = QT4
 TEMPLATE_NEMUQT4GUIEXE_RCCTOOL = QT4
 TEMPLATE_NEMUQT4GUIEXE_LRCTOOL = QT4
 TEMPLATE_NEMUQT4GUIEXE_SDKS = QT4
 TEMPLATE_NEMUQT4GUIEXE_QT_INFIX = $(NEMU_QT4_INFIX)
 TEMPLATE_NEMUQT4GUIEXE_DEFS = IN_RING3 QT_NO_DEBUG QT_THREAD_SUPPORT QT_SHARED HAVE_CONFIG_H $(ARCH_BITS_DEFS)
 TEMPLATE_NEMUQT4GUIEXE_RCDEFS = $(TEMPLATE_NEMUR3EXE_RCDEFS)

 ifeq ($(KBUILD_TARGET),win)
  # Note! No use of NEMU_VCC_CRT_TYPE here yet as it requires a /MDd build of Qt as well.
  TEMPLATE_NEMUQT4GUIEXE_TOOL = $(NEMU_VCC_TOOL)
  TEMPLATE_NEMUQT4GUIEXE_DEFS += \
     _WIN32_WINNT=0x0500 UNICODE _UNICODE \
     QT_DLL _CRT_SECURE_NO_DEPRECATE \
     $(QMAKE_PRL_DEFINES)
  TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS = -nologo -Zm200 -W3 -MD -Zi -EHsc -Zc:wchar_t-
  TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.debug = -RTCsu
  TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.dbgopt = $(NO_SUCH_VARIABLE)
  TEMPLATE_NEMUQT4GUIEXE_INCS += \
	$(PATH_TOOL_$(NEMU_VCC_TOOL)_ATLMFC_INC)
  TEMPLATE_NEMUQT4GUIEXE_LDFLAGS = -Ignore:4197 \
	/NOD /INCREMENTAL:NO /MAPINFO:EXPORTS /LargeAddressAware /DynamicBase /NxCompat /Release /Debug \
	/Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	/STUB:$(PATH_ROOT)/src/Nemu/HostDrivers/Support/win/winstub.com
  if defined(NEMU_SIGNING_MODE) && defined(NEMU_WITH_HARDENING)
   TEMPLATE_NEMUQT4GUIEXE_LDFLAGS += -IntegrityCheck
  endif
  TEMPLATE_NEMUQT4GUIEXE_SDKS += $(NEMU_WINPSDK)
  TEMPLATE_NEMUQT4GUIEXE_LIBS = \
	$(NEMU_LIBS_QT4) \
	$(LIB_RUNTIME) \
	$(NEMU_LIB_VMM_LAZY) \
	$(PATH_TOOL_$(NEMU_VCC_TOOL)_LIB)/msvcprt.lib \
	$(PATH_TOOL_$(NEMU_VCC_TOOL)_LIB)/msvcrt.lib \
	$(PATH_TOOL_$(NEMU_VCC_TOOL)_LIB)/oldnames.lib \
	$(PATH_TOOL_$(NEMU_VCC_TOOL)_LIB)/delayimp.lib \
	$(PATH_TOOL_$(NEMU_VCC_TOOL)_ATLMFC_LIB)/atls.lib
  ifdef NEMU_WITH_DEBUG_VCC_CRT # NemuCOM (static) is causing trouble of course.
   TEMPLATE_NEMUQT4GUIEXE_LIBS += \
	$(PATH_TOOL_$(NEMU_VCC_TOOL)_LIB)/msvcrt$(NEMU_VCC_CRT_TYPE).lib \
	$(PATH_TOOL_$(NEMU_VCC_TOOL)_LIB)/msvcprt$(NEMU_VCC_CRT_TYPE).lib
  endif
  TEMPLATE_NEMUQT4GUIEXE_POST_CMDS = $(NEMU_SIGN_IMAGE_CMDS)

 else # the gcc guys:
  TEMPLATE_NEMUQT4GUIEXE_TOOL = $(NEMU_GCC_TOOL)
  TEMPLATE_NEMUQT4GUIEXE_DEFS.linux = _REENTRANT

  TEMPLATE_NEMUQT4GUIEXE_DEFS.solaris = _REENTRANT

  ## @todo Use NEMU_GCC_PEDANTIC_CXX?
  TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS = \
	-g $(NEMU_GCC_pipe) $(filter-out -Wno-unused,$(NEMU_GCC_WARN)) -frtti -fno-exceptions -Wno-non-virtual-dtor \
	-Wno-long-long -fshort-wchar -fno-strict-aliasing \
	$(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_fvisibility-inlines-hidden) \
	$(NEMU_GCC_Wno-delete-non-virtual-dtor) $(NEMU_GCC_std) $(NEMU_GCC_IPRT_FMT_CHECK)
  TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.x86 = -m32
  TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.amd64 = -m64
  TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.linux = -pthread
  TEMPLATE_NEMUQT4GUIEXE_OBJCFLAGS = -g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_C) -Wno-long-long -fno-exceptions $(NEMU_GCC_IPRT_FMT_CHECK)
  TEMPLATE_NEMUQT4GUIEXE_OBJCFLAGS.x86 = $(TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.x86)
  TEMPLATE_NEMUQT4GUIEXE_OBJCFLAGS.amd64 = $(TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.amd64)
  TEMPLATE_NEMUQT4GUIEXE_OBJCXXFLAGS = \
	-g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_CXX) -Wno-non-virtual-dtor -Wno-long-long \
	-frtti -fno-exceptions $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_fvisibility-inlines-hidden) $(NEMU_GCC_IPRT_FMT_CHECK)
  TEMPLATE_NEMUQT4GUIEXE_OBJCXXFLAGS.x86 = $(TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.x86)
  TEMPLATE_NEMUQT4GUIEXE_OBJCXXFLAGS.amd64 = $(TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.amd64)
  TEMPLATE_NEMUQT4GUIEXE_LDFLAGS.x86 = -m32
  TEMPLATE_NEMUQT4GUIEXE_LDFLAGS.amd64 = -m64
  TEMPLATE_NEMUQT4GUIEXE_LIBS = \
	$(NEMU_LIBS_QT4) \
	$(LIB_SDL) \
	$(LIB_RUNTIME) \
	$(if-expr "$(LIB_VMM)" == "$(NEMU_LIB_VMM_LAZY)",$(LIB_REM),) \
	$(NEMU_LIB_VMM_LAZY)

  ifeq ($(KBUILD_TARGET),linux)
   TEMPLATE_NEMUQT4GUIEXE_LDFLAGS += -Wl,-z,noexecstack,-z,relro $(NEMU_LD_as_needed)
   TEMPLATE_NEMUQT4GUIEXE_LIBS += \
     $(NEMU_XCURSOR_LIBS) \
	Xext \
	X11
   TEMPLATE_NEMUQT4GUIEXE_LIBPATH += \
     $(NEMU_LIBPATH_X11)
  else ifeq ($(KBUILD_TARGET),darwin)
   TEMPLATE_NEMUQT4GUIEXE_DEFS.darwin        += $(NEMU_DARWIN_DEF_SDK_DEFS)
   TEMPLATE_NEMUQT4GUIEXE_CFLAGS.darwin      += $(NEMU_DARWIN_DEF_SDK_CFLAGS)
   TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS.darwin    += $(NEMU_DARWIN_DEF_SDK_CXXFLAGS)
   TEMPLATE_NEMUQT4GUIEXE_OBJCFLAGS.darwin   += $(NEMU_DARWIN_DEF_SDK_OBJCFLAGS)
   TEMPLATE_NEMUQT4GUIEXE_OBJCXXFLAGS.darwin += $(NEMU_DARWIN_DEF_SDK_OBJCXXFLAGS)
   TEMPLATE_NEMUQT4GUIEXE_LDFLAGS.darwin     += $(NEMU_DARWIN_DEF_SDK_LDFLAGS) -bind_at_load
   TEMPLATE_NEMUQT4GUIEXE_LIBS +=
   TEMPLATE_NEMUQT4GUIEXE_LIBPATH +=
  else
   TEMPLATE_NEMUQT4GUIEXE_INCS += \
	$(NEMU_XCURSOR_INCS)
   TEMPLATE_NEMUQT4GUIEXE_LIBS += \
     $(NEMU_XCURSOR_LIBS) \
	Xext \
	X11 \
	m \
	$(LIB_PTHREAD)
   TEMPLATE_NEMUQT4GUIEXE_LIBPATH += \
	$(NEMU_LIBPATH_X11)
   ifeq ($(KBUILD_TARGET),freebsd)
    TEMPLATE_NEMUQT4GUIEXE_INCS += \
	/usr/include \
	/usr/X11R6/include \
	/usr/local/include
    TEMPLATE_NEMUQT4GUIEXE_LIBPATH += \
	/usr/lib \
	/usr/X11R6/lib \
	/usr/local/lib
   endif
   ifeq ($(KBUILD_TARGET),solaris)
    TEMPLATE_NEMUQT4GUIEXE_LDFLAGS.solaris = -Wl,-z,ignore # Same as NEMU_LD_as_needed.
    TEMPLATE_NEMUQT4GUIEXE_LIBS += \
         rt socket nsl
   endif
  endif
  # Assume the Qt shared objects are in the same directory as the executable, on Solaris too.
  ifdef NEMU_WITH_RUNPATH
   TEMPLATE_NEMUQT4GUIEXE_LDFLAGS += '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RUNPATH)'
  else ifdef NEMU_WITH_RELATIVE_RUNPATH
   TEMPLATE_NEMUQT4GUIEXE_LDFLAGS += '$(NEMU_GCC_RPATH_OPT)$(NEMU_WITH_RELATIVE_RUNPATH)'
  endif

 endif

 # Add COM/XPCOM stuff
 TEMPLATE_NEMUQT4GUIEXE_LIBS += \
	$(PATH_STAGE_LIB)/NemuCOM$(NEMU_SUFF_LIB)
 ifdef NEMU_WITH_XPCOM
  ## @todo may be worth creating the NEMU_XPCOM SDK def, or just a SDK_NEMUXPCOM.
  TEMPLATE_NEMUQT4GUIEXE_DEFS += NEMU_WITH_XPCOM
  ifdef NEMU_WITH_XPCOM_NAMESPACE_CLEANUP
   TEMPLATE_NEMUQT4GUIEXE_DEFS += NEMU_WITH_XPCOM_NAMESPACE_CLEANUP
  endif
  TEMPLATE_NEMUQT4GUIEXE_INCS += \
	$(NEMU_XPCOM_INCS)
  TEMPLATE_NEMUQT4GUIEXE_LIBS += \
	$(LIB_XPCOM)
  TEMPLATE_NEMUQT4GUIEXE_INTERMEDIATES += \
	$(NEMU_PATH_SDK)/bindings/xpcom/include/VirtualBox_XPCOM.h
 else  # COM
  TEMPLATE_NEMUQT4GUIEXE_INCS += \
	$(NEMU_PATH_SDK)/bindings/mscom/include
  TEMPLATE_NEMUQT4GUIEXE_INTERMEDIATES += \
	$(NEMU_PATH_SDK)/bindings/mscom/include/VirtualBox.h
 endif # COM


 #
 # Template for building Qt GUI components.
 #
 TEMPLATE_NEMUQT4GUI = Nemu Qt GUI Components
 TEMPLATE_NEMUQT4GUI_EXTENDS = NEMUQT4GUIEXE
 TEMPLATE_NEMUQT4GUI_LIBS = $(filter-out $(QTMAIN),$(TEMPLATE_NEMUQT4GUIEXE_LIBS))
 ifeq ($(KBUILD_TARGET),darwin)
  TEMPLATE_NEMUQT4GUI_LDFLAGS.darwin += $(filter-out -bind_at_load,$(TEMPLATE_NEMUQT4GUIEXE_LDFLAGS.darwin)) \
	-current_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-compatibility_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)
 endif
 ifn1of ($(KBUILD_TARGET), darwin os2 win)
   TEMPLATE_NEMUQT4GUI_DEFS     = PIC $(TEMPLATE_NEMUQT4GUIEXE_DEFS)
   TEMPLATE_NEMUQT4GUI_CFLAGS   = -fPIC $(TEMPLATE_NEMUQT4GUIEXE_CFLAGS)
   TEMPLATE_NEMUQT4GUI_CXXFLAGS = -fPIC $(TEMPLATE_NEMUQT4GUIEXE_CXXFLAGS)
   TEMPLATE_NEMUQT4GUI_LDFLAGS  = -fPIC $(TEMPLATE_NEMUQT4GUIEXE_LDFLAGS)
 endif

endif # NEMU_WITH_QTGUI


#
# Template for installing symbol files that we wish to ship.
#
TEMPLATE_NemuDbgSyms = Symbol files for NemuDbg and gurus.
TEMPLATE_NemuDbgSyms_INST = $(INST_NEMUDBG_SYMS)


#
# Template for building build bldprogs.
#
# HACK ALERT! The BLD_TRG_* is a hack to allow building libraries as well.
#
TEMPLATE_NemuBldProg  = Nemu Build Program
TEMPLATE_NemuBldProg_BLD_TRG            := $(KBUILD_HOST)
TEMPLATE_NemuBldProg_BLD_TRG_ARCH       := $(KBUILD_HOST_ARCH)
TEMPLATE_NemuBldProg_BLD_TRG_CPU        := $(KBUILD_HOST_CPU)
TEMPLATE_NemuBldProg_DEFS               := IN_RING3 LOG_DISABLED
TEMPLATE_NemuBldProg_DEFS.win           := _CRT_SECURE_NO_DEPRECATE
ifeq ($(KBUILD_TARGET),$(KBUILD_HOST))
 TEMPLATE_NemuBldProg_ASTOOL            := $(NEMU_ASTOOL)
 TEMPLATE_NemuBldProg_ASFLAGS.x86       := $(NEMU_ASFLAGS32)
 TEMPLATE_NemuBldProg_ASFLAGS.amd64     := $(NEMU_ASFLAGS64)
else
 TEMPLATE_NemuBldProg_ASTOOL            := YASM
 TEMPLATE_NemuBldProg_ASFLAGS           := -D__YASM__ -Worphan-labels
 if1of ($(KBUILD_HOST),win)
  TEMPLATE_NemuBldProg_ASFLAGS          += -g cv8 -DASM_FORMAT_ELF
  TEMPLATE_NemuBldProg_ASFLAGS.x86      := -f win32
  TEMPLATE_NemuBldProg_ASFLAGS.amd64    := -f win64
 else if1of ($(KBUILD_HOST),darwin)
  TEMPLATE_NemuBldProg_ASFLAGS          += -DASM_FORMAT_MACHO
  TEMPLATE_NemuBldProg_ASFLAGS.x86      := -f macho32
  TEMPLATE_NemuBldProg_ASFLAGS.amd64    := -f macho64
 else
  TEMPLATE_NemuBldProg_ASFLAGS          += -g dwarf2 -DASM_FORMAT_ELF
  TEMPLATE_NemuBldProg_ASFLAGS.x86      := -f elf32
  TEMPLATE_NemuBldProg_ASFLAGS.amd64    := -f elf64
 endif
  TEMPLATE_NemuBldProg_ASFLAGS.amd64    += $(NEMU_YASM_Wno-segreg-in-64bit)
endif
ifeq ($(KBUILD_HOST),win)
 TEMPLATE_NemuBldProg_TOOL              := $(NEMU_VCC_TOOL_STEM)$(toupper $(KBUILD_HOST_ARCH))
 TEMPLATE_NemuBldProg_SDKS              := ReorderCompilerIncs $(NEMU_WINPSDK)
 TEMPLATE_NemuBldProg_CXXFLAGS          := -Zi -Zl -GR- -EHsc -GF -W3 -wd4065 -wd4244 -wd4996 -Zc:wchar_t- $(NEMU_VCC_OPT) $(NEMU_VCC_FP) -MT$(NEMU_VCC_CRT_TYPE)
 TEMPLATE_NemuBldProg_CXXFLAGS.debug    := -RTCsu
 TEMPLATE_NemuBldProg_CXXFLAGS.dbgopt    = $(NO_SUCH_VARIABLE)
 TEMPLATE_NemuBldProg_CXXFLAGS.profile   = $(TEMPLATE_NemuBldProg_CXXFLAGS.release)
 TEMPLATE_NemuBldProg_CXXFLAGS.kprofile  = $(TEMPLATE_NemuBldProg_CXXFLAGS.release)
 TEMPLATE_NemuBldProg_CFLAGS             = $(TEMPLATE_NemuBldProg_CXXFLAGS)
 TEMPLATE_NemuBldProg_CFLAGS.debug       = $(TEMPLATE_NemuBldProg_CXXFLAGS.debug)
 TEMPLATE_NemuBldProg_CFLAGS.dbgopt      = $(TEMPLATE_NemuBldProg_CXXFLAGS.dbgopt)
 TEMPLATE_NemuBldProg_CFLAGS.release     = $(TEMPLATE_NemuBldProg_CXXFLAGS.release)
 TEMPLATE_NemuBldProg_CFLAGS.profile     = $(TEMPLATE_NemuBldProg_CXXFLAGS.profile)
 TEMPLATE_NemuBldProg_CFLAGS.kprofile    = $(TEMPLATE_NemuBldProg_CXXFLAGS.kprofile)
 TEMPLATE_NemuBldProg_LDFLAGS            = -Ignore:4197 \
	/NOD /INCREMENTAL:NO /MAPINFO:EXPORTS /LargeAddressAware /DynamicBase /NxCompat /Release /Debug \
	/Version:$(NEMU_VERSION_MAJOR)0$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	/DISALLOWLIB:libc$(NEMU_VCC_CRT_TYPE_N).lib \
	/DISALLOWLIB:libcmt$(NEMU_VCC_CRT_TYPE_N).lib \
	/DISALLOWLIB:msvcrt.lib \
	/DISALLOWLIB:msvcrtd.lib \
	/DISALLOWLIB:msvcprt.lib \
	/DISALLOWLIB:msvcprtd.lib
 TEMPLATE_NemuBldProg_LIBS               = \
	$(PATH_TOOL_$(TEMPLATE_NemuBldProg_TOOL)_LIB)/oldnames.lib \
	$(PATH_TOOL_$(TEMPLATE_NemuBldProg_TOOL)_LIB)/libcmt$(NEMU_VCC_CRT_TYPE).lib \
	$(PATH_TOOL_$(TEMPLATE_NemuBldProg_TOOL)_LIB)/libcpmt$(NEMU_VCC_CRT_TYPE).lib

else
# (gcc of some kind )
TEMPLATE_NemuBldProg_TOOL                = GXX3
TEMPLATE_NemuBldProg_CFLAGS              = -g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_C) $(NEMU_GCC_Wno-variadic-macros)
TEMPLATE_NemuBldProg_CFLAGS.x86          = -m32
TEMPLATE_NemuBldProg_CFLAGS.sparc32      = -m32
TEMPLATE_NemuBldProg_CFLAGS.amd64        = -m64
TEMPLATE_NemuBldProg_CFLAGS.sparc64      = -m64
TEMPLATE_NemuBldProg_CFLAGS.release      = -O2 -fno-omit-frame-pointer -fno-strict-aliasing
TEMPLATE_NemuBldProg_CFLAGS.profile      = $(TEMPLATE_NemuBldProg_CXXFLAGS.profile)
TEMPLATE_NemuBldProg_CFLAGS.kprofile     = $(TEMPLATE_NemuBldProg_CXXFLAGS.kprofile)
TEMPLATE_NemuBldProg_CXXFLAGS            = -g $(NEMU_GCC_pipe) $(NEMU_GCC_PEDANTIC_CXX) $(NEMU_GCC_Wno-variadic-macros)
TEMPLATE_NemuBldProg_CXXFLAGS.x86        = -m32
TEMPLATE_NemuBldProg_CXXFLAGS.sparc32    = -m32
TEMPLATE_NemuBldProg_CXXFLAGS.amd64      = -m64
TEMPLATE_NemuBldProg_CXXFLAGS.sparc64    = -m64
TEMPLATE_NemuBldProg_CXXFLAGS.release    = -O2 -fno-omit-frame-pointer -fno-strict-aliasing
TEMPLATE_NemuBldProg_CXXFLAGS.profile    = $(TEMPLATE_NemuBldProg_CXXFLAGS.release)
TEMPLATE_NemuBldProg_CXXFLAGS.kprofile   = $(TEMPLATE_NemuBldProg_CXXFLAGS.release)
TEMPLATE_NemuBldProg_OBJCFLAGS           = $(TEMPLATE_NemuBldProg_CFLAGS)
TEMPLATE_NemuBldProg_OBJCFLAGS.x86       = $(TEMPLATE_NemuBldProg_CFLAGS.x86)
TEMPLATE_NemuBldProg_OBJCFLAGS.amd64     = $(TEMPLATE_NemuBldProg_CFLAGS.amd64)
TEMPLATE_NemuBldProg_OBJCFLAGS.release   = $(TEMPLATE_NemuBldProg_CFLAGS.release)
TEMPLATE_NemuBldProg_OBJCFLAGS.profile   = $(TEMPLATE_NemuBldProg_CFLAGS.profile)
TEMPLATE_NemuBldProg_OBJCFLAGS.kprofile  = $(TEMPLATE_NemuBldProg_CFLAGS.kprofile)
TEMPLATE_NemuBldProg_OBJCXXFLAGS         = $(TEMPLATE_NemuBldProg_CXXFLAGS)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.x86     = $(TEMPLATE_NemuBldProg_CXXFLAGS.x86)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.amd64   = $(TEMPLATE_NemuBldProg_CXXFLAGS.amd64)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.release = $(TEMPLATE_NemuBldProg_CXXFLAGS.release)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.profile = $(TEMPLATE_NemuBldProg_CXXFLAGS.profile)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.kprofile= $(TEMPLATE_NemuBldProg_CXXFLAGS.kprofile)
TEMPLATE_NemuBldProg_LDFLAGS.x86         = -m32
TEMPLATE_NemuBldProg_LDFLAGS.sparc32     = -m32
TEMPLATE_NemuBldProg_LDFLAGS.amd64       = -m64
TEMPLATE_NemuBldProg_LDFLAGS.sparc64     = -m64
 ifeq ($(KBUILD_HOST),linux)
TEMPLATE_NemuBldProg_LIBS                = pthread m rt dl
 else ifeq ($(KBUILD_HOST),os2)
TEMPLATE_NemuBldProg_TOOL                = GXX3OMF
TEMPLATE_NemuBldProg_LIBS                = socket iconv
 else ifeq ($(KBUILD_HOST),darwin)
TEMPLATE_NemuBldProg_TOOL                = GXX4MACHO
  if "$(NEMU_DEF_MACOSX_VERSION_MIN)" == "10.7" || "$(NEMU_DARWIN_HOST_VERSION_MAJOR)" == "7"
TEMPLATE_NemuBldProg_DEFS.darwin         = $(NEMU_DARWIN_DEF_SDK_10_7_DEFS)
TEMPLATE_NemuBldProg_CFLAGS.darwin       = $(NEMU_DARWIN_DEF_SDK_10_7_CFLAGS) -fno-common
TEMPLATE_NemuBldProg_CXXFLAGS.darwin     = $(NEMU_DARWIN_DEF_SDK_10_7_CXXFLAGS)
TEMPLATE_NemuBldProg_OBJCFLAGS.darwin    = $(NEMU_DARWIN_DEF_SDK_10_7_OBJCFLAGS) $(NEMU_GCC_PEDANTIC_C)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.darwin  = $(NEMU_DARWIN_DEF_SDK_10_7_OBJCXXFLAGS) $(NEMU_GCC_PEDANTIC_CXX)
TEMPLATE_NemuBldProg_LDFLAGS.darwin      = $(NEMU_DARWIN_DEF_SDK_10_7_LDFLAGS)
  else if "$(NEMU_DEF_MACOSX_VERSION_MIN)" == "10.6" || "$(NEMU_DARWIN_HOST_VERSION_MAJOR)" == "6"
TEMPLATE_NemuBldProg_DEFS.darwin         = $(NEMU_DARWIN_DEF_SDK_10_6_DEFS)
TEMPLATE_NemuBldProg_CFLAGS.darwin       = $(NEMU_DARWIN_DEF_SDK_10_6_CFLAGS) -fno-common
TEMPLATE_NemuBldProg_CXXFLAGS.darwin     = $(NEMU_DARWIN_DEF_SDK_10_6_CXXFLAGS)
TEMPLATE_NemuBldProg_OBJCFLAGS.darwin    = $(NEMU_DARWIN_DEF_SDK_10_6_OBJCFLAGS) $(NEMU_GCC_PEDANTIC_C)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.darwin  = $(NEMU_DARWIN_DEF_SDK_10_6_OBJCXXFLAGS) $(NEMU_GCC_PEDANTIC_CXX)
TEMPLATE_NemuBldProg_LDFLAGS.darwin      = $(NEMU_DARWIN_DEF_SDK_10_6_LDFLAGS)
  else if "$(NEMU_DEF_MACOSX_VERSION_MIN)" == "10.5" || "$(NEMU_DARWIN_HOST_VERSION_MAJOR)" == "5" || defined(NEMU_MACOS_10_5_WORKAROUND)
TEMPLATE_NemuBldProg_DEFS.darwin         = $(NEMU_DARWIN_DEF_SDK_10_5_DEFS)
TEMPLATE_NemuBldProg_CFLAGS.darwin       = $(NEMU_DARWIN_DEF_SDK_10_5_CFLAGS) -fno-common
TEMPLATE_NemuBldProg_CXXFLAGS.darwin     = $(NEMU_DARWIN_DEF_SDK_10_5_CXXFLAGS)
TEMPLATE_NemuBldProg_OBJCFLAGS.darwin    = $(NEMU_DARWIN_DEF_SDK_10_5_OBJCFLAGS) $(NEMU_GCC_PEDANTIC_C)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.darwin  = $(NEMU_DARWIN_DEF_SDK_10_5_OBJCXXFLAGS) $(NEMU_GCC_PEDANTIC_CXX)
TEMPLATE_NemuBldProg_LDFLAGS.darwin      = $(NEMU_DARWIN_DEF_SDK_10_5_LDFLAGS)
  else
TEMPLATE_NemuBldProg_DEFS.darwin         = $(NEMU_DARWIN_DEF_SDK_DEFS)
TEMPLATE_NemuBldProg_CFLAGS.darwin       = $(NEMU_DARWIN_DEF_SDK_CFLAGS) -fno-common
TEMPLATE_NemuBldProg_CXXFLAGS.darwin     = $(NEMU_DARWIN_DEF_SDK_CXXFLAGS)
TEMPLATE_NemuBldProg_OBJCFLAGS.darwin    = $(NEMU_DARWIN_DEF_SDK_OBJCFLAGS) $(NEMU_GCC_PEDANTIC_C)
TEMPLATE_NemuBldProg_OBJCXXFLAGS.darwin  = $(NEMU_DARWIN_DEF_SDK_OBJCXXFLAGS) $(NEMU_GCC_PEDANTIC_CXX)
TEMPLATE_NemuBldProg_LDFLAGS.darwin      = $(NEMU_DARWIN_DEF_SDK_LDFLAGS)
  endif
TEMPLATE_NemuBldProg_LIBS                =
 else ifeq ($(KBUILD_HOST),haiku)
TEMPLATE_NemuBldProg_TOOL                = GXX3
TEMPLATE_NemuBldProg_LIBS                = network iconv
TEMPLATE_NemuBldProg_LIBPATH            += \
	/boot/common/lib
 else if1of ($(KBUILD_HOST), freebsd netbsd openbsd)
TEMPLATE_NemuBldProg_TOOL                = GXX3
TEMPLATE_NemuBldProg_LIBS                = pthread
TEMPLATE_NemuBldProg_INCS               += \
	/usr/include \
	/usr/X11R6/include \
	/usr/local/include
TEMPLATE_NemuBldProg_LIBPATH            += \
	/usr/lib \
	/usr/X11R6/lib \
	/usr/local/lib
 else ifeq ($(KBUILD_HOST),solaris)
TEMPLATE_NemuBldProg_TOOL                = GXX3PLAIN
TEMPLATE_NemuBldProg_LIBS                = rt
 else
$(warning Warning: NEMU Build: Target $(KBUILD_HOST) is not officially supported!)
 endif

endif # !win


#
# Advanced build programs using IPRT and stuff.
#
TEMPLATE_NemuAdvBldProg = Advanced Nemu Build Program
TEMPLATE_NemuAdvBldProg_EXTENDS = NemuBldProg
TEMPLATE_NemuAdvBldProg_SDKS    = $(TEMPLATE_NemuBldProg_SDKS)
TEMPLATE_NemuAdvBldProg_SDKS.win= $(TEMPLATE_NemuBldProg_SDKS.win) NEMU_NTDLL
TEMPLATE_NemuAdvBldProg_DEFS    = $(TEMPLATE_NemuBldProg_DEFS) IN_RT_R3
ifeq ($(KBUILD_HOST),win)
 TEMPLATE_NemuAdvBldProg_CFLAGS = $(TEMPLATE_NemuBldProg_CFLAGS) $(NEMU_VCC_WERR)
 TEMPLATE_NemuAdvBldProg_CXXFLAGS = $(TEMPLATE_NemuBldProg_CXXFLAGS) $(NEMU_VCC_WERR)
endif
TEMPLATE_NemuAdvBldProg_LIBS    = \
	$(PATH_STAGE_LIB)/RuntimeBldProg$(NEMU_HOSTSUFF_LIB) \
	$(if-expr defined(IPRT_WITH_KSTUFF), \
		$(PATH_STAGE_LIB)/Nemu-kStuffStaticBldProg$(NEMU_HOSTSUFF_LIB) \
		$(PATH_STAGE_LIB)/RuntimeBldProg$(NEMU_HOSTSUFF_LIB) \
	,) \
	$(TEMPLATE_NemuBldProg_LIBS)
TEMPLATE_NemuAdvBldProg_LIBS.darwin = \
	$(TEMPLATE_NemuAdvBldProg_LIBS) \
	iconv \
	$(TEMPLATE_NemuBldProg_LIBS.darwin)
TEMPLATE_NemuAdvBldProg_LIBS.freebsd = \
	$(TEMPLATE_NemuAdvBldProg_LIBS) \
	iconv \
	rt \
	$(TEMPLATE_NemuBldProg_LIBS.freebsd)
TEMPLATE_NemuAdvBldProg_LIBS.linux = \
	$(TEMPLATE_NemuAdvBldProg_LIBS) \
	crypt \
	$(TEMPLATE_NemuBldProg_LIBS.linux)
TEMPLATE_NemuAdvBldProg_LIBS.solaris = \
	$(TEMPLATE_NemuAdvBldProg_LIBS) \
	contract \
	kstat \
	rt \
	socket \
	nsl \
	$(TEMPLATE_NemuBldProg_LIBS.solaris)


#
# Windows rc workaround for crosscompiling.
# (Some (old) Wine versions fails loading msvcrt.dll from the VCC bin directory.)
#
ifneq ($(KBUILD_HOST),win)
 TOOL_VCC80X86_RC    := $(EXEC_X86_WIN32) $(KBUILD_DEVTOOLS)/win.x86/bin/rc.exe
 TOOL_VCC80AMD64_RC  := $(EXEC_X86_WIN32) $(KBUILD_DEVTOOLS)/win.x86/bin/rc.exe
 TOOL_VCC70_RC       := $(EXEC_X86_WIN32) $(KBUILD_DEVTOOLS)/win.x86/bin/rc.exe
 WIN32_MC = $(EXEC_X86_WIN32) $(KBUILD_DEVTOOLS)/win.x86/bin/mc.exe
else
 WIN32_MC = $(EXEC_X86_WIN32) $(firstword $(wildcard \
	$(PATH_SDK_$(NEMU_WINPSDK)_BIN)/MC.Exe\
	$(PATH_SDK_WINPSDK_BIN)/MC.Exe\
	$(PATH_SDK_WINPSDK)/Bin/MC.Exe\
	$(PATH_SDK_WIN32SDK_BIN)/MC.Exe\
	$(PATH_SDK_WIN64SDK_BIN)/MC.Exe\
	$(KBUILD_DEVTOOLS)/win.x86/bin/mc.exe\
	) Sorry_Cannot_find_mc_in_the_PSDK)
endif


#
# Template for building R3 programs for the guest additions.
#
TEMPLATE_NEMUGUESTR3EXE           = Nemu Guest Program
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NEMUGUESTR3EXE_EXTENDS  = NEMUR3EXE
 TEMPLATE_NEMUGUESTR3EXE_SDKS     = ReorderCompilerIncs $(NEMU_WINPSDK_GST) NEMU_NTDLL
 TEMPLATE_NEMUGUESTR3EXE_CFLAGS   = $(filter-out -MD$(NEMU_VCC_CRT_TYPE), $(TEMPLATE_NEMUR3EXE_CFLAGS)) -MT$(NEMU_VCC_CRT_TYPE)
 TEMPLATE_NEMUGUESTR3EXE_CXXFLAGS = $(filter-out -MD$(NEMU_VCC_CRT_TYPE), $(TEMPLATE_NEMUR3EXE_CFLAGS)) -MT$(NEMU_VCC_CRT_TYPE)
 TEMPLATE_NEMUGUESTR3EXE_LDFLAGS  = $(filter-out /DISALLOWLIB:libcmt$(NEMU_VCC_CRT_TYPE).lib /DISALLOWLIB:libcpmt$(NEMU_VCC_CRT_TYPE).lib, $(TEMPLATE_NEMUR3EXE_LDFLAGS)) \
	/DISALLOWLIB:msvcrt$(NEMU_VCC_CRT_TYPE).lib \
	/DISALLOWLIB:msvcprt$(NEMU_VCC_CRT_TYPE).lib
 TEMPLATE_NEMUGUESTR3EXE_LIBS.x86           = \
 	$(PATH_TOOL_$(TEMPLATE_NEMUGUESTR3EXE_TOOL.win.x86)_LIB)/oldnames.lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUGUESTR3EXE_TOOL.win.x86)_LIB)/libcmt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUGUESTR3EXE_TOOL.win.x86)_LIB)/libcpmt$(NEMU_VCC_CRT_TYPE).lib
 TEMPLATE_NEMUGUESTR3EXE_LIBS.amd64         = \
 	$(PATH_TOOL_$(TEMPLATE_NEMUGUESTR3EXE_TOOL.win.amd64)_LIB)/oldnames.lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUGUESTR3EXE_TOOL.win.amd64)_LIB)/libcmt$(NEMU_VCC_CRT_TYPE).lib \
 	$(PATH_TOOL_$(TEMPLATE_NEMUGUESTR3EXE_TOOL.win.amd64)_LIB)/libcpmt$(NEMU_VCC_CRT_TYPE).lib
 # Hack for running on NT4, W2K and XP w/o SP: Change OS and subsystem version in the image.
 # HACK ALERT! Double expansion of $$(NLTAB).
 TEMPLATE_NEMUGUESTR3EXE_POST_CMDS.win.x86  = $(if $(eq $(tool_do),LINK_LIBRARY),,$(NEMU_PE_SET_VERSION) $(out)$$(NLTAB)$(TEMPLATE_NEMUR3EXE_POST_CMDS))
 TEMPLATE_NEMUGUESTR3EXE_LNK_DEPS.win.x86   = $(if $(eq $(tool_do),LINK_LIBRARY),,$(NEMU_PE_SET_VERSION))
 if defined(NEMU_WITH_MORE_NT4_COMPAT_BINARIES) && "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.x86"
  TEMPLATE_NEMUGUESTR3EXE_LIBS.win.x86 = $(NO_SUCH_VARIABLE)# Ditch RuntimeR3VccTricks2
 endif
else # the gcc guys
 ifneq ($(NEMU_WITH_COMPATIBLE_LINUX_GUEST_PACKAGE),)
  ifneq ($(KBUILD_TARGET),linux)
   override NEMU_WITH_COMPATIBLE_LINUX_GUEST_PACKAGE :=
  endif
 endif
 TEMPLATE_NEMUGUESTR3EXE_EXTENDS  = NEMUR3EXE
 TEMPLATE_NEMUGUESTR3EXE_TOOL    := $(subst GXX,GCC,$(TEMPLATE_NEMUR3EXE_TOOL))
 TEMPLATE_NEMUGUESTR3EXE_CXXFLAGS = $(TEMPLATE_NEMUR3EXE_CXXFLAGS) -fno-exceptions
 TEMPLATE_NEMUGUESTR3EXE_LDFLAGS.linux = $(filter-out $(NEMU_GCC_ORIGIN_OPT),$(TEMPLATE_NEMUR3EXE_LDFLAGS.linux))
 ifneq ($(NEMU_WITH_COMPATIBLE_LINUX_GUEST_PACKAGE),)
  ifeq ($(KBUILD_TARGET_ARCH),x86)
   TEMPLATE_NEMUGUESTR3EXE_TOOL         := NemuXGccX86RedHatLinux
  else ifeq ($(KBUILD_TARGET_ARCH),amd64)
   TEMPLATE_NEMUGUESTR3EXE_TOOL         := NemuXGccAmd64LinuxGnu
   TEMPLATE_NEMUGUESTR3EXE_TOOL.x86     := NemuXGccX86RedHatLinux
  endif
  TEMPLATE_NEMUGUESTR3EXE_CXXFLAGS      := $(filter-out $(NEMU_GCC_pipe) $(NEMU_GCC_Wextra) $(NEMU_GCC_Wno-missing-field-initializers) $(NEMU_GCC_fdiagnostics-show-option) $(NEMU_GCC_Wno-delete-non-virtual-dtor) $(NEMU_GCC_Wno-variadic-macros) $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_fvisibility-inlines-hidden) $(NEMU_GCC_mtune-generic) $(NEMU_GCC_Wlogical-op),$(TEMPLATE_NEMUGUESTR3EXE_CXXFLAGS)) -pipe
  TEMPLATE_NEMUGUESTR3EXE_CFLAGS        := $(TEMPLATE_NEMUGUESTR3EXE_CXXFLAGS)
  TEMPLATE_NEMUGUESTR3EXE_LDFLAGS.linux := $(filter-out $(NEMU_GCC_ORIGIN_OPT) $(NEMU_LD_as_needed),$(TEMPLATE_NEMUGUESTR3EXE_LDFLAGS.linux))
 endif
 TEMPLATE_NEMUGUESTR3EXE_LDFLAGS  = $(filter-out '$(NEMU_GCC_RPATH_OPT)%,$(TEMPLATE_NEMUR3EXE_LDFLAGS))
endif
TEMPLATE_NEMUGUESTR3EXE_INST      = $(INST_ADDITIONS)
TEMPLATE_NEMUGUESTR3EXE_DEFS     := $(filter-out $(ARCH_BITS_DEFS), $(TEMPLATE_NEMUR3EXE_DEFS)) IN_GUEST IN_GUEST_R3 IN_RT_R3 $(NEMU_GC_ARCH_BITS_DEFS)
TEMPLATE_NEMUGUESTR3EXE_DEFS.linux := $(TEMPLATE_NEMUR3EXE_DEFS.linux) LOG_USE_C99 RT_WITHOUT_EXEC_ALLOC
ifeq ($(KBUILD_TARGET),linux) # As few libs as possible on linux.
 TEMPLATE_NEMUGUESTR3EXE_LIBS     = pthread rt m dl
else if1of ($(KBUILD_TARGET), darwin freebsd netbsd openbsd)
 TEMPLATE_NEMUGUESTR3EXE_LIBS     = $(TEMPLATE_NEMUR3EXE_LIBS) iconv
else ifeq ($(KBUILD_TARGET), solaris)
 TEMPLATE_NEMUGUESTR3EXE_LIBS     = $(TEMPLATE_NEMUR3EXE_LIBS) nsl
endif

#
# Template for building normal R3 programs for the guest additions.
#
TEMPLATE_NewNemuGuestR3Exe = Nemu Guest Program w/ IPRT and VBGL.
TEMPLATE_NewNemuGuestR3Exe_EXTENDS  = NEMUGUESTR3EXE
TEMPLATE_NewNemuGuestR3Exe_LIBS     = \
	$(NEMU_LIB_IPRT_GUEST_R3) \
	$(NEMU_LIB_VBGL_R3) \
	$(NEMU_LIB_IPRT_GUEST_R3) \
	$(TEMPLATE_NEMUGUESTR3EXE_LIBS)

#
# Template for building R3 (dynamic) libraries for the guest additions.
#
TEMPLATE_NEMUGUESTR3DLL           = Nemu Guest User Dynamic Libraries
TEMPLATE_NEMUGUESTR3DLL_EXTENDS   = NEMUGUESTR3EXE
## @todo add a INSTFUN that separates dlls and libs.
ifn1of ($(KBUILD_TARGET), darwin os2 win)
 TEMPLATE_NEMUGUESTR3DLL_DEFS     = $(TEMPLATE_NEMUGUESTR3EXE_DEFS) PIC
 TEMPLATE_NEMUGUESTR3DLL_CFLAGS   = $(TEMPLATE_NEMUGUESTR3EXE_CFLAGS) -fPIC
 TEMPLATE_NEMUGUESTR3DLL_CXXFLAGS = $(TEMPLATE_NEMUGUESTR3EXE_CXXFLAGS) -fPIC -fno-exceptions
 TEMPLATE_NEMUGUESTR3DLL_LDFLAGS  = $(TEMPLATE_NEMUGUESTR3EXE_LDFLAGS) -fPIC
endif

#
# Template for building normal R3 (dynamic) libraries for the guest additions, allows warnings.
#
## @todo rename to NemuGuestR3DllWarn
TEMPLATE_NewNemuGuestR3Dll = Nemu Guest User Dynamic Libraries w/ IPRT and VBGL.
TEMPLATE_NewNemuGuestR3Dll_EXTENDS  = NEMUGUESTR3DLL
TEMPLATE_NewNemuGuestR3Dll_LIBS     = \
	$(NEMU_LIB_IPRT_GUEST_R3_SHARED) \
	$(NEMU_LIB_VBGL_R3_SHARED) \
	$(NEMU_LIB_IPRT_GUEST_R3_SHARED) \
	$(TEMPLATE_NEMUGUESTR3EXE_LIBS)

#
# Template for building normal R3 (dynamic) libraries for the guest additions, strict.
#
TEMPLATE_NemuGuestR3Dll = Nemu Guest User Dynamic Libraries w/ IPRT and VBGL.
TEMPLATE_NemuGuestR3Dll_EXTENDS  = NewNemuGuestR3Dll
TEMPLATE_NemuGuestR3Dll_EXTENDS_BY = appending
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NemuGuestR3Dll_CFLAGS      += $(NEMU_VCC_WERR)
 TEMPLATE_NemuGuestR3Dll_CXXFLAGS    += $(NEMU_VCC_WERR)
 TEMPLATE_NemuGuestR3Dll_LDFLAGS     += $(NEMU_VCC_LD_WERR)
else ifeq ($(NEMU_WITH_COMPATIBLE_LINUX_GUEST_PACKAGE),)
 TEMPLATE_NemuGuestR3Dll_CFLAGS      += $(NEMU_GCC_WERR)
 TEMPLATE_NemuGuestR3Dll_CXXFLAGS    += $(NEMU_GCC_WERR)
endif

#
# Template for building R3 (static) libraries for the guest additions, allows warnings.
#
## @todo rename to NemuGuestR3LibWarn.
TEMPLATE_NEMUGUESTR3LIB           = Nemu Guest User Libraries
TEMPLATE_NEMUGUESTR3LIB_EXTENDS   = NEMUGUESTR3EXE
TEMPLATE_NEMUGUESTR3LIB_INST      = $(INST_ADDITIONS_LIB)

#
# Template for building R3 (static) libraries for the guest additions, strict.
#
TEMPLATE_NemuGuestR3Lib = Nemu Guest User Dynamic Libraries w/ IPRT and VBGL.
TEMPLATE_NemuGuestR3Lib_EXTENDS  = NEMUGUESTR3LIB
TEMPLATE_NemuGuestR3Lib_EXTENDS_BY = appending
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_NemuGuestR3Lib_CFLAGS      += $(NEMU_VCC_WERR)
 TEMPLATE_NemuGuestR3Lib_CXXFLAGS    += $(NEMU_VCC_WERR)
 TEMPLATE_NemuGuestR3Lib_LDFLAGS     += $(NEMU_VCC_LD_WERR)
else ifeq ($(NEMU_WITH_COMPATIBLE_LINUX_GUEST_PACKAGE),)
 TEMPLATE_NemuGuestR3Lib_CFLAGS      += $(NEMU_GCC_WERR)
 TEMPLATE_NemuGuestR3Lib_CXXFLAGS    += $(NEMU_GCC_WERR)
endif

#
# Template for building R3 programs for the guest additions (no -pedantic)
#
TEMPLATE_NEMUGUESTR3NPEXE          = Nemu Guest Program Non-pedantic
TEMPLATE_NEMUGUESTR3NPEXE_EXTENDS  = NEMUGUESTR3EXE
ifneq ($(KBUILD_TARGET),win) # gcc only
TEMPLATE_NEMUGUESTR3NPEXE_CXXFLAGS = $(filter-out -pedantic -Wshadow,$(TEMPLATE_NEMUGUESTR3EXE_CXXFLAGS)) -Wno-sign-compare
TEMPLATE_NEMUGUESTR3NPEXE_CFLAGS   = $(filter-out -pedantic -Wshadow -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations,$(TEMPLATE_NEMUGUESTR3EXE_CFLAGS)) -Wno-sign-compare
endif

#
# Template for building R3 (dynamic) libraries for the guest additions (no -pedantic)
#
TEMPLATE_NEMUGUESTR3NPDLL           = Nemu Guest User Dynamic Libraries Non-pedantic
TEMPLATE_NEMUGUESTR3NPDLL_EXTENDS   = NEMUGUESTR3NPEXE
## @todo add a INSTFUN that separates dlls and libs.
ifn1of ($(KBUILD_TARGET), darwin os2 win)
 TEMPLATE_NEMUGUESTR3NPDLL_DEFS     = $(TEMPLATE_NEMUGUESTR3NPEXE_DEFS) PIC
 TEMPLATE_NEMUGUESTR3NPDLL_CFLAGS   = $(TEMPLATE_NEMUGUESTR3NPEXE_CFLAGS) -fPIC
 TEMPLATE_NEMUGUESTR3NPDLL_CXXFLAGS = $(TEMPLATE_NEMUGUESTR3NPEXE_CXXFLAGS) -fPIC -fno-exceptions
 TEMPLATE_NEMUGUESTR3NPDLL_LDFLAGS  = $(TEMPLATE_NEMUGUESTR3NPEXE_LDFLAGS) -fPIC
endif

#
# Template for building R3 (static) libraries for the guest additions (no -pedantic)
#
TEMPLATE_NEMUGUESTR3NPLIB           = Nemu Guest User Libraries Non-pedantic
TEMPLATE_NEMUGUESTR3NPLIB_EXTENDS   = NEMUGUESTR3NPEXE
TEMPLATE_NEMUGUESTR3NPLIB_INST      = $(INST_ADDITIONS_LIB)


#
# Template for XFree86 guest modules (relocatable module, i.e. sysmod).
# This mostly about zapping the NEMUR3EXE linker flags and libraries.
#
TEMPLATE_NEMUGUESTR3XF86MOD       = Nemu XFree86 Guest Module
TEMPLATE_NEMUGUESTR3XF86MOD_EXTENDS = NEMUGUESTR3EXE
TEMPLATE_NEMUGUESTR3XF86MOD_LIBS.$(KBUILD_TYPE)      = $(NO_SUCH_VARIABLE)
TEMPLATE_NEMUGUESTR3XF86MOD_LIBS.$(KBUILD_TARGET)    = $(NO_SUCH_VARIABLE)
TEMPLATE_NEMUGUESTR3XF86MOD_LDFLAGS.$(KBUILD_TARGET) = $(NO_SUCH_VARIABLE)
TEMPLATE_NEMUGUESTR3XF86MOD_LDFLAGS.$(KBUILD_TYPE)   = $(NO_SUCH_VARIABLE)
TEMPLATE_NEMUGUESTR3XF86MOD_LDFLAGS          = -r
if1of ($(KBUILD_TARGET), dragonfly freebsd linux netbsd openbsd) # the gnu ld guys.
 TEMPLATE_NEMUGUESTR3XF86MOD_LDFLAGS.release = -S
 TEMPLATE_NEMUGUESTR3XF86MOD_LDFLAGS.x86     = -m elf_i386
 TEMPLATE_NEMUGUESTR3XF86MOD_LDFLAGS.amd64   = -m elf_x86_64
endif
TEMPLATE_NEMUGUESTR3XF86MOD_CFLAGS  = $(TEMPLATE_NEMUGUESTR3EXE_CFLAGS)   -fno-merge-constants -std=c99 -ffreestanding
TEMPLATE_NEMUGUESTR3XF86MOD_CXXFLAGS= $(TEMPLATE_NEMUGUESTR3EXE_CXXFLAGS) -fno-merge-constants -ffreestanding
ifeq ($(NEMU_WITH_COMPATIBLE_LINUX_GUEST_PACKAGE),)
 TEMPLATE_NEMUGUESTR3XF86MOD_CFLAGS   += $(NEMU_GCC_fno-stack-protector)
 TEMPLATE_NEMUGUESTR3XF86MOD_CXXFLAGS += $(NEMU_GCC_fno-stack-protector)
endif
TEMPLATE_NEMUGUESTR3XF86MOD_SYSSUFF = .o
TEMPLATE_NEMUGUESTR3XF86MOD_LIBS  = \
	$(NEMU_LIB_VBGL_R3_XFREE86)
TEMPLATE_NEMUGUESTR3XF86MOD_DEFS  = $(TEMPLATE_NEMUGUESTR3DLL_DEFS) NEMU_GUESTR3XF86MOD RTMEM_NO_WRAP_TO_EF_APIS


#
# Template for XFree86 guest libraries.
#
TEMPLATE_NEMUGUESTR3XF86LIB         = Nemu XFree86 Guest Library
TEMPLATE_NEMUGUESTR3XF86LIB_EXTENDS = NEMUGUESTR3XF86MOD
TEMPLATE_NEMUGUESTR3XF86LIB_INST    = $(INST_ADDITIONS_LIB)


#
# Template for X.org guest modules (shared libs).
# This mostly about zapping unnecessary LIBS from NEMUGUESTR3DLL and adding some flags.
#
TEMPLATE_NEMUGUESTR3XORGMOD       = Nemu X.org Guest Module
TEMPLATE_NEMUGUESTR3XORGMOD_EXTENDS = NEMUGUESTR3DLL
TEMPLATE_NEMUGUESTR3XORGMOD_LIBS.$(KBUILD_TYPE)     = $(NO_SUCH_VARIABLE)
TEMPLATE_NEMUGUESTR3XORGMOD_LIBS.$(KBUILD_TARGET)   = $(NO_SUCH_VARIABLE)
TEMPLATE_NEMUGUESTR3XORGMOD_CFLAGS                  = $(TEMPLATE_NEMUGUESTR3DLL_CFLAGS) -std=c99
if1of ($(KBUILD_TARGET), linux)
 TEMPLATE_NEMUGUESTR3XORGMOD_CFLAGS                += -Wno-conversion -Wno-unused-parameter
 ifeq ($(NEMU_WITH_COMPATIBLE_LINUX_GUEST_PACKAGE),)
  TEMPLATE_NEMUGUESTR3XORGMOD_CFLAGS               += $(NEMU_GCC_Wno-variadic-macros)
 endif
endif
TEMPLATE_NEMUGUESTR3XORGMOD_DEFS = $(TEMPLATE_NEMUGUESTR3DLL_DEFS) NEMU_GUESTR3XORGMOD RTMEM_NO_WRAP_TO_EF_APIS
ifeq ($(KBUILD_TARGET_ARCH),amd64)
 TEMPLATE_NEMUGUESTR3XORGMOD_DEFS += _XSERVER64
endif
TEMPLATE_NEMUGUESTR3XORGMOD_LIBS = \
	$(NEMU_LIB_VBGL_R3_XORG)
TEMPLATE_NEMUGUESTR3XORGMOD_LIBS.freebsd += \
	iconv


#
# Template for X.Org guest libraries.
#
TEMPLATE_NEMUGUESTR3XORGLIB         = Nemu X.Org Guest Library
TEMPLATE_NEMUGUESTR3XORGLIB_EXTENDS = NEMUGUESTR3XORGMOD
TEMPLATE_NEMUGUESTR3XORGLIB_INST    = $(INST_ADDITIONS_LIB)


#
# Template for building R0 drivers for the guest additions.
#
TEMPLATE_NEMUGUESTR0             = Nemu Guest Driver
TEMPLATE_NEMUGUESTR0_EXTENDS     = NEMUR0DRV
TEMPLATE_NEMUGUESTR0_INST        = $(INST_ADDITIONS)
TEMPLATE_NEMUGUESTR0_SDKS.win.x86   = ReorderCompilerIncs $(NEMU_WINDDK_GST) $(NEMU_WINPSDK_GST)INCS
TEMPLATE_NEMUGUESTR0_SDKS.win.amd64 = ReorderCompilerIncs $(NEMU_WINDDK_GST) $(NEMU_WINPSDK_GST)INCS
TEMPLATE_NEMUGUESTR0_LIBS.win.x86   = \
	$(PATH_SDK_$(NEMU_WINDDK)_LIB)/int64.lib
TEMPLATE_NEMUGUESTR0_DEFS        = $(TEMPLATE_NEMUR0DRV_DEFS) IN_GUEST IN_GUEST_R0
TEMPLATE_NEMUGUESTR0_DEFS.linux  = RT_NO_EXPORT_SYMBOL
ifeq ($(KBUILD_TARGET),solaris)
 TEMPLATE_NEMUGUESTR0_LDFLAGS    = -r -dy
endif
ifn1of (darwin os2 win, $(KBUILD_TARGET))
 TEMPLATE_NEMUGUESTR0_CFLAGS     = $(patsubst %/Nemu/SUPDrvMangling.h,%/Nemu/NemuGuestMangling.h,$(TEMPLATE_NEMUR0DRV_CFLAGS))
 TEMPLATE_NEMUGUESTR0_CXXFLAGS   = $(patsubst %/Nemu/SUPDrvMangling.h,%/Nemu/NemuGuestMangling.h,$(TEMPLATE_NEMUR0DRV_CXXFLAGS))
endif

#
# Template for building R0 libraries for the guest additions.
#
TEMPLATE_NEMUGUESTR0LIB          = Nemu Guest Driver Libraries
TEMPLATE_NEMUGUESTR0LIB_EXTENDS  = NEMUGUESTR0
TEMPLATE_NEMUGUESTR0LIB_INSTTYPE = stage
TEMPLATE_NEMUGUESTR0LIB_INSTTYPE.linux = stage
TEMPLATE_NEMUGUESTR0LIB_INST     = $(INST_ADDITIONS_LIB)
ifeq ($(KBUILD_TARGET),haiku)
 TEMPLATE_NEMUGUESTR0LIB_LDFLAGS = -r -dy
endif

#
# Template for building OpenGL host dlls.
#
TEMPLATE_NEMUCROGLR3HOSTDLL                  = Nemu OpenGL Host DLLs
TEMPLATE_NEMUCROGLR3HOSTDLL_EXTENDS          = NEMUR3NP
TEMPLATE_NEMUCROGLR3HOSTDLL_EXTENDS_BY       = prepending
TEMPLATE_NEMUCROGLR3HOSTDLL_DEFS             = CHROMIUM_THREADSAFE NEMU_WITH_HGCM UNPACKS
TEMPLATE_NEMUCROGLR3HOSTDLL_DEFS.win         = _WIN32_WINNT=0x0500 WINDOWS=1
TEMPLATE_NEMUCROGLR3HOSTDLL_DEFS.linux       = Linux=1 _GNU_SOURCE
TEMPLATE_NEMUCROGLR3HOSTDLL_DEFS.solaris     = SunOS=1 _GNU_SOURCE #GLEXT_64_TYPES_DEFINED
TEMPLATE_NEMUCROGLR3HOSTDLL_DEFS.darwin      = DARWIN=1 GL_GLEXT_LEGACY _GNU_SOURCE NEMU_WITH_COCOA_QT
TEMPLATE_NEMUCROGLR3HOSTDLL_LDFLAGS.darwin   = -framework AppKit
TEMPLATE_NEMUCROGLR3HOSTDLL_DEFS.freebsd     = FreeBSD=1 _GNU_SOURCE
TEMPLATE_NEMUCROGLR3HOSTDLL_INCS             = $(NEMU_PATH_CROGL_INCLUDE) $(NEMU_PATH_CROGL_GENFILES)
TEMPLATE_NEMUCROGLR3HOSTDLL_SDKS.darwin      = DARWIN-OPENGL
TEMPLATE_NEMUCROGLR3HOSTDLL_LDFLAGS.darwin  += \
	-framework OpenGL \
	-current_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-compatibility_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)
TEMPLATE_NEMUCROGLR3HOSTDLL_LDFLAGS.linux    = -Wl,--no-as-needed
TEMPLATE_NEMUCROGLR3HOSTDLL_BLDDIRS          = $(NEMU_PATH_CROGL_GENFILES)/

#
# Template for building OpenGL host libraries.
#
TEMPLATE_NEMUCROGLR3HOSTLIB         = Nemu OpenGL Host Libraries
TEMPLATE_NEMUCROGLR3HOSTLIB_EXTENDS = NEMUCROGLR3HOSTDLL
TEMPLATE_NEMUCROGLR3HOSTLIB_INST    = $(INST_LIB)

#
# Template for building OpenGL guest dlls.
#
TEMPLATE_NEMUCROGLR3GUESTDLL                  = Nemu OpenGL Guest DLLs
TEMPLATE_NEMUCROGLR3GUESTDLL_EXTENDS          = NEMUGUESTR3NPDLL
TEMPLATE_NEMUCROGLR3GUESTDLL_EXTENDS_BY       = prepending
TEMPLATE_NEMUCROGLR3GUESTDLL_DEFS             = CHROMIUM_THREADSAFE NEMU_WITH_HGCM
TEMPLATE_NEMUCROGLR3GUESTDLL_DEFS.win         = WINDOWS=1
TEMPLATE_NEMUCROGLR3GUESTDLL_DEFS.linux       = Linux=1 _GNU_SOURCE
TEMPLATE_NEMUCROGLR3GUESTDLL_DEFS.solaris     = SunOS=1 _GNU_SOURCE #GLEXT_64_TYPES_DEFINED
TEMPLATE_NEMUCROGLR3GUESTDLL_DEFS.darwin      = DARWIN=1 GL_GLEXT_LEGACY _GNU_SOURCE NEMU_WITH_COCOA_QT
TEMPLATE_NEMUCROGLR3GUESTDLL_LDFLAGS.darwin   = -framework AppKit
TEMPLATE_NEMUCROGLR3GUESTDLL_DEFS.freebsd     = FreeBSD=1 _GNU_SOURCE
TEMPLATE_NEMUCROGLR3GUESTDLL_INCS             = $(NEMU_PATH_CROGL_INCLUDE) $(NEMU_PATH_CROGL_GENFILES)
TEMPLATE_NEMUCROGLR3GUESTDLL_SDKS.darwin      = DARWIN-OPENGL
TEMPLATE_NEMUCROGLR3GUESTDLL_LDFLAGS.darwin  += \
	-framework OpenGL \
	-current_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD) \
	-compatibility_version $(NEMU_VERSION_MAJOR).$(NEMU_VERSION_MINOR).$(NEMU_VERSION_BUILD)
TEMPLATE_NEMUCROGLR3GUESTDLL_BLDDIRS          = $(NEMU_PATH_CROGL_GENFILES)/

#
# Template for building OpenGL guest libraries.
#
TEMPLATE_NEMUCROGLR3GUESTLIB         = Nemu OpenGL Guest Libraries
TEMPLATE_NEMUCROGLR3GUESTLIB_EXTENDS = NEMUCROGLR3GUESTDLL
TEMPLATE_NEMUCROGLR3GUESTLIB_INST    = $(INST_ADDITIONS_LIB)


#
# Template for building Mesa guest library, Linux-only so far.
#
TEMPLATE_NEMUMESAR3GUESTLIB         = Nemu Mesa Guest Library
TEMPLATE_NEMUMESAR3GUESTLIB_EXTENDS = NEMUCROGLR3GUESTDLL
TEMPLATE_NEMUMESAR3GUESTLIB_INST    = $(INST_ADDITIONS_LIB)
TEMPLATE_NEMUMESAR3GUESTLIB_DEFS.linux   = Linux=1
TEMPLATE_NEMUMESAR3GUESTLIB_DEFS.solaris = SunOS=1
TEMPLATE_NEMUMESAR3GUESTLIB_DEFS.darwin  = DARWIN=1 GL_GLEXT_LEGACY
ifeq ($(KBUILD_TARGET),linux)
 TEMPLATE_NEMUMESAR3GUESTLIB_ASTOOL              = $(TEMPLATE_NEMUCROGLR3GUESTDLL_TOOL)
 TEMPLATE_NEMUMESAR3GUESTLIB_ASFLAGS             = $(NO_SUCH_VARIABLE)
 TEMPLATE_NEMUMESAR3GUESTLIB_ASFLAGS.x86         = -m32
 TEMPLATE_NEMUMESAR3GUESTLIB_ASFLAGS.amd64       = -m64
 TEMPLATE_NEMUMESAR3GUESTLIB_ASDEFS              = $(NO_SUCH_VARIABLE)
endif


#
# Guest additions libraries (all static).
#   The _MINI and _SHARED are both compiled as PIC and intended for linking into a .so/.dll/.dylib.
#
NEMU_LIB_IPRT_GUEST_R3           = $(NEMU_PATH_ADDITIONS_LIB)/RuntimeGuestR3$(NEMU_SUFF_LIB)
NEMU_LIB_IPRT_GUEST_R3_SHARED    = $(NEMU_PATH_ADDITIONS_LIB)/RuntimeGuestR3Shared$(NEMU_SUFF_LIB)
NEMU_LIB_IPRT_GUEST_R0           = $(NEMU_PATH_ADDITIONS_LIB)/RuntimeGuestR0$(NEMU_SUFF_LIB)
ifeq ($(KBUILD_TARGET_ARCH),x86)
 NEMU_LIB_IPRT_GUEST_R0_NT4      = $(NEMU_PATH_ADDITIONS_LIB)/RuntimeGuestR0NT4$(NEMU_SUFF_LIB)
else
 NEMU_LIB_IPRT_GUEST_R0_NT4      = $(NEMU_LIB_IPRT_GUEST_R0)
endif
NEMU_LIB_VBGL_R3                 = $(NEMU_PATH_ADDITIONS_LIB)/NemuGuestR3Lib$(NEMU_SUFF_LIB) \
				   $(if $(NEMU_WITH_DRAG_AND_DROP),$(NEMU_PATH_ADDITIONS_LIB)/NemuDnDGuestR3Lib$(NEMU_SUFF_LIB))
NEMU_LIB_VBGL_R3_XFREE86         = $(NEMU_PATH_ADDITIONS_LIB)/NemuGuestR3LibXFree86$(NEMU_SUFF_LIB)
NEMU_LIB_VBGL_R3_XORG            = $(NEMU_PATH_ADDITIONS_LIB)/NemuGuestR3LibXOrg$(NEMU_SUFF_LIB)
NEMU_LIB_VBGL_R3_SHARED          = $(NEMU_PATH_ADDITIONS_LIB)/NemuGuestR3LibShared$(NEMU_SUFF_LIB)
NEMU_LIB_VBGL_R0BASE             = $(NEMU_PATH_ADDITIONS_LIB)/NemuGuestR0LibBase$(NEMU_SUFF_LIB)
NEMU_LIB_VBGL_R0                 = $(NEMU_PATH_ADDITIONS_LIB)/NemuGuestR0Lib$(NEMU_SUFF_LIB)
ifeq ($(KBUILD_TARGET),x86)
 NEMU_LIB_IPRT_GUEST_R3_X86      = $(NEMU_LIB_IPRT_GUEST_R3)
 NEMU_LIB_IPRT_GUEST_R3_SHARED_X86 = $(NEMU_LIB_IPRT_GUEST_R3_SHARED)
 NEMU_LIB_VBGL_R3_X86            = $(NEMU_LIB_VBGL_R3)
 NEMU_LIB_VBGL_R3_SHARED_X86     = $(NEMU_LIB_VBGL_R3_SHARED)
else
 NEMU_LIB_IPRT_GUEST_R3_X86      = $(NEMU_PATH_ADDITIONS_LIB)/RuntimeGuestR3-x86$(NEMU_SUFF_LIB)
 NEMU_LIB_IPRT_GUEST_R3_SHARED_X86 = $(NEMU_PATH_ADDITIONS_LIB)/RuntimeGuestR3Shared-x86$(NEMU_SUFF_LIB)
 NEMU_LIB_VBGL_R3_X86            = $(NEMU_PATH_ADDITIONS_LIB)/NemuGuestR3Lib-x86$(NEMU_SUFF_LIB)
 NEMU_LIB_VBGL_R3_SHARED_X86     = $(NEMU_PATH_ADDITIONS_LIB)/NemuGuestR3LibShared-x86$(NEMU_SUFF_LIB)
endif


#
# Check the publisher and version string.
#
# We are being very strict because the version string is visible in various
# APIs and logs and must be machine readable.
#
NEMU_VERSION_COMP_VALID_CHAR_SET = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz()[]{}+-.,
ifneq ($(NEMU_BUILD_PUBLISHER),)
 if $(length $(NEMU_BUILD_PUBLISHER)) > 10
  $(error Nemu: NEMU_BUILD_PUBLISHER must not be longer than 10 characters!)
 endif
 if "$(substr $(NEMU_BUILD_PUBLISHER), 1, 1)" != "_"
  $(error Nemu: NEMU_BUILD_PUBLISHER must start with an underscore!)
 endif
 if "$(translate $(substr $(NEMU_BUILD_PUBLISHER),2),$(NEMU_VERSION_COMP_VALID_CHAR_SET),)" != ""
  $(error Nemu: NEMU_BUILD_PUBLISHER='$(NEMU_BUILD_PUBLISHER)' contains bad characters! Valid set is:$(NLTAB)$(NEMU_VERSION_COMP_VALID_CHAR_SET))
 endif
endif

if $(words $(NEMU_VERSION_STRING)) != 1
 $(error Nemu: NEMU_VERSION_STRING='$(NEMU_VERSION_STRING)' contains spaces or is empty.)
endif
if "$(subst __,-,$(NEMU_VERSION_STRING))" != "$(NEMU_VERSION_STRING)"
 $(error Nemu: NEMU_VERSION_STRING='$(NEMU_VERSION_STRING)' contains double underscores.)
endif

NEMU_VER_TMP1 := $(subst _,$(SP),$(NEMU_VERSION_STRING))

if $(words $(NEMU_VER_TMP1)) > 3
 $(error Nemu: NEMU_VERSION_STRING='$(NEMU_VERSION_STRING)' contains too many parts (underscores), max 3!)
endif
if "$(translate $(word 1,$(NEMU_VER_TMP1)),0123456789,)" != ".."
 $(error Nemu: The x.y.z part of NEMU_VERSION_STRING='$(NEMU_VERSION_STRING)' is malformed: '$(word 1,$(NEMU_VER_TMP1))')
endif
if "$(word 1,$(NEMU_VER_TMP1))" != "$(NEMU_VERSION_STRING_RAW)"
 $(error Nemu: NEMU_VERSION_STRING='$(NEMU_VERSION_STRING)' does not start with NEMU_VERSION_STRING_RAW='$(NEMU_VERSION_STRING_RAW)')
endif

if $(words $(NEMU_VER_TMP1)) == 3 || ($(words $(NEMU_VER_TMP1)) == 2 && "$(NEMU_BUILD_PUBLISHER)" == "")
 if      "$(substr $(word 2,$(NEMU_VER_TMP1)),1,4)" == "BETA"
  NEMU_VER_TMP2 = 5
 else if "$(substr $(word 2,$(NEMU_VER_TMP1)),1,5)" == "ALPHA"
  NEMU_VER_TMP2 = 6
 else if "$(substr $(word 2,$(NEMU_VER_TMP1)),1,2)" == "RC"
  NEMU_VER_TMP2 = 3
 else
  $(error Nemu: NEMU_VERSION_STRING='$(NEMU_VERSION_STRING)' uses an unknown build type: '$(word 2,$(NEMU_VER_TMP1))')
 endif
 if "$(translate $(substr $(word 2,$(NEMU_VER_TMP1)),$(NEMU_VER_TMP2)),0123456789)" != ""
  $(error Nemu: NEMU_VERSION_STRING='$(NEMU_VERSION_STRING)' uses an unknown build type: '$(word 2,$(NEMU_VER_TMP1))')
 endif
endif

NEMU_VER_TMP1 :=
NEMU_VER_TMP2 :=


#
# Two targets to coordinate version number changes properly. Note that the
# only way to get a really consistent build is to run 'kmk' in the top-level
# directory. If you don't run it there, you get a consistent sub-tree only.
#
NEMU_BAD_CHAR_SET   = ,;:/\$(SP)$(TAB)$(HASH)=![]@%&''()*""<>?^{}|~
NEMU_VERSION_STAMP  = $(PATH_OUT)/version-stamp-raw-api-$(translate $(NEMU_VERSION_STRING)-$(NEMU_C_YEAR)-$(NEMU_VENDOR)-$(NEMU_PRODUCT)-$(NEMU_API_VERSION)-$(NEMU_BUILD_PUBLISHER)-$(USERNAME),$(NEMU_BAD_CHAR_SET),,_)
NEMU_VERSION_HEADER = $(PATH_OUT)/version-generated.h
NEMU_VERSION_MK     = $(PATH_OUT)/version-generated.mk

$(NEMU_VERSION_STAMP): | $(PATH_ROOT)/Config.kmk
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(RM) -f $(wildcard $(PATH_OUT)/version-stamp-*)
	$(QUIET)$(APPEND) $@ $(NEMU_VERSION_STRING)

$(NEMU_VERSION_HEADER): $(NEMU_VERSION_STAMP)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(RM) -f $@ $@.tmp
	$(QUIET)$(APPEND) $@.tmp '#ifndef ___version_generated_h___'
	$(QUIET)$(APPEND) $@.tmp '#define ___version_generated_h___'
	$(QUIET)$(APPEND) $@.tmp ''
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_VERSION_MAJOR $(NEMU_VERSION_MAJOR)'
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_VERSION_MINOR $(NEMU_VERSION_MINOR)'
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_VERSION_BUILD $(NEMU_VERSION_BUILD)'
ifneq ($(NEMU_VERSION_PRERELEASE),)
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_VERSION_PRERELEASE "$(strip $(NEMU_VERSION_PRERELEASE))"'
endif
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_VERSION_STRING_RAW "$(NEMU_VERSION_STRING_RAW)"'
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_VERSION_STRING "$(NEMU_VERSION_STRING)"'
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_API_VERSION_STRING "$(NEMU_API_VERSION)"'
	$(QUIET)$(APPEND) $@.tmp ''
ifdef NEMU_BUILD_SERVER_BUILD
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_BUILD_SERVER_BUILD 1'
else
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_PRIVATE_BUILD_DESC "Private build by $(USERNAME)"'
endif
	$(QUIET)$(APPEND) $@.tmp ''
	$(QUIET)$(APPEND) $@.tmp '#endif'
	$(QUIET)$(MV) -f $@.tmp $@


NEMU_PACKAGE_HEADER = $(PATH_OUT)/package-generated.h

$(NEMU_PACKAGE_HEADER):
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(RM) -f $@ $@.tmp
	$(QUIET)$(APPEND) $@.tmp '#ifndef ___package_generated_h___'
	$(QUIET)$(APPEND) $@.tmp '#define ___package_generated_h___'
	$(QUIET)$(APPEND) $@.tmp ''
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_PACKAGE_STRING "$(NEMU_PACKAGE_STRING)"'
	$(QUIET)$(APPEND) $@.tmp ''
	$(QUIET)$(APPEND) $@.tmp '#endif'
	$(QUIET)$(MV) -f $@.tmp $@

NEMU_PRODUCT_HEADER = $(PATH_OUT)/product-generated.h

$(NEMU_PRODUCT_HEADER): $(NEMU_VERSION_STAMP)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(RM) -f $@ $@.tmp
	$(QUIET)$(APPEND) $@.tmp '#ifndef ___product_generated_h___'
	$(QUIET)$(APPEND) $@.tmp '#define ___product_generated_h___'
	$(QUIET)$(APPEND) $@.tmp ''
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_VENDOR "$(NEMU_VENDOR)"'
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_VENDOR_SHORT "$(NEMU_VENDOR_SHORT)"'
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_PRODUCT "$(NEMU_PRODUCT)"'
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_BUILD_PUBLISHER "$(NEMU_BUILD_PUBLISHER)"'
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_C_YEAR "$(NEMU_C_YEAR)"'
	$(QUIET)$(APPEND) $@.tmp ''
	$(QUIET)$(APPEND) $@.tmp '#endif'
	$(QUIET)$(MV) -f $@.tmp $@

#
# Used for external makefiles which cannot include Config.kmk
#
$(NEMU_VERSION_MK): $(NEMU_VERSION_STAMP)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(RM) -f $@ $@.tmp
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(APPEND) $@.tmp 'NEMU_VERSION_MAJOR = $(NEMU_VERSION_MAJOR)'
	$(QUIET)$(APPEND) $@.tmp 'NEMU_VERSION_MINOR = $(NEMU_VERSION_MINOR)'
	$(QUIET)$(APPEND) $@.tmp 'NEMU_VERSION_BUILD = $(NEMU_VERSION_BUILD)'
	$(QUIET)$(APPEND) $@.tmp 'NEMU_VERSION_STRING = $(NEMU_VERSION_STRING)'
ifneq ($(NEMU_VERSION_PRERELEASE),)
	$(QUIET)$(APPEND) $@.tmp 'NEMU_VERSION_PRERELEASE = $(strip $(NEMU_VERSION_PRERELEASE))'
endif
	$(QUIET)$(APPEND) $@.tmp 'NEMU_VENDOR = $(NEMU_VENDOR)'
	$(QUIET)$(APPEND) $@.tmp 'NEMU_VENDOR_SHORT = $(NEMU_VENDOR_SHORT)'
	$(QUIET)$(APPEND) $@.tmp 'NEMU_PRODUCT = $(NEMU_PRODUCT)'
	$(QUIET)$(APPEND) $@.tmp 'NEMU_C_YEAR = $(NEMU_C_YEAR)'
ifdef NEMU_BUILD_SERVER_BUILD
	$(QUIET)$(APPEND) $@.tmp 'NEMU_BUILD_SERVER_BUILD = 1'
else
	$(QUIET)$(APPEND) $@.tmp 'NEMU_PRIVATE_BUILD_DESC = Private build by $(USERNAME)'
endif
	$(QUIET)$(MV) -f $@.tmp $@

if !defined(NEMU_OSE) && !defined(NEMU_NOINC_LICENSE_VER_KMK)
 if1of ($(KBUILD_TARGET), freebsd linux netbsd openbsd solaris)
  # NEMU_LICENSE_VER is used in several Makefiles
  NEMU_LICENSE_VER_KMK = $(PATH_OUT)/license-version.kmk
$(NEMU_LICENSE_VER_KMK): $(NEMU_BRAND_LICENSE_HTML)
	$(call MSG_GENERATE,,$(NEMU_LICENSE_VER_KMK))
	$(QUIET)$(MKDIR) -p $(@D)
  ifdef NEMU_BRAND_LICENSE_VER
	$(QUIET)$(RM) -f '$@'
	$(APPEND) '$@' 'NEMU_LICENSE_VER=$(NEMU_BRAND_LICENSE_VER)'
  else
	$(QUIET)$(SED) -e "s/.*License version \([0-9.]*\) *[,&].*/NEMU_LICENSE_VER=\1/;t;d" --output $@ $(NEMU_BRAND_LICENSE_HTML)
  endif
  -include $(NEMU_LICENSE_VER_KMK)
  ifdef NEMU_LICENSE_VER
   NEMU_LICENSE_FILES = \
	 License-$(NEMU_LICENSE_VER).html \
	 $(foreach f,$(NEMU_INSTALLER_ADD_LANGUAGES),License-$(NEMU_LICENSE_VER)-$(f).html)
   NEMU_LICENSE_BINS = $(addprefix $(PATH_STAGE_BIN)/,$(NEMU_LICENSE_FILES))
  endif
 endif
endif


ifndef NEMU_NOINC_MISC
# Force building of the version header file as the first thing anywhere in
# the tree. This eliminates the need for manual dependencies on it.
## @todo there gotta be a better way of doing this.
Makefile.kmk: | $(NEMU_VERSION_HEADER) $(NEMU_VERSION_MK) $(NEMU_PRODUCT_HEADER) $(NEMU_PACKAGE_HEADER)
endif


#
# Subversion tree revision.
#
# The NEMU_SVN_REV contains our best guess.  Use svn info on the root of the
# tree to determine this it if .svn/wc.db or .svn/entries is found (the former
# also up to two directory levels higher to allow for checkouts of the entire
# repository), otherwise fall back on the Config.kmk revision.
#
# Makefile rules using this information shall list $(NEMU_SVN_REV_KMK) as a
# prerequisite.
#
SVN                    ?= svn$(HOSTSUFF_EXE)
NEMU_SVN_REV_KMK        = $(PATH_OUT)/revision.kmk
ifndef NEMU_SVN_REV
 NEMU_SVN_REV_FALLBACK := $(patsubst %:,,  $Rev: 105127 $  )
 NEMU_SVN_DEP          := $(firstword $(wildcard $(PATH_ROOT)/.svn/wc.db $(abspath $(PATH_ROOT)/../.svn/wc.db) $(abspath $(PATH_ROOT)/../../.svn/wc.db) $(PATH_ROOT)/.svn/entries))
 ifeq ($(which $(SVN)),)
  NEMU_SVN_DEP         :=
 endif

# Rule for generating a timestamp and updating the real thing on change.
$(NEMU_SVN_REV_KMK).ts +| $(NEMU_SVN_REV_KMK): $(if $(NEMU_SVN_DEP), $(NEMU_SVN_DEP), $(PATH_ROOT)/Config.kmk)
	$(call MSG_GENERATE,,$(NEMU_SVN_REV_KMK))
	$(QUIET)$(RM) -f $@ $@.tmp
	$(QUIET)$(MKDIR) -p $(@D)
 ifneq ($(NEMU_SVN_DEP),)
	$(REDIRECT) -E 'LC_ALL=C' -wo $@.tmp -- $(SVN) info $(PATH_ROOT)
	$(SED) -e '/^Last Changed Rev/!d'  -e 's/Last Changed Rev\: */export NEMU_SVN_REV=/' --output $@ $@.tmp
	$(QUIET)$(RM) -f $@.tmp
 else
	$(QUIET)$(APPEND) $@ 'export NEMU_SVN_REV=$(NEMU_SVN_REV_FALLBACK)'
 endif
	$(QUIET)$(CP) --changed -fv $@ $(NEMU_SVN_REV_KMK)

 ifndef NEMU_NOINC_SVN_REV_KMK
  include $(NEMU_SVN_REV_KMK)
 endif
else
# allow to overwrite NEMU_SVN_REV externally (mainly for building .debs/.rpms)
$(NEMU_SVN_REV_KMK):
	$(call MSG_GENERATE,,$(NEMU_SVN_REV_KMK))
	$(QUIET)$(RM) -f $@
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(APPEND) $@ 'export NEMU_SVN_REV=$(NEMU_SVN_REV)'
	$(QUIET)echo '* $(NEMU_SVN_REV_KMK) was externally overwritten:'
	$(QUIET)$(CAT) $(NEMU_SVN_REV_KMK)
endif

# only needed for NemuGuest for Linux/FreeBSD guests
NEMU_SVN_REV_HEADER = $(PATH_OUT)/revision-generated.h
$(NEMU_SVN_REV_HEADER): $(NEMU_SVN_REV_KMK)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(RM) -f $@ $@.tmp
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(APPEND) $@.tmp '#define NEMU_SVN_REV $(NEMU_SVN_REV)'
	$(QUIET)$(MV) -f $@.tmp $@

#
# Shared definitions of the XIDL file to use as a source for
# generating various other files (NemuSVC, webservice, docs, front-ends, ...)
#

# Real XIDL source file; from this we strip the <desc> elements to generate
# a second XIDL file, from which the COM/XPCOM IDL files are then generated:
NEMU_XIDL_FILE_SRC     = $(PATH_ROOT)/src/Nemu/Main/idl/VirtualBox.xidl
# second XIDL file to use as source for COM/XPCOM IDL (with stripped docs):
NEMU_XIDL_FILE         = $(PATH_OUT)/obj/VirtualBox_stripped.xidl

# Java stuff.
ifeq ($(KBUILD_TARGET), darwin)
 NEMU_JAVA_COMMANDS = $(firstword $(wildcard \
        /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Commands \
        /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Commands \
        $(if-expr $(NEMU_XCODE_VERSION_MAJOR) >= 4,/System/Library/Frameworks/JavaVM.framework/Versions/A/Commands,) \
        ) /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Commands)
 NEMU_JAVAC     = $(NEMU_JAVA_COMMANDS)/javac
 NEMU_JAVAH     = $(NEMU_JAVA_COMMANDS)/javah
 NEMU_JAR       = $(NEMU_JAVA_COMMANDS)/jar
 NEMU_JAVADOC   = $(NEMU_JAVA_COMMANDS)/javadoc
 NEMU_WSIMPORT  = $(NEMU_JAVA_COMMANDS)/wsimport
 if $(NEMU_XCODE_VERSION_MAJOR) >= 4 # Lion (4.1-preview 5) has a broken CurrentJDK link.  Blindly applying it to 4.0.
  NEMU_JAVA_INC  = $(NEMU_PATH_MACOSX_SDK)/System/Library/Frameworks/JavaVM.framework/Versions/A/Headers
 else
  NEMU_JAVA_INC  = $(NEMU_PATH_MACOSX_SDK)/System/Library/Frameworks/JavaVM.framework/Versions/1.6/Headers
 endif

else

 ifeq ($(KBUILD_TARGET),linux)
  ifeq ($(origin NEMU_JAVA_HOME),undefined)
   # Add correct detection for you distro after the /usr/../java-6-sun line.
   NEMU_JAVA_HOME := $(firstword $(wildcard \
	$(KBUILD_DEVTOOLS)/linux.x86/jdk1.6.0_27 \
	/usr/lib/jvm/java-6-sun  \
	/usr/lib/jvm/java-6-openjdk \
	/usr/lib/jvm/java-6-openjdk-i386 \
	/usr/lib/jvm/java-6-openjdk-amd64 \
	/usr/lib/jvm/java-7-openjdk-i386 \
	/usr/lib/jvm/java-7-openjdk-amd64 \
	/usr/lib/jvm/default-java \
	/usr/lib/jvm/java \
	\
	/usr/lib/jvm/sun-jdk-1.6 \
	) /usr/lib/jvm/java-6-sun)
  endif
 endif

 ifeq ($(KBUILD_TARGET),solaris)
  # NEMU_JAVA_HOME ?= /usr/jdk/jdk1.6.0
  NEMU_JAVA_HOME ?= /usr/java
 endif

 ifeq ($(KBUILD_TARGET),win)
  NEMU_JAVA_HOME ?= c:/jdk
 endif

 NEMU_JAVAC     = $(NEMU_JAVA_HOME)/bin/javac
 NEMU_JAVAH     = $(NEMU_JAVA_HOME)/bin/javah
 NEMU_JAR       = $(NEMU_JAVA_HOME)/bin/jar
 NEMU_JAVADOC   = $(NEMU_JAVA_HOME)/bin/javadoc
 NEMU_WSIMPORT  = $(NEMU_JAVA_HOME)/bin/wsimport
 # correct for targets we care about
 NEMU_MD_OS = $(KBUILD_TARGET)
 NEMU_JAVA_INC  = \
 	$(NEMU_JAVA_HOME)/include \
 	$(NEMU_JAVA_HOME)/include/$(NEMU_MD_OS)
endif


#
# NEMU_SEP needs to be quoted when used on the shell command line.
#
if1of ($(KBUILD_TARGET), os2 win)
 NEMU_SEP = $(SEMICOLON)
else
 NEMU_SEP = $(COLON)
endif
NEMU_JAVAC_OPTS   = -encoding UTF-8 -source 1.5 -target 1.5 -Xlint:unchecked
NEMU_JAVADOC_OPTS = -encoding UTF-8


#
# Legacy.
#
## @todo try remove this.
ifneq ($(LOCALCFG),)
 include $(LOCALCFG)
endif


#
# Some extra goals.
#
.PHONY: up update st stat status
up update::
	$(SVN) up

up2 update2::
	$(SVN) up --ignore-externals

st stat status:
	$(SVN) status

quick:
	$(MAKE) NEMU_QUICK=1

