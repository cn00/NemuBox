# $Id: Makefile.kmk $
## @file
# Sub-Makefile for the Nemu web service.
#
# Warning! This is a seriously complicated makefile!
#

#
# Copyright (C) 2007-2015 Oracle Corporation
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#

# Define NEMU_GSOAP_INSTALLED to something if you have gSOAP's
# "wsdl2h" and "soapcpp2" executables on your PATH somewhere.

#
# Here's an overview how all this works. It's complicated. Essentially,
# lots of files get generated automatically from our XML XIDL file that
# describes the VirtualBox API (../idl/VirtualBox.xidl); as a result,
# no manual coding is necessary when the API changes. All generated
# web service code gets adjusted automatically.
#
# In more detail:
#
# 1) We use xsltproc and websrv-wsdl.xsl to generate a WSDL file from
#    our XML IDL file. WSDL (Web Service Description language) is an XML
#    industry standard that publicly describes a web service.
#    So, the WSDL generated here describes the VirtualBox web
#    service to third-party clients; for example, one can feed it to
#    Java or Perl or some other toolkit that understands WSDL and thus
#    easily write a short script that connects to the web service properly.
#    This WSDL file ends up in $(NEMUWEB_OUT_DIR)/nemuweb.wsdl.
#
# 2) We use xsltproc and websrv-wsdl2gsoapH.xsl to generate a so-called
#    "gSoap header file": $(NEMUWEB_OUT_DIR)/gsoapH_from_xslt.h from
#    the WSDL previously generated.
#    This file looks like a C header file, but really isn't meant
#    to be included by a C compiler. Instead, it just happens to be the
#    format that gSOAP uses to specify SOAP interfaces instead of WSDL.
#    (The reason for this appears to be that gSOAP predates WSDL and
#    thus needed some format to describe the syntax of a web service.)
#
#	 Note that gSOAP now also comes with its own WSDL-to-gsoap.h converter,
#    but the readme mentions some funny license restrictions, so instead we
#    have our own converter in XSLT.
#
# 3) We then feed that pseudo-header file to gSOAP's soapcpp2 compiler,
#    which generates a ton of files in $(NEMUWEB_OUT_DIR), most importantly:
#
#    SOAP_CLIENT_H = $(NEMUWEB_OUT_DIR)/soapStub.h (header file for webservice clients)
#    SOAP_SERVER_H = $(NEMUWEB_OUT_DIR)/soapH.h (header file for webservice servers)
#
#    These are "real" header files that one can use to program a) a webservice client
#    and b) a webservice server. Of course to build b) one will have to write method
#    implementations with useful code that does something. This is where more
#    code generation via XSLT comes in:
#
# 4) We use xsltproc to generate tons of C++ code directly from the XIDL that
#    maps each SOAP method to our COM methods. This large C++ file is
#    $(NEMUWEB_OUT_DIR)/methodmaps.cpp. The actual webservice executable (nemuwebsrv,
#    which acts as an HTTP server) is composed of this file, plus hard-coded
#    method implementations in nemuweb.cpp, plus gSOAP library code for the HTTP
#    server.
#

SUB_DEPTH = ../../../..
include $(KBUILD_PATH)/subheader.kmk

#
# Find the gSOAP toolkit.
#
# Note! We're not using the gSOAP toolkit correctly. The main issue is that
#       compiling soapcpp2.cpp instead of using the library. So, in order
#       to make this work with a locally installed gSOAP toolkit there are
#       some hoops to jump thru to say the least... Shipping soapcpp2.cpp/h
#       is out of the question without also including the two soap tools.
#
# Some observations on distros for OSE / configure:
#       The proposed gentoo ebuild screws up several things in the install phase
#       and thus fails to ship stdsoap2.cpp and relatives.
#
#       debian (2.7.9l-0.2) stuffs stdsoap2.cpp and a handful of the import files
#       into /usr/include/gsoap.
#
#       fedora (2.7.12-fc10.x86_64) uses the default install layout and does not
#       ship stdsoap2.cpp and friends.
#
ifeq ($(NEMU_GSOAP_INSTALLED),)
 NEMU_GSOAP_INSTALLED = 1
 NEMU_PATH_GSOAP := $(lastword $(sort $(wildcard $(KBUILD_DEVTOOLS)/common/gsoap/*)))
 ifeq ($(NEMU_PATH_GSOAP),)
  NEMU_PATH_GSOAP := $(lastword $(sort $(wildcard $(KBUILD_DEVTOOLS_HST)/gsoap/*)))
 endif
 if "$(NEMU_PATH_GSOAP)" == "" && defined(KBUILD_DEVTOOLS_HST)
  NEMU_PATH_GSOAP := $(lastword $(sort $(wildcard $(KBUILD_DEVTOOLS_HST_ALT)/gsoap/*)))
 endif
 ifeq ($(NEMU_PATH_GSOAP),)
  $(warning NEMU_PATH_GSOAP not found...)
  NEMU_GSOAP_INSTALLED =
 endif
else
 NEMU_PATH_GSOAP       := $(NEMU_PATH_GSOAP)
endif
NEMU_PATH_GSOAP_BIN    := $(strip $(NEMU_PATH_GSOAP_BIN))
if "$(NEMU_PATH_GSOAP_BIN)" == ""
 NEMU_PATH_GSOAP_BIN   := $(NEMU_PATH_GSOAP)/bin
 if      "$(KBUILD_HOST)" == "darwin"
  NEMU_PATH_GSOAP_BIN  := $(NEMU_PATH_GSOAP_BIN)/macosx
 else if "$(KBUILD_HOST)" == "win"
  NEMU_PATH_GSOAP_BIN  := $(NEMU_PATH_GSOAP_BIN)/win32
 else if "$(KBUILD_HOST)" == "linux"
  NEMU_PATH_GSOAP_BIN  := $(NEMU_PATH_GSOAP_BIN)/linux386
 else if "$(KBUILD_HOST)" == "solaris"
  if $(NEMU_SOLARIS_11_VERSION) >= 164
   NEMU_PATH_GSOAP_BIN  := $(NEMU_PATH_GSOAP_BIN)/solaris11.x86
  else
   NEMU_PATH_GSOAP_BIN  := $(NEMU_PATH_GSOAP_BIN)/solaris.x86
  endif
 else
  NEMU_PATH_GSOAP_BIN  := $(NEMU_PATH_GSOAP_BIN)/$(KBUILD_HOST).x86
 endif
 if !exists($(NEMU_PATH_GSOAP_BIN))
  NEMU_PATH_GSOAP_BIN  := $(NEMU_PATH_GSOAP)/bin
 endif
endif
NEMU_SOAPCPP2          := $(NEMU_PATH_GSOAP_BIN)/soapcpp2$(HOSTSUFF_EXE)
NEMU_WSDL2H            := $(NEMU_PATH_GSOAP_BIN)/wsdl2h$(HOSTSUFF_EXE)
NEMU_STUBMAKER          = $(firstword $(which stubmaker stubmaker.pl) stubmaker_not_found)
NEMU_WSDL2PY            = $(firstword $(which wsdl2py) wsdl2py_not_found)

NEMU_PATH_GSOAP_IMPORT := $(strip $(if $(NEMU_PATH_GSOAP_IMPORT),$(NEMU_PATH_GSOAP_IMPORT),$(NEMU_PATH_GSOAP)/import))
NEMU_GSOAP_INCS        := $(strip $(if $(NEMU_GSOAP_INCS),$(NEMU_GSOAP_INCS),$(NEMU_PATH_GSOAP) $(NEMU_PATH_GSOAP_IMPORT) ))
# note: $(if $(defined FOO)) does not work here!
NEMU_GSOAP_CXX_SOURCES := $(strip $(if-expr "$(origin NEMU_GSOAP_CXX_SOURCES)" != "undefined",$(NEMU_GSOAP_CXX_SOURCES),$(NEMU_PATH_GSOAP)/stdsoap2.cpp))
NEMU_GSOAP_CXX_LIBS    := $(strip $(if-expr "$(origin NEMU_GSOAP_CXX_LIBS)" != "undefined",$(NEMU_GSOAP_CXX_LIBS),))


#
# Globals
#
NEMUWEB_OUT_DIR := $(PATH_TARGET)/webservice
BLDDIRS += $(NEMUWEB_OUT_DIR)

# The webservice location
NEMU_PATH_WEBSERVICE          := $(PATH_SUB_CURRENT)

# The IDL subdirectory (contains some XSLT files)
NEMU_PATH_IDL                 := $(abspath $(PATH_SUB_CURRENT)/../idl)

# If this is set, all webservice files are considered out-of-date every time
# this makefile is touched. Otherwise, set this to empty.
RECOMPILE_ON_MAKEFILE_CURRENT := $(MAKEFILE_CURRENT)

PATH_TARGET_SOAPDEMOXML       := $(NEMUWEB_OUT_DIR)/demo_soapxml
PATH_TARGET_SOAPDEMOHEADERS   := $(NEMUWEB_OUT_DIR)/demo_headers
PATH_TARGET_SOAPDEMONSMAPS    := $(NEMUWEB_OUT_DIR)/demo_namespacemaps
PATH_TARGET_WEBTEST           := $(NEMUWEB_OUT_DIR)/webtest

# the original XIDL file (has to include documentation as we need it):
NEMUWEB_IDL_SRC_ORIG          := $(NEMU_XIDL_FILE_SRC)
# the original XIDL file without documentation
NEMUWEB_IDL_SRC_STRIPPED      := $(NEMU_XIDL_FILE)
# platform-specific XIDL file generated from $(NEMUWEB_IDL_SRC_STRIPPED):
NEMUWEB_IDL_SRC               := $(NEMUWEB_OUT_DIR)/VirtualBox.xidl

NEMUWEB_WSDL                   = $(NEMUWEB_OUT_DIR)/nemuweb.wsdl
NEMUWEBSERVICE_WSDL            = $(NEMUWEB_OUT_DIR)/nemuwebService.wsdl

NEMUWEB_TYPEMAP               := $(NEMUWEB_OUT_DIR)/typemap.dat

NEMUWEB_GSOAPH_FROM_XSLT      := $(NEMUWEB_OUT_DIR)/gsoapH_from_xslt.h
ifdef NEMU_GSOAP_INSTALLED
 NEMUWEB_GSOAPH_FROM_GSOAP    := $(NEMUWEB_OUT_DIR)/gsoapH_from_gsoap.h
else
 NEMUWEB_GSOAPH_FROM_GSOAP    :=
endif
NEMUWEB_SOAP_CLIENT_H         := $(NEMUWEB_OUT_DIR)/soapStub.h
NEMUWEB_SOAP_SERVER_H         := $(NEMUWEB_OUT_DIR)/soapH.h


ifdef NEMU_GSOAP_VERBOSE
 NEMUWEB_XSLTPROC_VERBOSE      = --stringparam G_argDebug '1'
 NEMUWEB_WSDL_VERBOSE          = -v
else
 NEMUWEB_SOAPCPP2_SKIP_FILES   = -x
endif


## @todo NEMUWEB_GSOAPH_FROM_XSLT should probably be a indirect dep of something.
NEMUWEB_OTHERS += \
	$(NEMUWEB_GSOAPH_FROM_XSLT)


# disable -fvisibility=hidden as the SOAP stuff does not properly set the visibility attributes
TEMPLATE_NEMUWEBR3EXE = Webservices without -fvisibility
TEMPLATE_NEMUWEBR3EXE_EXTENDS = NEMUR3EXE
TEMPLATE_NEMUWEBR3EXE_CXXFLAGS = $(filter-out $(NEMU_GCC_fvisibility-hidden) $(NEMU_GCC_fvisibility-inlines-hidden),\
				 $(TEMPLATE_NEMUR3EXE_CXXFLAGS))

ifdef NEMU_GSOAP_INSTALLED
 ifndef NEMU_ONLY_SDK
 #
 # nemusoap - Library used by both the programs (save build time).
 #
 LIBRARIES += nemusoap
 nemusoap_TEMPLATE = NEMUWEBR3EXE
 nemusoap_CXXFLAGS.win += -bigobj
 ifn1of ($(KBUILD_TARGET), win)
  nemusoap_CXXFLAGS += -Wno-shadow
 endif
 nemusoap_INCS := \
	$(NEMU_GSOAP_INCS) \
	$(NEMUWEB_OUT_DIR) \
	$(PATH_SUB_CURRENT)
 ifdef NEMU_WITH_WEBSERVICES_SSL
  nemusoap_DEFS += WITH_OPENSSL
  nemusoap_SDKS += NEMU_OPENSSL2
 endif
 ifdef NEMU_WITHOUT_SPLIT_SOAPC
  nemusoap_SOURCES = \
	$(NEMUWEB_OUT_DIR)/soapC.cpp
 else
  BLDPROGS += split-soapC
  split-soapC_TEMPLATE = NemuBldProg
  split-soapC_SOURCES = split-soapC.cpp

  nemusoap_SOURCES = \
	$(NEMUWEB_OUT_DIR)/soapC-1.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-2.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-3.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-4.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-5.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-6.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-7.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-8.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-9.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-10.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-11.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-12.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-13.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-14.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-15.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-16.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-17.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-18.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-19.cpp \
	$(NEMUWEB_OUT_DIR)/soapC-20.cpp
  nemusoap_CXXFLAGS += \
	$(NEMU_GCC_Wno-vla)
 endif
 nemusoap_CLEAN := $(nemusoap_SOURCES) # lazy bird
 nemusoap_SOURCES += \
	$(NEMU_GSOAP_CXX_SOURCES)
 nemusoap_ORDERDEPS = \
	$(NEMUWEB_IDL_SRC) \
	$(NEMUWEB_OUT_DIR)/gsoap_copy_all_ts
 ifn1of ($(KBUILD_TARGET), win)
  $(NEMU_GSOAP_CXX_SOURCES)_CXXFLAGS = -Wno-format
  # currently necessary when compiling against OpenSSL 1.0 due to a missing
  # typecase from 'const v3_ext_method*' to 'aka v3_ext_method*'.
  $(NEMU_GSOAP_CXX_SOURCES)_CXXFLAGS += -fpermissive

 endif
 $(NEMUWEB_OUT_DIR)/soapC-3.cpp_CXXFLAGS.win.x86 = -Og- # VCC70 says "function too large".

ifdef NEMU_SOAP_PRECOMPILED_HEADER
 # This'll save a few seconds, but the compiler invocation currently makes it impracticable. This will
 # be addressed in a future kBuild version, by adding PCH support or/and by adding some helpers to
 # gather the required data (DEFS,INCS,CXXTOOL,CXXFLAGS).
 nemusoap_INTERMEDIATES += $(NEMUWEB_OUT_DIR)/soapH.h.gch
 nemusoap_CXXFLAGS += -Winvalid-pch -H
 nemusoap_CLEAN += $(NEMUWEB_OUT_DIR)/soapH.h.gch

$(NEMUWEB_OUT_DIR)/soapH.h.gch: $(NEMUWEB_OUT_DIR)/soapH.h
	g++ -x c++-header -g -g -Wall -pedantic -Wno-long-long -Wno-trigraphs -Wno-variadic-macros -pipe -O0 -fno-omit-frame-pointer -fno-strict-aliasing -fvisibility-inlines-hidden -fvisibility=hidden -DNEMU_HAVE_VISIBILITY_HIDDEN -mmacosx-version-min=10.4 -isysroot /Developer/SDKs/MacOSX10.4u.sdk -m32 -I/Volumes/ScratchHFS/bird/nemu/svn/trunk/src/Nemu/Main/webservice/gsoap -I/Volumes/ScratchHFS/bird/nemu/svn/trunk/out/darwin.x86/debug/obj/src/Nemu/Main -I/Volumes/ScratchHFS/bird/nemu/svn/trunk/src/Nemu/Main/webservice -I/Volumes/ScratchHFS/bird/nemu/svn/trunk/include -I/Volumes/ScratchHFS/bird/nemu/svn/trunk/out/darwin.x86/debug -DNEMU -DNEMU_WITH_DEBUGGER -DNEMU_WITH_DEBUGGER_GUI -DDEBUG -DDEBUG_bird -DDEBUG_USERNAME=bird -DRT_OS_DARWIN -D__DARWIN__ -DRT_ARCH_X86 -D__X86__ -DNEMU_WITH_HYBRID_32BIT_KERNEL -DIN_RING3 -DHC_ARCH_BITS=32 -DGC_ARCH_BITS=32 -DMAC_OS_X_VERSION_MIN_REQUIRED=1040 -DMAC_OS_X_VERSION_MAX_ALLOWED=1040 \
		$< -o $@
endif
 endif # !NEMU_ONLY_SDK


 ifndef NEMU_ONLY_SDK
 #
 # nemuwebsrv - webservice server process
 #
 PROGRAMS += nemuwebsrv
 nemuwebsrv_TEMPLATE = NEMUMAINCLIENTEXE
 nemuwebsrv_DEFS += SOCKET_CLOSE_ON_EXEC
 nemuwebsrv_INCS = \
	$(NEMU_GSOAP_INCS) \
	$(NEMUWEB_OUT_DIR) \
	.
 nemuwebsrv_CXXFLAGS.win += -bigobj
 ifn1of ($(KBUILD_TARGET), win)
  nemuwebsrv_CXXFLAGS += -Wno-shadow
 endif
 nemuwebsrv_LIBS += \
	$(PATH_STAGE_LIB)/nemusoap$(NEMU_SUFF_LIB) \
	$(NEMU_GSOAP_CXX_LIBS) \
	$(LIB_RUNTIME)
 nemuwebsrv_LIBS.solaris += socket nsl
 ifdef NEMU_WITH_WEBSERVICES_SSL
  nemuwebsrv_DEFS += WITH_OPENSSL
  nemuwebsrv_SDKS += NEMU_OPENSSL2
 endif
 nemuwebsrv_SOURCES = \
	nemuweb.cpp \
	$(NEMUWEB_OUT_DIR)/methodmaps.cpp \
	$(NEMUWEB_OUT_DIR)/soapServer.cpp \
    $(NEMUWEB_OUT_DIR)/nemuweb-wsdl.c
 nemuwebsrv_SOURCES.win = \
	NemuWebSrv.rc
 nemuwebsrv_CLEAN = \
	$(NEMUWEB_OUT_DIR)/methodmaps.cpp \
	$(NEMUWEB_OUT_DIR)/soapServer.cpp \
    $(NEMUWEB_OUT_DIR)/nemuweb-wsdl.c

 nemuweb.cpp_DEFS = \
	$(if $(NEMU_BLEEDING_EDGE),NEMU_BLEEDING_EDGE=\"$(NEMU_BLEEDING_EDGE)\",)

 nemuwebsrv_ORDERDEPS = $(NEMUWEB_OUT_DIR)/gsoap_copy_all_ts
 endif # !NEMU_ONLY_SDK

 ifdef NEMU_WITH_JWS
INSTALLS += NemuJWs-inst-jar

#
# Java glue JAR files
#
NEMU_JWS_JAR     = $(NemuJWs-inst-jar_0_OUTDIR)/nemujws.jar
NEMU_JWSDOC_JAR  = $(NemuJWs-inst-jar_0_OUTDIR)/nemujws-doc.jar
NEMU_JWSSRC_JAR  = $(NemuJWs-inst-jar_0_OUTDIR)/nemujws-src.jar
NEMU_JWS_TARGET := $(PATH_TARGET)/nemujws-gen
NEMU_JWS_GEN     = $(NEMU_JWS_TARGET)/jwsgen
NEMU_JWS_GEN_RAWSRC = $(NEMU_JWS_GEN)/merged.file
NEMU_JWS_JDEST  := $(NEMU_JWS_TARGET)/jdest
NEMU_JWSDOC_JDEST  := $(NEMU_JWS_TARGET)/jdest-doc
NEMU_GLUE_XSLT_DIR := $(PATH_ROOT)/src/Nemu/Main/glue
NEMU_JAXLIB_DIR    := $(PATH_ROOT)/src/Nemu/Main/webservice/jaxlibs

NemuJWs-inst-jar_INST = $(INST_SDK)bindings/webservice/java/jax-ws/
NemuJWs-inst-jar_MODE = a+r,u+w
NemuJWs-inst-jar_SOURCES = \
	$(NEMU_JWS_JAR) \
	$(NEMU_JWSDOC_JAR) \
	$(NEMU_JWSSRC_JAR)
NemuJWs-inst-jar_CLEAN = \
	$(NEMU_JWS_JAR) \
	$(NEMU_JWSDOC_JAR) \
	$(NEMU_JWSSRC_JAR) \
	$(NEMU_JWS_GEN)/jwsglue.list \
	$(NEMU_JWSDOC_JDEST)/package-list \
	$(wildcard \
		$(NEMU_JWS_GEN)/java/*/*/*.java \
		$(NEMU_JWS_GEN)/java/*/*/*/*.java \
		$(NEMU_JWS_JDEST)/*.class \
		$(NEMU_JWS_JDEST)/*/*.class \
		$(NEMU_JWS_JDEST)/*/*/*.class \
		$(NEMU_JWS_JDEST)/*/*/*/*.class \
		$(NEMU_JWSDOC_JDEST)/*.html \
		$(NEMU_JWSDOC_JDEST)/*.css \
		$(NEMU_JWSDOC_JDEST)/*/*.gif \
		$(NEMU_JWSDOC_JDEST)/*/*/*.html \
		$(NEMU_JWSDOC_JDEST)/*/*/*/*.html \
	)
NemuJWs-inst-jar_BLDDIRS += $(NEMU_JWS_GEN)/java
NemuJWs-inst-jar_GENERATEDSOURCES = $(addprefix $(NemuJWs-inst-jar_BLDDIRS)/,$(NemuJWS_NEMU_JWSGLUEFILES))

NemuJWSGlue_KMK = $(PATH_OUT)/nemujwsglue.kmk
include $(NemuJWSGlue_KMK)

$(NemuJWSGlue_KMK).ts +| $(NemuJWSGlue_KMK): $(NEMUWEB_IDL_SRC_ORIG) $(NEMU_GLUE_XSLT_DIR)/glue-java.xsl $(NEMU_VERSION_STAMP)
	$(call MSG_GENERATE,,$(NemuJWSGlue_KMK))
	$(QUIET)$(RM) -f $@
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(NEMU_XSLTPROC) \
              --stringparam filelistonly NemuJWS_NEMU_JWSGLUEFILES \
              --stringparam G_nemuApiSuffix $(NEMU_API_SUFFIX) \
              --stringparam G_nemuGlueStyle jaxws              \
              --stringparam G_nemuDirPrefix org/virtualbox$(NEMU_API_SUFFIX)/ \
              -o $@ $(NEMU_GLUE_XSLT_DIR)/glue-java.xsl $<
	$(QUIET)$(CP) --changed -fv $@ $(NemuJWSGlue_KMK)

$(NEMU_JWS_GEN_RAWSRC) \
+| $(NemuJWs-inst-jar_GENERATEDSOURCES): \
		$(NEMUWEB_IDL_SRC_ORIG) \
		$(NEMU_GLUE_XSLT_DIR)/glue-java.xsl \
		$(NEMU_FILESPLIT) \
		$(NEMU_VERSION_STAMP)
	$(call MSG_L1,Generating JAX-WS Java glue files from XIDL)
	$(QUIET)$(RM) -f $(filter-out $(NemuJWs-inst-jar_GENERATEDSOURCES),$(wildcard $(NEMU_JWS_GEN)/java/*/*/*.java))
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(NEMU_XSLTPROC) \
              --stringparam filelistonly "" \
              --stringparam G_nemuApiSuffix $(NEMU_API_SUFFIX) \
              --stringparam G_nemuGlueStyle jaxws              \
              --stringparam G_nemuDirPrefix org/virtualbox$(NEMU_API_SUFFIX)/ \
              -o $(NEMU_JWS_GEN_RAWSRC) $(NEMU_GLUE_XSLT_DIR)/glue-java.xsl $<
	$(QUIET)$(MKDIR) -p $(NEMU_JWS_GEN)/java/org/virtualbox$(NEMU_API_SUFFIX)
	$(QUIET)$(NEMU_FILESPLIT) $(NEMU_JWS_GEN_RAWSRC) $(NEMU_JWS_GEN)/java

## @todo somehow also find out the authoritative list of files generated by
# wsimport (before running it), then we could rely on proper dependencies
# instead of creating jwsglue.list. Would allow avoiding a lot of unnecessary
# compilation with incremental builds, when almost nothing changed in the IDL
# file. Currently everything is recompiled if only one file is changed.
$(NEMU_JWS_GEN)/jwsglue.list.ts +| $(NEMU_JWS_GEN)/jwsglue.list: \
		$(NEMUWEB_IDL_SRC) \
		$(NEMU_FILESPLIT) \
		$(NEMUWEBSERVICE_WSDL) \
		$(NEMUWEB_WSDL) \
		$(NemuJWs-inst-jar_GENERATEDSOURCES) \
		| $(NEMU_JWS_GEN)/java/
	$(QUIET)$(RM) -f -- $(wildcard $(NEMU_JWS_GEN)/java/*/*/*/*.java)
	$(call MSG_GENERATE,,$(NEMU_JWS_GEN)/jwsglue.list,JAX-WS for Java 1.6 bindings using $(NEMUWEBSERVICE_WSDL))
	$(NEMU_WSIMPORT) -Xnocompile -p $(NEMU_JAVA_PACKAGE).jaxws -d $(NEMU_JWS_GEN)/java $(NEMUWEBSERVICE_WSDL)
	$(QUIET)echo $(NemuJWs-inst-jar_GENERATEDSOURCES) > $@
	$(QUIET)echo $(NEMU_JWS_GEN)/java/*/*/*/*.java >> $@
	$(QUIET)$(CP) --changed -fv $@ $(NEMU_JWS_GEN)/jwsglue.list

$$(NEMU_JWS_JAR): $(NEMU_JWS_GEN)/jwsglue.list $(NEMUWEB_WSDL) $(NEMUWEBSERVICE_WSDL) $(NEMU_JWS_GEN)/MANIFEST.MF | $$(dir $$@)
	$(call MSG_TOOL,javac,$(notdir $@),jwsgen.list,)
	$(QUIET)$(RM) -Rf $(NEMU_JWS_JDEST)
	$(QUIET)$(MKDIR) -p $(NEMU_JWS_JDEST)
	$(call MSG_L1,Compiling bridge code)
	$(NEMU_JAVAC) $(NEMU_JAVAC_OPTS) \
                @$(NEMU_JWS_GEN)/jwsglue.list \
		-d $(NEMU_JWS_JDEST) -classpath $(NEMU_JWS_JDEST)
	$(QUIET)$(SED) -e "s/nemuweb.wsdl/nemuweb$(NEMU_API_SUFFIX).wsdl/" <  $(NEMUWEBSERVICE_WSDL) > $(NEMU_JWS_JDEST)/nemuwebService$(NEMU_API_SUFFIX).wsdl
	$(QUIET)$(CP) -f $(NEMUWEB_WSDL) $(NEMU_JWS_JDEST)/nemuweb$(NEMU_API_SUFFIX).wsdl
	$(call MSG_LINK,$(notdir $@),$@)
	$(NEMU_JAR) cfm $@ $(NEMU_JWS_GEN)/MANIFEST.MF -C $(NEMU_JWS_JDEST) .

$(NEMU_JWS_GEN)/MANIFEST.MF: $(NEMU_PATH_WEBSERVICE)/MANIFEST.MF.in
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(MKDIR) -p $(NEMU_JWS_GEN)
	$(QUIET)$(SED) \
		-e 's/@NEMU_VERSION_STRING@/$(NEMU_VERSION_STRING)/' \
		-e 's/@NEMU_VERSION_MAJOR@/$(NEMU_VERSION_MAJOR)/' \
		-e 's/@NEMU_VERSION_MINOR@/$(NEMU_VERSION_MINOR)/' \
		-e 's/@NEMU_API_SUFFIX@/$(NEMU_API_SUFFIX)/' \
		<  $< >  $@

$$(NEMU_JWSDOC_JAR): $(NEMU_JWS_GEN)/jwsglue.list $$(NemuJWs-inst-jar_GENERATEDSOURCES) $(NEMUWEB_WSDL) $(NEMUWEBSERVICE_WSDL) $$(NEMU_JWS_JAR) | $$(dir $$@)
	$(call MSG_TOOL,javadoc,$(notdir $@),jwsgen.list,)
	$(QUIET)$(RM) -Rf $(NEMU_JWSDOC_JDEST)
	$(QUIET)$(MKDIR) -p $(NEMU_JWSDOC_JDEST)
	$(call MSG_L1,Generating javadoc html documentation)
	$(NEMU_JAVADOC) $(NEMU_JAVADOC_OPTS) -quiet \
		-sourcepath $(NEMU_JWS_GEN)/java org.virtualbox$(NEMU_API_SUFFIX) \
		-d $(NEMU_JWSDOC_JDEST)
	$(call MSG_LINK,$(notdir $@),$@)
	$(NEMU_JAR) cf $@ -C $(NEMU_JWSDOC_JDEST) .

$$(NEMU_JWSSRC_JAR): $$(NEMU_JWS_JAR) | $$(dir $$@)
	$(call MSG_LINK,$(notdir $@),$@)
	$(NEMU_JAR) cf $@ -C $(NEMU_JWS_GEN)/java .

## @todo compile ../glue/tests/TestNemu.java to have sanity checking

 endif # NEMU_WITH_JWS

 ifndef NEMU_ONLY_SDK
 #
 # webtest - webservice sample client in C++
 #
 PROGRAMS += webtest
 webtest_TEMPLATE = NEMUWEBR3EXE
 webtest_CXXFLAGS.win += -bigobj
 ifn1of ($(KBUILD_TARGET), win)
  webtest_CXXFLAGS += -Wno-shadow
 endif
 webtest_INCS := \
	$(NEMU_GSOAP_INCS) \
	$(NEMUWEB_OUT_DIR) \
	.
 webtest_LIBS += \
	$(PATH_STAGE_LIB)/nemusoap$(NEMU_SUFF_LIB) \
	$(NEMU_GSOAP_CXX_LIBS) \
	$(LIB_RUNTIME)
 webtest_LIBS.solaris += nsl
 ifdef NEMU_WITH_WEBSERVICES_SSL
  webtest_DEFS += WITH_OPENSSL
  webtest_SDKS += NEMU_OPENSSL2
 endif
 webtest_SOURCES = \
	webtest.cpp \
	$(NEMUWEB_OUT_DIR)/soapClient.cpp
 webtest_CLEAN = \
	$(NEMUWEB_OUT_DIR)/soapClient.cpp

 webtest_ORDERDEPS = $(NEMUWEB_OUT_DIR)/gsoap_copy_all_ts
 endif # !NEMU_ONLY_SDK


 #
 # Additional mess to cleanup (applies to both webtest and nemuwebsrv).
 #
 ## @todo figure out whether the SDK really needs this or not...
 OTHER_CLEAN += \
	$(wildcard $(NEMUWEB_OUT_DIR)/soap*.h) \
	$(wildcard $(NEMUWEB_OUT_DIR)/soap*.cpp) \
	$(wildcard $(NEMUWEB_OUT_DIR)/*.nsmap) \
	$(NEMUWEB_GSOAPH_FROM_XSLT) \
	$(NEMUWEB_GSOAPH_FROM_GSOAP) \
	$(NEMUWEB_SOAP_CLIENT_H) \
	$(NEMUWEB_SOAP_SERVER_H) \
	$(NEMUWEB_OUT_DIR)/gsoap_generate_all_ts \
	$(NEMUWEB_OUT_DIR)/gsoap_copy_all_ts \
	$(wildcard $(PATH_TARGET_SOAPDEMOXML)/*) \
	$(PATH_TARGET_SOAPDEMOXML)/dummy_file \
	$(wildcard $(PATH_TARGET_SOAPDEMOHEADERS)/*) \
	$(PATH_TARGET_SOAPDEMOHEADERS)/dummy_file \
	$(wildcard $(PATH_TARGET_SOAPDEMONSMAPS)/*) \
	$(PATH_TARGET_SOAPDEMONSMAPS)/dummy_file

endif # NEMU_GSOAP_INSTALLED


if defined(NEMU_ONLY_SDK) && "$(KBUILD_TARGET)" != "win"
 #
 # Globals relevant to the SDK.
 #
 NEMUWEB_GLUE_PYTHON           = $(NEMU_PATH_SDK)/bindings/webservice/python/lib/VirtualBox_wrappers.py
 NEMUWEB_WS_PYTHON             = $(NEMU_PATH_SDK)/bindings/webservice/python/lib/VirtualBox_server.py
 NEMUWEB_WS_PERL               = $(NEMU_PATH_SDK)/bindings/webservice/perl/lib/nemuService.pm
 NEMUWEB_WS_PHP                = $(NEMU_PATH_SDK)/bindings/webservice/php/lib/nemuServiceWrappers.php
 NEMUWEB_SAMPLES_JAXWS_DIR     = $(NEMU_PATH_SDK)/bindings/webservice/java/jax-ws/samples
 NEMUWEB_JAXWSSAMPLE           = $(NEMUWEB_SAMPLES_JAXWS_DIR)/clienttest.java
 NEMUWEB_METRICSAMPLE          = $(NEMUWEB_SAMPLES_JAXWS_DIR)/metrictest.java

 define find_java_files
  $(shell find $(1) -name \*.java)
 endef

 NEMUWEB_OTHERS               +=  \
	$(if $(NEMU_WITH_PYTHON),$(NEMUWEB_GLUE_PYTHON),)       \
	$(if $(NEMU_WITH_PYTHON),$(NEMUWEB_WS_PYTHON),)         \
	$(if $(NEMU_WITH_PERL),$(NEMUWEB_WS_PERL),)             \
	$(if $(NEMU_WITH_PHP),$(NEMUWEB_WS_PHP),)               \
	$(PATH_ROOT)


 #
 # Install sample code.
 #
 INSTALLS += nemuwebinst
 nemuwebinst_INST = $(INST_SDK)bindings/webservice/
 nemuwebinst_MODE = a+rx,u+w
 nemuwebinst_SOURCES = \
	$(if $(NEMU_WITH_PERL),samples/perl/clienttest.pl=>perl/samples/clienttest.pl,) \
	$(if $(NEMU_WITH_PHP),samples/php/clienttest.php=>php/samples/clienttest.php,) \
	$(if $(NEMU_WITH_PYTHON),samples/python/clienttest.py=>python/samples/clienttest.py,)

 INSTALLS += nemuwebinst_nox
 nemuwebinst_nox_INST = $(INST_SDK)bindings/webservice/
 nemuwebinst_nox_MODE = a+r,u+w
 nemuwebinst_nox_SOURCES = \
	$(if $(NEMU_WITH_PYTHON),samples/python/Makefile=>python/samples/Makefile,) \
	$(if $(NEMU_WITH_PYTHON),samples/python/Makefile.glue=>python/lib/Makefile,) \
	$(if ($NEMU_WITH_JWS),$(PATH_ROOT)/COPYING.LIB=>java/jax-ws/COPYING.LIB,)

 INSTALLS += nemuwebinst_wsdl
 nemuwebinst_wsdl_INST = $(INST_SDK)bindings/webservice/
 nemuwebinst_wsdl_MODE = a+r,u+w
 nemuwebinst_wsdl_SOURCES = \
	$(NEMUWEB_WSDL)=>nemuweb.wsdl \
	$(NEMUWEBSERVICE_WSDL)=>nemuwebService.wsdl

endif # NEMU_ONLY_SDK

#
# Update the OTHERS and OTHER_CLEAN lists with NEMUWEB_OTHERS and some more stuff.
#
# We can't just built up OTHERS and append it to OTHER_CLEAN because we're sharing
# OTHERS with all the other Nemu makefiles, thus NEMUWEB_OTHERS.
#
OTHERS += $(NEMUWEB_OTHERS)
OTHER_CLEAN += \
	$(NEMUWEB_OTHERS) \
	$(NEMUWEB_WSDL) \
	$(NEMUWEBSERVICE_WSDL) \
	$(NEMUWEB_TYPEMAP) \
	$(NEMUWEB_IDL_SRC)

# generate platform-specific XIDL file from original XIDL file
$(NEMUWEB_IDL_SRC): $(NEMUWEB_IDL_SRC_STRIPPED) $(NEMU_PATH_WEBSERVICE)/platform-xidl.xsl | $$(dir $$@)
	$(call MSG_GENERATE,,$@,$(NEMUWEB_IDL_SRC) using platform-xidl.xsl)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(NEMU_XSLTPROC) $(NEMUWEB_XSLTPROC_VERBOSE) -o $@ $(NEMU_PATH_WEBSERVICE)/platform-xidl.xsl $<

# generate WSDL from main XIDL file
$(NEMUWEB_WSDL): $(NEMUWEB_IDL_SRC) $(NEMU_PATH_WEBSERVICE)/websrv-wsdl.xsl $(NEMU_PATH_IDL)/typemap-shared.inc.xsl $(RECOMPILE_ON_MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@,$(NEMUWEB_IDL_SRC) using websrv-wsdl.xsl)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(NEMU_XSLTPROC) $(NEMUWEB_XSLTPROC_VERBOSE) -o $@ $(NEMU_PATH_WEBSERVICE)/websrv-wsdl.xsl $<

$(NEMUWEBSERVICE_WSDL): $(NEMUWEB_IDL_SRC) $(NEMU_PATH_WEBSERVICE)/websrv-wsdl-service.xsl $(NEMU_PATH_IDL)/typemap-shared.inc.xsl $(RECOMPILE_ON_MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@,$(NEMUWEB_IDL_SRC) using websrv-wsdl-service.xsl)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(NEMU_XSLTPROC) $(NEMUWEB_XSLTPROC_VERBOSE) -o $@ $(NEMU_PATH_WEBSERVICE)/websrv-wsdl-service.xsl $<

ifdef NEMU_ONLY_SDK

$(NEMUWEB_GLUE_PYTHON): $(NEMUWEB_IDL_SRC) $(NEMUWEB_WSDL) $(NEMUWEBSERVICE_WSDL) $(NEMU_PATH_WEBSERVICE)/websrv-python.xsl
	$(call MSG_GENERATE,,$@,$(NEMUWEB_IDL_SRC) using websrv-python.xsl)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(NEMU_XSLTPROC) $(NEMUWEB_XSLTPROC_VERBOSE) -o $@ $(NEMU_PATH_WEBSERVICE)/websrv-python.xsl $<

$(NEMUWEB_WS_PYTHON): $(NEMUWEB_WSDL) $(NEMUWEBSERVICE_WSDL)
	$(call MSG_GENERATE,,$@, WS Python bindings)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(MKDIR) -p $(@D)
# Try both w/o and with --file option
	$(QUIET)$(REDIRECT) -C $(@D) -- $(SHELL) -c "$(NEMU_WSDL2PY) -b $(NEMUWEBSERVICE_WSDL) || $(NEMU_WSDL2PY) -b  --file $(NEMUWEBSERVICE_WSDL)"
	$(QUIET)$(APPEND) $@ ''

$(NEMUWEB_WS_PERL): $(NEMUWEB_WSDL) $(NEMUWEBSERVICE_WSDL)
	$(call MSG_GENERATE,,$@, WS Perl bindings)
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(REDIRECT) -C $(@D) -- $(NEMU_STUBMAKER) file://$(NEMUWEBSERVICE_WSDL)
# Ugly, ugly, ugly, make me right once
	$(QUIET)$(SED) -e "s+http://www.virtualbox.org/Service+http://www.virtualbox.org/+" --output $(NEMUWEB_WS_PERL).tmp $(NEMUWEB_WS_PERL)
	$(QUIET)$(MV) $(NEMUWEB_WS_PERL).tmp $(NEMUWEB_WS_PERL)
	$(QUIET)$(APPEND) $@ ''

$(NEMUWEB_WS_PHP): $(NEMUWEB_IDL_SRC) $(NEMU_PATH_WEBSERVICE)/websrv-php.xsl
	$(call MSG_GENERATE,,$@,$(NEMUWEB_IDL_SRC) using websrv-php.xsl)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(NEMU_XSLTPROC) $(NEMUWEB_XSLTPROC_VERBOSE) -o $@ $(NEMU_PATH_WEBSERVICE)/websrv-php.xsl $<

endif # NEMU_ONLY_SDK

# generate typemap.dat (used by wsdl2h) from main XIDL file
$(NEMUWEB_TYPEMAP): $(NEMUWEB_IDL_SRC) $(NEMU_PATH_WEBSERVICE)/websrv-typemap.xsl $(NEMU_PATH_IDL)/typemap-shared.inc.xsl $(RECOMPILE_ON_MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@,$(NEMUWEB_IDL_SRC) using websrv-typemap.xsl)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(NEMU_XSLTPROC) $(NEMUWEB_XSLTPROC_VERBOSE) -o $@ $(NEMU_PATH_WEBSERVICE)/websrv-typemap.xsl $<

# generate gsoap pseudo-C header file from that WSDL; once via XSLT...
$(NEMUWEB_GSOAPH_FROM_XSLT): $(NEMUWEB_WSDL) $(NEMU_PATH_WEBSERVICE)/websrv-wsdl2gsoapH.xsl $(NEMU_PATH_IDL)/typemap-shared.inc.xsl $(RECOMPILE_ON_MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@,$(NEMUWEB_WSDL) using websrv-wsdl2gsoapH.xsl)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(NEMU_XSLTPROC) $(NEMUWEB_XSLTPROC_VERBOSE) -o $@ $(NEMU_PATH_WEBSERVICE)/websrv-wsdl2gsoapH.xsl $<

NEMU_NSMAP = $(NEMUWEB_OUT_DIR)/nemuwebsrv.nsmap
$(NEMU_NSMAP): $(NEMUWEB_IDL_SRC) $(NEMU_PATH_WEBSERVICE)/websrv-nsmap.xsl $(NEMU_PATH_IDL)/typemap-shared.inc.xsl $(RECOMPILE_ON_MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@,$(NEMUWEB_IDL_SRC) using websrv-nsmap.xsl)
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(NEMU_XSLTPROC) $(NEMUWEB_XSLTPROC_VERBOSE) -o $@ $(NEMU_PATH_WEBSERVICE)/websrv-nsmap.xsl $<

ifdef NEMU_GSOAP_INSTALLED
# ... and once with the gSOAP tool (just for comparison, we don't use it for licensing reasons)
$(NEMUWEB_GSOAPH_FROM_GSOAP): $(NEMUWEB_WSDL) $(NEMUWEB_TYPEMAP) | $$(dir $$@)
	$(call MSG_GENERATE,,$@,)
	$(QUIET)$(RM) -f -- $@
	$(NEMU_WSDL2H) $(NEMUWEB_WSDL_VERBOSE) -t$(NEMUWEB_TYPEMAP) -nnemu -o $@ $<

# this sets the gsoap header that we use for further compilation; if stuff works, then the
# one we generate via XSLT produces the same end result as the one from the gSOAP tool;
# with this variable we can swap for testing, but shipped code must use NEMUWEB_GSOAPH_FROM_XSLT
GSOAPH_RELEVANT = $(NEMUWEB_GSOAPH_FROM_XSLT)

# wsdl2h -v: verbose
# wsdl2h -e: don't qualify enum names
# wsdl2h -n<prefix>: namespace header prefix

## @todo change this to state explicitly what will be generated?

# generate server and client code from gsoap pseudo-C header file
$(NEMUWEB_OUT_DIR)/gsoap_generate_all_ts \
+ $(NEMUWEB_OUT_DIR)/soapH.h \
+ $(NEMUWEB_OUT_DIR)/soapStub.h \
+ $(NEMUWEB_OUT_DIR)/soapC.cpp \
+ $(NEMUWEB_OUT_DIR)/soapClient.cpp \
+ $(NEMUWEB_OUT_DIR)/soapServer.cpp \
: $(NEMUWEB_GSOAPH_FROM_GSOAP) $(NEMUWEB_GSOAPH_FROM_XSLT) $(NEMU_NSMAP) $(RECOMPILE_ON_MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,lots of files,$(GSOAPH_RELEVANT))
	$(RM) -f $@
	$(REDIRECT) -C $(NEMUWEB_OUT_DIR) -- $(NEMU_SOAPCPP2) $(NEMUWEB_SOAPCPP2_SKIP_FILES) -L -2 -w -I$(NEMU_PATH_GSOAP_IMPORT) $(GSOAPH_RELEVANT)
	$(APPEND) $@ done

# Copy the generated headers and stuff.  This was split into a separate rule
# way back because we thought we could use $(wildcard ) and avoid the shell,
# however we cannot as it is subject to caching.  Let the shell do the globbing.
# GSOAP versions 2.8 and later do not generate the unneeded soapnemu*.h files
# any more. Ignoring the exit code is the simple solution, accepting the error.
$(NEMUWEB_OUT_DIR)/gsoap_copy_all_ts: $(NEMUWEB_OUT_DIR)/gsoap_generate_all_ts | $$(dir $$@)
	$(RM) -f $@
	$(MKDIR) -p $(PATH_TARGET_SOAPDEMOXML) $(PATH_TARGET_SOAPDEMOHEADERS) $(PATH_TARGET_SOAPDEMONSMAPS)
ifdef NEMU_GSOAP_VERBOSE
	$(MV_EXT) -f -- $(NEMUWEB_OUT_DIR)/*.req.xml $(NEMUWEB_OUT_DIR)/*.res.xml $(PATH_TARGET_SOAPDEMOXML)/
endif
	-$(MV_EXT) -f -- $(NEMUWEB_OUT_DIR)/soapnemu*.h $(PATH_TARGET_SOAPDEMOHEADERS)/
	$(MV_EXT) -f -- $(NEMUWEB_OUT_DIR)/nemuBinding.nsmap $(PATH_TARGET_SOAPDEMONSMAPS)/
	$(APPEND) $@ done

$(PATH_TARGET_SOAPDEMONSMAPS) \
$(PATH_TARGET_SOAPDEMOHEADERS)/soapnemuBindingProxy.h \
$(PATH_TARGET_SOAPDEMOHEADERS)/soapnemuBindingObject.h: $(NEMUWEB_OUT_DIR)/gsoap_copy_all_ts

# soapcpp2 -2: generate SOAP 1.2 calls
# soapcpp2 -S: server-side code only
# soapcpp2 -L: don't generate soapClientLib/soapServerLib
# soapcpp2 -w: don't generate WSDL and schema files
# soapcpp2 -x: don't generate sample XML files

ifndef NEMU_WITHOUT_SPLIT_SOAPC
#
# Split up the soapC.cpp monster into manageable bits that can be
# built in parallel and without exhausting all available memory.
#
$(NEMUWEB_OUT_DIR)/soapC-1.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-2.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-3.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-4.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-5.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-6.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-7.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-8.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-9.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-10.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-11.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-12.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-13.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-14.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-15.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-16.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-17.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-18.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-19.cpp \
+ $(NEMUWEB_OUT_DIR)/soapC-20.cpp \
: $(NEMUWEB_OUT_DIR)/soapC.cpp $$(split-soapC_1_TARGET) | $$(dir $$@)
	$(RM) -f -- $(wildcard $(NEMUWEB_OUT_DIR)/soapC-?.cpp $(NEMUWEB_OUT_DIR)/soapC-??.cpp)
	$(split-soapC_1_TARGET) $(NEMUWEB_OUT_DIR)/soapC.cpp $(NEMUWEB_OUT_DIR) 20
endif # !NEMU_WITHOUT_SPLIT_SOAPC

endif # NEMU_GSOAP_INSTALLED



# generate method maps in server: map wsdl operations to com/xpcom method calls
$(NEMUWEB_OUT_DIR)/methodmaps.cpp: $(NEMUWEB_IDL_SRC) $(NEMU_PATH_WEBSERVICE)/websrv-cpp.xsl $(NEMU_PATH_IDL)/typemap-shared.inc.xsl $(RECOMPILE_ON_MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@,$(NEMUWEB_IDL_SRC) using websrv-cpp.xsl)
	$(QUIET)$(NEMU_XSLTPROC) -o $@ $(NEMU_PATH_WEBSERVICE)/websrv-cpp.xsl $<

# generate C file which contains nemuweb.wsdl
$$(NEMUWEB_OUT_DIR)/nemuweb-wsdl.c: $(NEMUWEB_WSDL) $(NEMU_BIN2C)
	$(call MSG_TOOL,bin2c,nemuweb-wsdl,$<,$@)
	$(QUIET)$(NEMU_BIN2C) -ascii NemuWebWSDL $< $@


ifdef NEMU_ONLY_SDK

$(NEMUWEB_JAXWSSAMPLE): $(NEMU_PATH_WEBSERVICE)/samples/java/jax-ws/clienttest.java
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(MKDIR) -p $(NEMUWEB_SAMPLES_JAXWS_DIR)
	$(QUIET)$(SED) -e 's/{NEMU_API_SUFFIX}/$(NEMU_API_SUFFIX)/' <  $< >  $@

$(NEMUWEB_METRICSAMPLE): $(NEMU_PATH_WEBSERVICE)/samples/java/jax-ws/metrictest.java
	$(QUIET)$(RM) -f -- $@
	$(QUIET)$(MKDIR) -p $(NEMUWEB_SAMPLES_JAXWS_DIR)
	$(QUIET)$(SED) -e 's/{NEMU_API_SUFFIX}/$(NEMU_API_SUFFIX)/' <  $< >  $@

endif # NEMU_ONLY_SDK

include $(FILE_KBUILD_SUB_FOOTER)
